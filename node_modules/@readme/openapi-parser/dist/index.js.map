{"version":3,"sources":["../src/index.ts","../src/lib/index.ts","../src/util.ts","../src/repair.ts","../src/validators/schema.ts","../src/lib/reduceAjvErrors.ts","../src/validators/spec/index.ts","../src/validators/spec/openapi.ts","../src/validators/spec/swagger.ts","../src/validators/spec.ts"],"sourcesContent":["import type { APIDocument, ParserOptions, ValidationResult, ErrorDetails, WarningDetails } from './types.js';\n\nimport { $RefParser, dereferenceInternal, MissingPointerError } from '@apidevtools/json-schema-ref-parser';\n\nimport { isSwagger, isOpenAPI } from './lib/index.js';\nimport { convertOptionsForParser, normalizeArguments, repairSchema } from './util.js';\nimport { validateSchema } from './validators/schema.js';\nimport { validateSpec } from './validators/spec.js';\n\nexport type { ParserOptions, ValidationResult, ErrorDetails, WarningDetails };\n\n/**\n * Parses the given API definition, in JSON or YAML format, and returns it as a JSON object. This\n * method **does not** resolve `$ref` pointers or dereference anything. It simply parses _one_ file\n * and returns it.\n *\n * @param api - A file path or URL to a JSON Schema object, or the JSON Schema object itself.\n * @param options\n */\nexport async function parse<S extends APIDocument = APIDocument>(api: S | string, options?: ParserOptions): Promise<S> {\n  const args = normalizeArguments<S>(api);\n  const parserOptions = convertOptionsForParser(options);\n\n  const parser = new $RefParser<S>();\n  const schema = await parser.parse(args.path, args.schema, parserOptions);\n\n  // If necessary, repair the schema of any anomalies and quirks.\n  repairSchema(schema, args.path);\n\n  return schema;\n}\n\n/**\n * Bundles all referenced files and URLs into a single API definition that only has _internal_\n * `$ref` pointers. This lets you split up your definition however you want while you're building\n * it, but later combine all those files together when it's time to package or distribute the API\n * definition to other people. The resulting definition size will be small, since it will still\n * contain _internal_ JSON references rather than being fully-dereferenced.\n *\n * @param api - A file path or URL to a JSON Schema object, or the JSON Schema object itself.\n * @param options\n */\nexport async function bundle<S extends APIDocument = APIDocument>(\n  api: S | string,\n  options?: ParserOptions,\n): Promise<S> {\n  const args = normalizeArguments<S>(api);\n  const parserOptions = convertOptionsForParser(options);\n\n  const parser = new $RefParser<S>();\n  await parser.bundle(args.path, args.schema, parserOptions);\n\n  // If necessary, repair the schema of any anomalies and quirks.\n  repairSchema(parser.schema, args.path);\n\n  return parser.schema;\n}\n\n/**\n * Dereferences all `$ref` pointers in the supplied API definition, replacing each reference with\n * its resolved value. This results in an API definition that does not contain _any_ `$ref`\n * pointers. Instead, it's a normal JSON object tree that can easily be crawled and used just like\n * any other object. This is great for programmatic usage, especially when using tools that don't\n * understand JSON references.\n *\n * @param api - A file path or URL to a JSON Schema object, or the JSON Schema object itself.\n * @param options\n */\nexport async function dereference<S extends APIDocument = APIDocument>(\n  api: S | string,\n  options?: ParserOptions,\n): Promise<S> {\n  const args = normalizeArguments<S>(api);\n  const parserOptions = convertOptionsForParser(options);\n\n  const parser = new $RefParser<S>();\n  await parser.dereference(args.path, args.schema, parserOptions);\n\n  // If necessary, repair the schema of any anomalies and quirks.\n  repairSchema(parser.schema, args.path);\n\n  return parser.schema;\n}\n\n/**\n * Validates the API definition against the Swagger 2.0, OpenAPI 3.0, or OpenAPI 3.1 specifications.\n *\n * In addition to validating the API definition against their respective specification schemas it\n * will also be validated against specific areas that aren't covered by the Swagger or OpenAPI\n * schemas, such as duplicate parameters, invalid component schema names, or duplicate\n * `operationId` values.\n *\n * If validation fails an error will be thrown with information about what, and where, the error\n * lies within the API definition.\n *\n * Internally this method invokes [`dereference()`](#dereference) so the returned object, whether\n * its a Swagger or OpenAPI definition, will be fully dereferenced.\n *\n * @see {@link https://github.com/OAI/OpenAPI-Specification/tree/main/schemas/v2.0}\n * @see {@link https://github.com/OAI/OpenAPI-Specification/tree/main/schemas/v3.0}\n * @see {@link https://github.com/OAI/OpenAPI-Specification/tree/main/schemas/v3.1}\n * @param api - A file path or URL to a JSON Schema object, or the JSON Schema object itself.\n * @param options\n */\nexport async function validate<S extends APIDocument, Options extends ParserOptions>(\n  api: S | string,\n  options?: Options,\n): Promise<ValidationResult> {\n  const args = normalizeArguments<S>(api);\n  const parserOptions = convertOptionsForParser(options);\n\n  let result: ValidationResult;\n\n  // ZSchema doesn't support circular objects, so don't dereference circular $refs yet\n  // (see https://github.com/zaggino/z-schema/issues/137)\n  const circular$RefOption = parserOptions.dereference.circular;\n  parserOptions.dereference.circular = 'ignore';\n\n  const parser = new $RefParser<S>();\n  try {\n    await parser.dereference(args.path, args.schema, parserOptions);\n  } catch (err) {\n    // `json-schema-ref-parser` will throw exceptions on things like `$ref` pointers that can't\n    // be resolved so we need to capture and reformat those into our expected `ValidationResult`\n    // format.\n    if (err instanceof MissingPointerError) {\n      return {\n        valid: false,\n        errors: [{ message: err.message }],\n        warnings: [],\n        additionalErrors: 0,\n        specification: null,\n      };\n    }\n\n    throw err;\n  }\n\n  if (!isSwagger(parser.schema) && !isOpenAPI(parser.schema)) {\n    return {\n      valid: false,\n      errors: [{ message: 'Supplied schema is not a valid API definition.' }],\n      warnings: [],\n      additionalErrors: 0,\n      specification: null,\n    };\n  }\n\n  // Restore the original options, now that we're done dereferencing\n  parserOptions.dereference.circular = circular$RefOption;\n\n  // Validate the API against the OpenAPI or Swagger JSON schema definition.\n  // NOTE: This is safe to do, because we haven't dereferenced circular $refs yet\n  result = validateSchema(parser.schema, options);\n  if (!result.valid) {\n    return result;\n  }\n\n  if (parser.$refs?.circular) {\n    if (circular$RefOption === true) {\n      // The API has circular reference so we need to do a second pass to fully dereference it.\n      dereferenceInternal<S>(parser, parserOptions);\n    } else if (circular$RefOption === false) {\n      // The API has circular references but we're configured to not permit that.\n      throw new ReferenceError(\n        'The API contains circular references but the validator is configured to not permit them.',\n      );\n    }\n  }\n\n  // Validate the API against the OpenAPI or Swagger specification.\n  const rules = options?.validate?.rules?.openapi;\n  result = validateSpec(parser.schema, {\n    openapi: {\n      'array-without-items': rules?.['array-without-items'] || 'error',\n      'duplicate-non-request-body-parameters': rules?.['duplicate-non-request-body-parameters'] || 'error',\n      'duplicate-operation-id': rules?.['duplicate-operation-id'] || 'error',\n      'non-optional-path-parameters': rules?.['non-optional-path-parameters'] || 'error',\n      'path-parameters-not-in-parameters': rules?.['path-parameters-not-in-parameters'] || 'error',\n      'path-parameters-not-in-path': rules?.['path-parameters-not-in-path'] || 'error',\n    },\n  });\n\n  return result;\n}\n\n/**\n * A utility to transform the `ValidationResult` from a `validate()` call into a human-readable\n * string.\n *\n */\nexport function compileErrors(result: ValidationResult): string {\n  const specName = result.specification || 'API definition';\n  const status = !result.valid ? 'failed' : 'succeeded, but with warnings';\n\n  const message: string[] = [`${specName} schema validation ${status}.`];\n\n  if (result.valid === false) {\n    if (result.errors.length) {\n      message.push(...result.errors.map(err => err.message));\n    }\n  }\n\n  if (result.warnings.length) {\n    if (result.valid === false && result.errors.length) {\n      message.push('We have also found some additional warnings:');\n    }\n\n    message.push(...result.warnings.map(warn => warn.message));\n  }\n\n  if (result.valid === false && result.additionalErrors > 0) {\n    message.push(\n      `Plus an additional ${result.additionalErrors} errors. Please resolve the above and re-run validation to see more.`,\n    );\n  }\n\n  return message.join('\\n\\n');\n}\n","import type { OpenAPIV2, OpenAPIV3, OpenAPIV3_1 } from 'openapi-types';\n\n/**\n * Regular expression that matches path parameter templating.\n *\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#path-templating}\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md#path-templating}\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#path-templating}\n */\nexport const pathParameterTemplateRegExp: RegExp = /\\{([^/}]+)}/g;\n\n/**\n * List of HTTP verbs used for OperationItem as per the OpenAPI and Swagger specifications\n *\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#path-item-object}\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#path-item-object}\n */\nexport const supportedHTTPMethods = ['get', 'post', 'put', 'delete', 'patch', 'options', 'head', 'trace'] as const;\nexport const swaggerHTTPMethods = ['get', 'put', 'post', 'delete', 'options', 'head', 'patch'] as const;\n\n/**\n * Is a given object a Swagger API definition?\n *\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function isSwagger(schema: any): schema is OpenAPIV2.Document {\n  return 'swagger' in schema && schema.swagger !== undefined;\n}\n\n/**\n * Is a given object an OpenAPI API definition?\n *\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function isOpenAPI(schema: any): schema is OpenAPIV3_1.Document | OpenAPIV3.Document {\n  return 'openapi' in schema && schema.openapi !== undefined;\n}\n\n/**\n * Is a given object an OpenAPI 3.0 API definition?\n *\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function isOpenAPI30(schema: any): schema is OpenAPIV3.Document {\n  return 'openapi' in schema && schema.openapi !== undefined && schema.openapi.startsWith('3.0');\n}\n\n/**\n * Is a given object an OpenAPI 3.1 API definition?\n *\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function isOpenAPI31(schema: any): schema is OpenAPIV3_1.Document | OpenAPIV3_1.Document {\n  return 'openapi' in schema && schema.openapi !== undefined && schema.openapi.startsWith('3.1');\n}\n\n/**\n * Determine the proper name for the API specification schema used by a given schema.\n *\n */\nexport function getSpecificationName(\n  api: OpenAPIV2.Document | OpenAPIV3_1.Document | OpenAPIV3.Document,\n): 'OpenAPI' | 'Swagger' {\n  return isSwagger(api) ? 'Swagger' : 'OpenAPI';\n}\n","import type { APIDocument, ParserOptions } from './types.js';\nimport type { ParserOptions as $RefParserOptions } from '@apidevtools/json-schema-ref-parser';\n\nimport { getJsonSchemaRefParserDefaultOptions } from '@apidevtools/json-schema-ref-parser';\n\nimport { isOpenAPI } from './lib/index.js';\nimport { fixOasRelativeServers } from './repair.js';\n\n/**\n * If necessary, repair the schema of any anomalies and quirks.\n *\n */\nexport function repairSchema<S extends APIDocument = APIDocument>(schema: S, filePath?: string): void {\n  if (isOpenAPI(schema)) {\n    // This is an OpenAPI v3 schema, check if the configured `servers` have any relative paths and\n    // fix them if the content was pulled from a web resource.\n    fixOasRelativeServers(schema, filePath);\n  }\n}\n\n/**\n * Normalize our library variable arguments into a standard format to be used within\n * `json-schema-ref-parser`.\n *\n */\nexport function normalizeArguments<S extends APIDocument = APIDocument>(\n  api: S | string,\n): { path: string; schema: S | undefined } {\n  return {\n    path: typeof api === 'string' ? api : '',\n    schema: typeof api === 'object' ? (api as S) : undefined,\n  };\n}\n\n/**\n * Convert our option set to be used within `json-schema-ref-parser`.\n *\n */\nexport function convertOptionsForParser(options: ParserOptions): Partial<$RefParserOptions> {\n  const parserOptions = getJsonSchemaRefParserDefaultOptions();\n  return {\n    ...parserOptions,\n    dereference: {\n      ...parserOptions.dereference,\n\n      circular:\n        options?.dereference && 'circular' in options.dereference\n          ? options.dereference.circular\n          : parserOptions.dereference.circular,\n      onCircular: options?.dereference?.onCircular || parserOptions.dereference.onCircular,\n      onDereference: options?.dereference?.onDereference || parserOptions.dereference.onDereference,\n\n      // OpenAPI 3.1 allows for `summary` and `description` properties at the same level as a `$ref`\n      // pointer to be preserved when that `$ref` pointer is dereferenced. The default behavior of\n      // `json-schema-ref-parser` is to discard these properties but this option allows us to\n      // override that behavior.\n      preservedProperties: ['summary', 'description'],\n    },\n\n    resolve: {\n      ...parserOptions.resolve,\n\n      external:\n        options?.resolve && 'external' in options.resolve ? options.resolve.external : parserOptions.resolve.external,\n\n      http: {\n        ...(typeof parserOptions.resolve.http === 'object' ? parserOptions.resolve.http : {}),\n        timeout: options?.resolve?.http && 'timeout' in options.resolve.http ? options.resolve.http.timeout : 5000,\n      },\n    },\n  };\n}\n","import type { OpenAPI, OpenAPIV3, OpenAPIV3_1 } from 'openapi-types';\n\nimport { isOpenAPI, supportedHTTPMethods } from './lib/index.js';\n\n/**\n * This function takes in a `ServerObject`, checks if it has relative path and then fixes it as per\n * the path URL.\n *\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md#server-object}\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#server-object}\n *\n * @param server - The server object to be fixed.\n * @param path - The path (an HTTP(S) url) from where the file was downloaded.\n * @returns The fixed server object\n */\nfunction fixServers(\n  server: OpenAPIV3_1.ReferenceObject | OpenAPIV3.ParameterObject | OpenAPIV3.ServerObject,\n  path: string,\n) {\n  // A server URL starting with \"/\" tells that it is not an HTTP(s) URL.\n  if (server && 'url' in server && server.url && server.url.startsWith('/')) {\n    try {\n      const inUrl = new URL(path);\n\n      // eslint-disable-next-line no-param-reassign\n      server.url = `${inUrl.protocol}//${inUrl.hostname}${server.url}`;\n    } catch {\n      // The server path isn't valid but we shouldn't crash out.\n    }\n  }\n}\n\n/**\n * This function helps fix the relative servers in the API definition file be at root, path or\n * operation's level.\n *\n * From the OpenAPI v3 specification for the `ServerObject` `url` property:\n *\n *    REQUIRED. A URL to the target host. This URL supports Server Variables and MAY be relative,\n *    to indicate that the host location is relative to the location where the OpenAPI document is\n *    being served. Variable substitutions will be made when a variable is named in `{brackets}`.\n *\n * Further the spec says that `servers` property can show up at root level, in `PathItemObject` or\n * in `OperationObject`. However interpretation of the spec says that relative paths for servers\n * should take into account the hostname that serves the OpenAPI file.\n *\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md#server-object}\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#server-object}\n */\nexport function fixOasRelativeServers(schema: OpenAPI.Document, filePath?: string): void {\n  if (!schema || !isOpenAPI(schema) || !filePath || (!filePath.startsWith('http:') && !filePath.startsWith('https:'))) {\n    return;\n  }\n\n  if (schema.servers) {\n    schema.servers.map(server => fixServers(server, filePath)); // Root level servers array's fixup\n  }\n\n  (['paths', 'webhooks'] as const).forEach(component => {\n    if (component in schema) {\n      const schemaElement = schema.paths || {};\n      Object.keys(schemaElement).forEach(path => {\n        const pathItem = schemaElement[path] || {};\n        Object.keys(pathItem).forEach((opItem: keyof typeof pathItem) => {\n          const pathItemElement = pathItem[opItem];\n          if (!pathItemElement) {\n            return;\n          }\n\n          /**\n           * Servers are at the `PathItemObject` level.\n           *\n           * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md#path-item-object}\n           * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#path-item-object}\n           */\n          if (opItem === 'servers' && Array.isArray(pathItemElement)) {\n            pathItemElement.forEach(server => fixServers(server, filePath));\n            return;\n          }\n\n          /**\n           * Servers are at the `OperationObject` level.\n           *\n           * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md#operation-object}\n           * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#operation-object}\n           */\n          if (\n            supportedHTTPMethods.includes(opItem as unknown as (typeof supportedHTTPMethods)[number]) &&\n            typeof pathItemElement === 'object' &&\n            'servers' in pathItemElement &&\n            Array.isArray(pathItemElement.servers)\n          ) {\n            pathItemElement.servers.forEach(server => fixServers(server, filePath));\n          }\n        });\n      });\n    }\n  });\n}\n","import type { ParserOptions, ValidationResult } from '../types.js';\nimport type { OpenAPIV2, OpenAPIV3, OpenAPIV3_1 } from 'openapi-types';\n\nimport betterAjvErrors from '@readme/better-ajv-errors';\nimport { openapi } from '@readme/openapi-schemas';\nimport Ajv from 'ajv/dist/2020.js';\nimport AjvDraft4 from 'ajv-draft-04';\n\nimport { getSpecificationName, isOpenAPI31, isSwagger } from '../lib/index.js';\nimport { reduceAjvErrors } from '../lib/reduceAjvErrors.js';\n\n/**\n * We've had issues with specs larger than 2MB+ with 1,000+ errors causing memory leaks so if we\n * have a spec with more than `LARGE_SPEC_ERROR_CAP` errors and it's **stringified** length is\n * larger than `LARGE_SPEC_LIMITS` then we will only return the first `LARGE_SPEC_ERROR_CAP` errors.\n *\n * Ideally we'd be looking at the byte size of the spec instead of looking at its stringified\n * length value but the Blob API, which we'd use to get its size with `new Blob([str]).size;`, was\n * only recently introduced in Node 15.\n *\n * w/r/t the 5,000,000 limit here: The spec we found causing these memory leaks had a size of\n * 13,934,323 so 5mil seems like a decent cap to start with.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Blob}\n */\nconst LARGE_SPEC_ERROR_CAP = 20;\nconst LARGE_SPEC_SIZE_CAP = 5000000;\n\n/**\n * Determines which version of Ajv to load and prepares it for use.\n *\n */\nfunction initializeAjv(draft04: boolean = true) {\n  const opts = {\n    allErrors: true,\n    strict: false,\n    validateFormats: false,\n  };\n\n  if (draft04) {\n    return new AjvDraft4(opts);\n  }\n\n  return new Ajv(opts);\n}\n\n/**\n * Validates the given Swagger API against the Swagger 2.0 or OpenAPI 3.0 and 3.1 schemas.\n *\n */\nexport function validateSchema(\n  api: OpenAPIV2.Document | OpenAPIV3_1.Document | OpenAPIV3.Document,\n  options: ParserOptions = {},\n): ValidationResult {\n  let ajv;\n\n  // Choose the appropriate schema (Swagger or OpenAPI)\n  let schema;\n  const specificationName = getSpecificationName(api);\n\n  if (isSwagger(api)) {\n    schema = openapi.v2;\n    ajv = initializeAjv();\n  } else if (isOpenAPI31(api)) {\n    schema = openapi.v31legacy;\n\n    /**\n     * There's a bug with Ajv in how it handles `$dynamicRef` in the way that it's used within the\n     * 3.1 schema so we need to do some adhoc workarounds.\n     *\n     * @see {@link https://github.com/OAI/OpenAPI-Specification/issues/2689}\n     * @see {@link https://github.com/ajv-validator/ajv/issues/1573}\n     */\n    const schemaDynamicRef = schema.$defs.schema;\n    if ('$dynamicAnchor' in schemaDynamicRef) {\n      delete schemaDynamicRef.$dynamicAnchor;\n    }\n\n    /* eslint-disable @typescript-eslint/ban-ts-comment */\n    // @ts-expect-error Intentionally setting up this funky schema for an AJV bug.\n    schema.$defs.components.properties.schemas.additionalProperties = schemaDynamicRef;\n    // @ts-expect-error\n    schema.$defs.header.dependentSchemas.schema.properties.schema = schemaDynamicRef;\n    // @ts-expect-error\n    schema.$defs['media-type'].properties.schema = schemaDynamicRef;\n    // @ts-expect-error\n    schema.$defs.parameter.properties.schema = schemaDynamicRef;\n    /* eslint-enable @typescript-eslint/ban-ts-comment */\n\n    ajv = initializeAjv(false);\n  } else {\n    schema = openapi.v3;\n    ajv = initializeAjv();\n  }\n\n  // Validate against the schema\n  const isValid = ajv.validate(schema, api);\n  if (isValid) {\n    // We don't support warnings in our schema validation, only the **spec** validator.\n    return { valid: true, warnings: [], specification: specificationName };\n  }\n\n  let additionalErrors = 0;\n  let reducedErrors = reduceAjvErrors(ajv.errors);\n  if (reducedErrors.length >= LARGE_SPEC_ERROR_CAP) {\n    try {\n      if (JSON.stringify(api).length >= LARGE_SPEC_SIZE_CAP) {\n        additionalErrors = reducedErrors.length - 20;\n        reducedErrors = reducedErrors.slice(0, 20);\n      }\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    } catch (error) {\n      // If we failed to stringify the API definition to look at its size then we should process\n      // all of its errors as-is.\n    }\n  }\n\n  try {\n    // @ts-expect-error typing on the `ErrorObject` that we use here doesn't match what `better-ajv-errors` uses\n    const errors = betterAjvErrors(schema, api, reducedErrors, {\n      format: 'cli-array',\n      colorize: options?.validate?.errors?.colorize || false,\n      indent: 2,\n    });\n\n    return {\n      valid: false,\n      errors,\n      warnings: [],\n      additionalErrors,\n      specification: specificationName,\n    };\n  } catch (err) {\n    // If `better-ajv-errors` fails for whatever reason we should capture and return it. We'll\n    // obviously not show the user all of their validation errors but it's better than nothing.\n    return {\n      valid: false,\n      errors: [{ message: err.message }],\n      warnings: [],\n      additionalErrors,\n      specification: specificationName,\n    };\n  }\n}\n","import type { ErrorObject } from 'ajv';\n\n/**\n * Because of the way that Ajv works, if a validation error occurs deep within a schema there's a\n * chance that errors will also be thrown for its immediate parents, leading to a case where we'll\n * eventually show the error indecipherable errors like \"$ref is missing here!\" instance of what's\n * _actually_ going on where they may have mistyped `enum` as `enumm`.\n *\n * To alleviate this confusing noise, we're compressing Ajv errors down to only surface the deepest\n * point for each lineage, so that if a user typos `enum` as `enumm` we'll surface just that error\n * for them (because really that's **the** error).\n *\n */\nexport function reduceAjvErrors(errors: ErrorObject[]): ErrorObject[] {\n  const flattened = new Map<string, ErrorObject>();\n\n  errors.forEach(err => {\n    // These two errors appear when a child schema of them has a problem and instead of polluting\n    // the user with indecipherable noise we should instead relay the more specific error to them.\n    // If this is all that's present in the stack then as a safety net before we wrap up we'll just\n    // return the original `errors` stack.\n    if ([\"must have required property '$ref'\", 'must match exactly one schema in oneOf'].includes(err.message)) {\n      return;\n    }\n\n    // If this is our first run through let's initialize our dataset and move along.\n    if (!flattened.size) {\n      flattened.set(err.instancePath, err);\n      return;\n    } else if (flattened.has(err.instancePath)) {\n      // If we already have an error recorded for this `instancePath` we can ignore it because we\n      // (likely) already have recorded the more specific error.\n      return;\n    }\n\n    // If this error hasn't already been recorded, maybe it's an error against the same\n    // `instancePath` stack, in which case we should ignore it because the more specific error has\n    // already been recorded.\n    let shouldRecordError = true;\n    flattened.forEach(flat => {\n      if (flat.instancePath.includes(err.instancePath)) {\n        shouldRecordError = false;\n      }\n    });\n\n    if (shouldRecordError) {\n      flattened.set(err.instancePath, err);\n    }\n  });\n\n  // If we weren't able to fold errors down for whatever reason just return the original stack.\n  if (!flattened.size) {\n    return errors;\n  }\n\n  return [...flattened.values()];\n}\n","import type { ErrorDetails, WarningDetails } from '../../types.js';\n\nexport abstract class SpecificationValidator {\n  errors: ErrorDetails[] = [];\n\n  warnings: WarningDetails[] = [];\n\n  protected reportError(message: string): void {\n    this.errors.push({ message });\n  }\n\n  protected reportWarning(message: string): void {\n    this.warnings.push({ message });\n  }\n\n  abstract run(): void;\n}\n","import type { ParserRulesOpenAPI } from '../../types.js';\nimport type { OpenAPIV3, OpenAPIV3_1 } from 'openapi-types';\n\nimport { supportedHTTPMethods, pathParameterTemplateRegExp, isOpenAPI31, isOpenAPI30 } from '../../lib/index.js';\n\nimport { SpecificationValidator } from './index.js';\n\ntype ParameterObject =\n  | (OpenAPIV3_1.ParameterObject | OpenAPIV3_1.ReferenceObject)\n  | (OpenAPIV3.ParameterObject | OpenAPIV3.ReferenceObject);\n\n/**\n * Validates parts of the OpenAPI 3.0 and 3.1 specification that aren't covered by their JSON\n * Schema definitions.\n *\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md}\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md}\n */\nexport class OpenAPISpecificationValidator extends SpecificationValidator {\n  api: OpenAPIV3_1.Document | OpenAPIV3.Document;\n\n  rules: ParserRulesOpenAPI;\n\n  constructor(api: OpenAPIV3_1.Document | OpenAPIV3.Document, rules: ParserRulesOpenAPI) {\n    super();\n\n    this.api = api;\n    this.rules = rules;\n  }\n\n  run(): void {\n    const operationIds: string[] = [];\n    Object.keys(this.api.paths || {}).forEach(pathName => {\n      const path = this.api.paths[pathName];\n      const pathId = `/paths${pathName}`;\n\n      if (path && pathName.startsWith('/')) {\n        this.validatePath(path, pathId, operationIds);\n      }\n    });\n\n    /**\n     * There's a problem with how the 3.0 schema uses `patternProperties` for defining the format of\n     * scheme names that it ignores anything that doesn't match, so if you for example have a space\n     * in a schema name it'll be seen as valid when it should instead trigger a validation error.\n     *\n     * @see {@link https://github.com/APIDevTools/swagger-parser/issues/184}\n     */\n    if (isOpenAPI30(this.api)) {\n      if (this.api.components) {\n        Object.keys(this.api.components).forEach((componentType: keyof typeof this.api.components) => {\n          Object.keys(this.api.components[componentType]).forEach(componentName => {\n            if (!/^[a-zA-Z0-9.\\-_]+$/.test(componentName)) {\n              const componentId = `/components/${componentType}/${componentName}`;\n\n              this.reportError(\n                `\\`${componentId}\\` has an invalid name. Component names should match against: /^[a-zA-Z0-9.-_]+$/`,\n              );\n            }\n          });\n        });\n      }\n    }\n\n    /**\n     * OpenAPI 3.1 brought the addition of `webhooks` and made `paths` optional however the\n     * specification requires that one or the other be present, and not be empty. Unfortunately the\n     * JSON Schema for the specification is unable to specify this.\n     *\n     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#openapi-document}\n     */\n    if (isOpenAPI31(this.api)) {\n      if (!Object.keys(this.api.paths || {}).length && !Object.keys(this.api.webhooks || {}).length) {\n        this.reportError('OpenAPI 3.1 definitions must contain at least one entry in either `paths` or `webhook`.');\n      }\n    }\n  }\n\n  /**\n   * Validates the given path.\n   *\n   */\n  private validatePath(\n    path: OpenAPIV3_1.PathItemObject | OpenAPIV3.PathItemObject,\n    pathId: string,\n    operationIds: string[],\n  ) {\n    supportedHTTPMethods.forEach(operationName => {\n      const operation = path[operationName];\n      const operationId = `${pathId}/${operationName}`;\n\n      if (operation) {\n        const declaredOperationId = operation.operationId;\n        if (declaredOperationId) {\n          if (!operationIds.includes(declaredOperationId)) {\n            operationIds.push(declaredOperationId);\n          } else if (this.rules['duplicate-operation-id'] === 'warning') {\n            this.reportWarning(`The operationId \\`${declaredOperationId}\\` is duplicated and should be made unique.`);\n          } else {\n            this.reportError(`The operationId \\`${declaredOperationId}\\` is duplicated and must be made unique.`);\n          }\n        }\n\n        this.validateParameters(path, pathId, operation, operationId);\n\n        Object.keys(operation.responses || {}).forEach(responseCode => {\n          const response = operation.responses[responseCode];\n          const responseId = `${operationId}/responses/${responseCode}`;\n          if (response && !('$ref' in response)) {\n            this.validateResponse(response, responseId);\n          }\n        });\n      }\n    });\n  }\n\n  /**\n   * Validates the parameters for the given operation.\n   *\n   */\n  private validateParameters(\n    path: OpenAPIV3_1.PathItemObject | OpenAPIV3.PathItemObject,\n    pathId: string,\n    operation: OpenAPIV3_1.OperationObject | OpenAPIV3.OperationObject,\n    operationId: string,\n  ) {\n    const pathParams = path.parameters || [];\n    const operationParams = operation.parameters || [];\n\n    // Check for duplicate path parameters.\n    this.checkForDuplicates(pathParams, pathId);\n\n    // Check for duplicate operation parameters.\n    this.checkForDuplicates(operationParams, operationId);\n\n    // Combine the path and operation parameters, with the operation params taking precedence over\n    // the path params.\n    const params = pathParams.reduce((combinedParams, value) => {\n      const duplicate = combinedParams.some(param => {\n        if ('$ref' in param || '$ref' in value) {\n          return false;\n        }\n\n        return param.in === value.in && param.name === value.name;\n      });\n\n      if (!duplicate) {\n        combinedParams.push(value);\n      }\n\n      return combinedParams;\n    }, operationParams.slice());\n\n    this.validatePathParameters(params, pathId, operationId);\n    this.validateParameterTypes(params, operationId);\n  }\n\n  /**\n   * Validates path parameters for the given path.\n   *\n   */\n  private validatePathParameters(params: ParameterObject[], pathId: string, operationId: string) {\n    // Find all `{placeholders}` in the path string. And because paths can have path parameters duped\n    // we need to convert this to a unique array so we can eliminate false positives of placeholders\n    // that might be duplicated.\n    const placeholders = [...new Set(pathId.match(pathParameterTemplateRegExp) || [])];\n\n    params\n      .filter(param => 'in' in param)\n      .filter(param => param.in === 'path')\n      .forEach(param => {\n        if (param.required !== true) {\n          if (this.rules['non-optional-path-parameters'] === 'warning') {\n            this.reportWarning(\n              `Path parameters should not be optional. Set \\`required=true\\` for the \\`${param.name}\\` parameter at \\`${operationId}\\`.`,\n            );\n          } else {\n            this.reportError(\n              `Path parameters cannot be optional. Set \\`required=true\\` for the \\`${param.name}\\` parameter at \\`${operationId}\\`.`,\n            );\n          }\n        }\n\n        const match = placeholders.indexOf(`{${param.name}}`);\n        if (match === -1) {\n          const error = `\\`${operationId}\\` has a path parameter named \\`${param.name}\\`, but there is no corresponding \\`{${param.name}}\\` in the path string.`;\n\n          if (this.rules['path-parameters-not-in-path'] === 'warning') {\n            this.reportWarning(error);\n          } else {\n            this.reportError(error);\n          }\n        }\n\n        placeholders.splice(match, 1);\n      });\n\n    if (placeholders.length > 0) {\n      const list = new Intl.ListFormat('en', { style: 'long', type: 'conjunction' }).format(\n        placeholders.map(placeholder => `\\`${placeholder}\\``),\n      );\n\n      const error = `\\`${operationId}\\` is missing path parameter(s) for ${list}.`;\n      if (this.rules['path-parameters-not-in-parameters'] === 'warning') {\n        this.reportWarning(error);\n      } else {\n        this.reportError(error);\n      }\n    }\n  }\n\n  /**\n   * Validates data types of parameters for the given operation.\n   *\n   */\n  private validateParameterTypes(params: ParameterObject[], operationId: string) {\n    params.forEach(param => {\n      if ('$ref' in param) {\n        return;\n      }\n\n      /**\n       * @todo add better handling when `content` is present instead of `schema`.\n       * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md#fixed-fields-10}\n       * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#fixed-fields-10}\n       */\n      if (!param.schema && param.content) {\n        return;\n      } else if ('$ref' in param.schema) {\n        return;\n      }\n\n      const parameterId = `${operationId}/parameters/${param.name}`;\n\n      this.validateSchema(param.schema, parameterId);\n    });\n  }\n\n  /**\n   * Validates the given response object.\n   *\n   */\n  private validateResponse(response: OpenAPIV3_1.ResponseObject | OpenAPIV3.ResponseObject, responseId: string) {\n    Object.keys(response.headers || {}).forEach(headerName => {\n      const header = response.headers[headerName];\n      const headerId = `${responseId}/headers/${headerName}`;\n      if ('$ref' in header) {\n        return;\n      }\n\n      if (header.schema) {\n        if (!('$ref' in header.schema)) {\n          this.validateSchema(header.schema, headerId);\n        }\n      } else if (header.content) {\n        Object.keys(header.content).forEach(mediaType => {\n          if (header.content[mediaType].schema) {\n            if (!('$ref' in header.content[mediaType].schema)) {\n              this.validateSchema(header.content[mediaType].schema || {}, `${headerId}/content/${mediaType}/schema`);\n            }\n          }\n        });\n      }\n    });\n\n    if (response.content) {\n      Object.keys(response.content).forEach(mediaType => {\n        if (response.content[mediaType].schema) {\n          if (!('$ref' in response.content[mediaType].schema)) {\n            this.validateSchema(response.content[mediaType].schema || {}, `${responseId}/content/${mediaType}/schema`);\n          }\n        }\n      });\n    }\n  }\n\n  /**\n   * Validates the given Swagger schema object.\n   *\n   */\n  private validateSchema(schema: OpenAPIV3_1.SchemaObject | OpenAPIV3.SchemaObject, schemaId: string) {\n    if (schema.type === 'array' && !schema.items) {\n      if (this.rules['array-without-items'] === 'warning') {\n        this.reportWarning(`\\`${schemaId}\\` is an array, so it should include an \\`items\\` schema.`);\n      } else {\n        this.reportError(`\\`${schemaId}\\` is an array, so it must include an \\`items\\` schema.`);\n      }\n    }\n  }\n\n  /**\n   * Checks the given parameter list for duplicates.\n   *\n   */\n  private checkForDuplicates(params: ParameterObject[], schemaId: string) {\n    for (let i = 0; i < params.length - 1; i++) {\n      const outer = params[i];\n      for (let j = i + 1; j < params.length; j++) {\n        const inner = params[j];\n        if ('$ref' in outer || '$ref' in inner) {\n          continue;\n        }\n\n        if (outer.name === inner.name && outer.in === inner.in) {\n          const error = `Found multiple \\`${outer.in}\\` parameters named \\`${outer.name}\\` in \\`${schemaId}\\`.`;\n\n          if (this.rules['duplicate-non-request-body-parameters'] === 'warning') {\n            this.reportWarning(error);\n          } else {\n            this.reportError(error);\n          }\n        }\n      }\n    }\n  }\n}\n","import type { IJsonSchema, OpenAPIV2 } from 'openapi-types';\n\nimport { swaggerHTTPMethods, pathParameterTemplateRegExp } from '../../lib/index.js';\n\nimport { SpecificationValidator } from './index.js';\n\n/**\n * Validates parts of the Swagger 2.0 specification that aren't covered by its JSON Schema\n * definitions.\n *\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md}\n */\nexport class SwaggerSpecificationValidator extends SpecificationValidator {\n  api: OpenAPIV2.Document;\n\n  constructor(api: OpenAPIV2.Document) {\n    super();\n\n    this.api = api;\n  }\n\n  run(): void {\n    const operationIds: string[] = [];\n    Object.keys(this.api.paths || {}).forEach(pathName => {\n      const path = this.api.paths[pathName];\n      const pathId = `/paths${pathName}`;\n\n      if (path && pathName.startsWith('/')) {\n        this.validatePath(path, pathId, operationIds);\n      }\n    });\n\n    Object.keys(this.api.definitions || {}).forEach(definitionName => {\n      const definition = this.api.definitions[definitionName];\n      const definitionId = `/definitions/${definitionName}`;\n\n      if (!/^[a-zA-Z0-9.\\-_]+$/.test(definitionName)) {\n        this.reportError(\n          `\\`${definitionId}\\` has an invalid name. Definition names should match against: /^[a-zA-Z0-9.-_]+$/`,\n        );\n      }\n\n      this.validateRequiredPropertiesExist(definition, definitionId);\n    });\n  }\n\n  /**\n   * Validates the given path.\n   *\n   */\n  private validatePath(path: OpenAPIV2.PathItemObject, pathId: string, operationIds: string[]) {\n    swaggerHTTPMethods.forEach(operationName => {\n      const operation = path[operationName];\n      const operationId = `${pathId}/${operationName}`;\n\n      if (operation) {\n        const declaredOperationId = operation.operationId;\n        if (declaredOperationId) {\n          if (!operationIds.includes(declaredOperationId)) {\n            operationIds.push(declaredOperationId);\n          } else {\n            this.reportError(`The operationId \\`${declaredOperationId}\\` is duplicated and must be made unique.`);\n          }\n        }\n\n        this.validateParameters(path, pathId, operation, operationId);\n\n        Object.keys(operation.responses || {}).forEach(responseName => {\n          const response = operation.responses[responseName];\n          if ('$ref' in response || !response) {\n            return;\n          }\n\n          const responseId = `${operationId}/responses/${responseName}`;\n          this.validateResponse(responseName, response, responseId);\n        });\n      }\n    });\n  }\n\n  /**\n   * Validates the parameters for the given operation.\n   *\n   */\n  private validateParameters(\n    path: OpenAPIV2.PathItemObject,\n    pathId: string,\n    operation: OpenAPIV2.OperationObject,\n    operationId: string,\n  ) {\n    const pathParams = (path.parameters || []).filter(param => !('$ref' in param)) as OpenAPIV2.ParameterObject[];\n    const operationParams = (operation.parameters || []).filter(\n      param => !('$ref' in param),\n    ) as OpenAPIV2.ParameterObject[];\n\n    // Check for duplicate path parameters\n    this.checkForDuplicates(pathParams, pathId);\n\n    // Check for duplicate operation parameters\n    this.checkForDuplicates(operationParams, operationId);\n\n    // Combine the path and operation parameters,\n    // with the operation params taking precedence over the path params\n    const params = pathParams.reduce((combinedParams, value) => {\n      const duplicate = combinedParams.some(param => {\n        if ('$ref' in param || '$ref' in value) {\n          return false;\n        }\n        return param.in === value.in && param.name === value.name;\n      });\n      if (!duplicate) {\n        combinedParams.push(value);\n      }\n      return combinedParams;\n    }, operationParams.slice());\n\n    this.validateBodyParameters(params, operationId);\n    this.validatePathParameters(params, pathId, operationId);\n    this.validateParameterTypes(params, operation, operationId);\n  }\n\n  /**\n   * Validates body and formData parameters for the given operation.\n   *\n   */\n  private validateBodyParameters(params: OpenAPIV2.ParameterObject[], operationId: string) {\n    const bodyParams = params.filter(param => param.in === 'body');\n    const formParams = params.filter(param => param.in === 'formData');\n\n    // There can only be one \"body\" parameter\n    if (bodyParams.length > 1) {\n      this.reportError(`\\`${operationId}\\` has ${bodyParams.length} body parameters. Only one is allowed.`);\n    } else if (bodyParams.length > 0 && formParams.length > 0) {\n      // \"body\" params and \"formData\" params are mutually exclusive\n      this.reportError(\n        `\\`${operationId}\\` has \\`body\\` and \\`formData\\` parameters. Only one or the other is allowed.`,\n      );\n    }\n  }\n\n  /**\n   * Validates path parameters for the given path.\n   *\n   */\n  private validatePathParameters(params: OpenAPIV2.ParameterObject[], pathId: string, operationId: string) {\n    // Find all {placeholders} in the path string\n    const placeholders: string[] = pathId.match(pathParameterTemplateRegExp) || [];\n\n    // Check for duplicates\n    for (let i = 0; i < placeholders.length; i++) {\n      for (let j = i + 1; j < placeholders.length; j++) {\n        if (placeholders[i] === placeholders[j]) {\n          this.reportError(`\\`${operationId}\\` has multiple path placeholders named \\`${placeholders[i]}\\`.`);\n        }\n      }\n    }\n\n    params\n      .filter(param => param.in === 'path')\n      .forEach(param => {\n        if (param.required !== true) {\n          this.reportError(\n            `Path parameters cannot be optional. Set \\`required=true\\` for the \\`${param.name}\\` parameter at \\`${operationId}\\`.`,\n          );\n        }\n\n        const match = placeholders.indexOf(`{${param.name}}`);\n        if (match === -1) {\n          this.reportError(\n            `\\`${operationId}\\` has a path parameter named \\`${param.name}\\`, but there is no corresponding \\`{${param.name}}\\` in the path string.`,\n          );\n        }\n\n        placeholders.splice(match, 1);\n      });\n\n    if (placeholders.length > 0) {\n      const list = new Intl.ListFormat('en', { style: 'long', type: 'conjunction' }).format(\n        placeholders.map(placeholder => `\\`${placeholder}\\``),\n      );\n\n      this.reportError(`\\`${operationId}\\` is missing path parameter(s) for ${list}.`);\n    }\n  }\n\n  /**\n   * Validates data types of parameters for the given operation.\n   *\n   */\n  private validateParameterTypes(\n    params: OpenAPIV2.ParameterObject[],\n    operation: OpenAPIV2.OperationObject,\n    operationId: string,\n  ) {\n    params.forEach(param => {\n      const parameterId = `${operationId}/parameters/${param.name}`;\n      let schema;\n\n      switch (param.in) {\n        case 'body':\n          schema = param.schema;\n          break;\n        case 'formData':\n          schema = param;\n          break;\n        default:\n          schema = param;\n      }\n\n      this.validateSchema(schema, parameterId);\n      this.validateRequiredPropertiesExist(schema, parameterId);\n\n      if (schema.type === 'file') {\n        // \"file\" params must consume at least one of these MIME types\n        const formData = /multipart\\/(.*\\+)?form-data/;\n        const urlEncoded = /application\\/(.*\\+)?x-www-form-urlencoded/;\n\n        const consumes = operation.consumes || this.api.consumes || [];\n\n        const hasValidMimeType = consumes.some(consume => {\n          return formData.test(consume) || urlEncoded.test(consume);\n        });\n\n        if (!hasValidMimeType) {\n          this.reportError(\n            `\\`${operationId}\\` has a file parameter, so it must consume \\`multipart/form-data\\` or \\`application/x-www-form-urlencoded\\`.`,\n          );\n        }\n      }\n    });\n  }\n\n  /**\n   * Validates the given response object.\n   *\n   */\n  private validateResponse(code: number | string, response: OpenAPIV2.ResponseObject, responseId: string) {\n    /**\n     * The Swagger JSON Schema allows for any HTTP code between `000` and `999`, where as the OpenAPI\n     * JSON Schema fixed this to require it to be a _known_ code between 100 and 599.\n     *\n     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/f9a2302ee6707cb65f4aaf180fdce9b0a906701e/schemas/v2.0/schema.json#L350}\n     */\n    if (code !== 'default') {\n      if (\n        (typeof code === 'number' && (code < 100 || code > 599)) ||\n        (typeof code === 'string' && (Number(code) < 100 || Number(code) > 599))\n      ) {\n        this.reportError(`\\`${responseId}\\` has an invalid response code: ${code}`);\n      }\n    }\n\n    Object.keys(response.headers || {}).forEach(headerName => {\n      const header = response.headers[headerName];\n      const headerId = `${responseId}/headers/${headerName}`;\n      this.validateSchema(header, headerId);\n    });\n\n    if (response.schema) {\n      if ('$ref' in response.schema) {\n        return;\n      }\n\n      this.validateSchema(response.schema, `${responseId}/schema`);\n    }\n  }\n\n  /**\n   * Validates the given Swagger schema object.\n   *\n   */\n  private validateSchema(schema: OpenAPIV2.SchemaObject, schemaId: string) {\n    if (schema.type === 'array' && !schema.items) {\n      this.reportError(`\\`${schemaId}\\` is an array, so it must include an \\`items\\` schema.`);\n    }\n  }\n\n  /**\n   * Validates that the declared properties of the given Swagger schema object actually exist.\n   *\n   */\n  private validateRequiredPropertiesExist(schema: IJsonSchema, schemaId: string) {\n    // Recursively collects all properties of the schema and its ancestors. They are added to the props object.\n    function collectProperties(schemaObj: IJsonSchema, props: Record<string, IJsonSchema>) {\n      if (schemaObj.properties) {\n        Object.keys(schemaObj.properties).forEach(property => {\n          // eslint-disable-next-line no-prototype-builtins\n          if (schemaObj.properties.hasOwnProperty(property)) {\n            // eslint-disable-next-line no-param-reassign\n            props[property] = schemaObj.properties[property];\n          }\n        });\n      }\n\n      if (schemaObj.allOf) {\n        schemaObj.allOf.forEach(parent => {\n          collectProperties(parent, props);\n        });\n      }\n    }\n\n    if (schema.required && Array.isArray(schema.required)) {\n      const props: Record<string, IJsonSchema> = {};\n      collectProperties(schema, props);\n      schema.required.forEach(requiredProperty => {\n        if (!props[requiredProperty]) {\n          this.reportError(\n            `Property \\`${requiredProperty}\\` is listed as required but does not exist in \\`${schemaId}\\`.`,\n          );\n        }\n      });\n    }\n  }\n\n  /**\n   * Checks the given parameter list for duplicates.\n   *\n   */\n  private checkForDuplicates(params: OpenAPIV2.ParameterObject[], schemaId: string) {\n    for (let i = 0; i < params.length - 1; i++) {\n      const outer = params[i];\n      for (let j = i + 1; j < params.length; j++) {\n        const inner = params[j];\n        if (outer.name === inner.name && outer.in === inner.in) {\n          this.reportError(`Found multiple \\`${outer.in}\\` parameters named \\`${outer.name}\\` in \\`${schemaId}\\`.`);\n        }\n      }\n    }\n  }\n}\n","import type { ParserRulesOpenAPI, ValidationResult } from '../types.js';\nimport type { SpecificationValidator } from './spec/index.js';\nimport type { OpenAPIV2, OpenAPIV3, OpenAPIV3_1 } from 'openapi-types';\n\nimport { getSpecificationName, isOpenAPI } from '../lib/index.js';\n\nimport { OpenAPISpecificationValidator } from './spec/openapi.js';\nimport { SwaggerSpecificationValidator } from './spec/swagger.js';\n\n/**\n * Validates either a Swagger 2.0 or OpenAPI 3.x API definition against cases that aren't covered\n * by their JSON Schema definitions.\n *\n */\nexport function validateSpec(\n  api: OpenAPIV2.Document | OpenAPIV3_1.Document | OpenAPIV3.Document,\n  rules: {\n    openapi: ParserRulesOpenAPI;\n  },\n): ValidationResult {\n  let validator: SpecificationValidator;\n\n  const specificationName = getSpecificationName(api);\n  if (isOpenAPI(api)) {\n    validator = new OpenAPISpecificationValidator(api, rules.openapi);\n  } else {\n    validator = new SwaggerSpecificationValidator(api);\n  }\n\n  validator.run();\n\n  if (!validator.errors.length) {\n    return {\n      valid: true,\n      warnings: validator.warnings,\n      specification: specificationName,\n    };\n  }\n\n  return {\n    valid: false,\n    errors: validator.errors,\n    warnings: validator.warnings,\n    additionalErrors: 0,\n    specification: specificationName,\n  };\n}\n"],"mappings":"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","names":[]}