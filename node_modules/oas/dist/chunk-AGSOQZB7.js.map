{"version":3,"sources":["../src/index.ts","../src/lib/get-auth.ts","../src/lib/get-user-variable.ts"],"sourcesContent":["import type { Extensions } from './extensions.js';\nimport type * as RMOAS from './types.js';\nimport type { OpenAPIV3_1 } from 'openapi-types';\nimport type { Match, ParamData } from 'path-to-regexp';\n\nimport { dereference } from '@readme/openapi-parser';\nimport { pathToRegexp, match } from 'path-to-regexp';\n\nimport {\n  CODE_SAMPLES,\n  HEADERS,\n  OAUTH_OPTIONS,\n  PARAMETER_ORDERING,\n  SAMPLES_LANGUAGES,\n  extensionDefaults,\n  getExtension,\n  hasRootExtension,\n  validateParameterOrdering,\n} from './extensions.js';\nimport { getAuth } from './lib/get-auth.js';\nimport getUserVariable from './lib/get-user-variable.js';\nimport { isPrimitive } from './lib/helpers.js';\nimport { Operation, Webhook } from './operation/index.js';\nimport { findSchemaDefinition, supportedMethods } from './utils.js';\n\ninterface PathMatch {\n  match?: Match<ParamData>;\n  operation: RMOAS.PathsObject;\n  url: {\n    method?: RMOAS.HttpMethods;\n    nonNormalizedPath: string;\n    origin: string;\n    path: string;\n    slugs: Record<string, string>;\n  };\n}\ntype PathMatches = PathMatch[];\n\nconst SERVER_VARIABLE_REGEX = /{([-_a-zA-Z0-9:.[\\]]+)}/g;\n\nfunction ensureProtocol(url: string) {\n  // Add protocol to urls starting with // e.g. //example.com\n  // This is because httpsnippet throws a HARError when it doesnt have a protocol\n  if (url.match(/^\\/\\//)) {\n    return `https:${url}`;\n  }\n\n  // Add protocol to urls with no // within them\n  // This is because httpsnippet throws a HARError when it doesnt have a protocol\n  if (!url.match(/\\/\\//)) {\n    return `https://${url}`;\n  }\n\n  return url;\n}\n\nfunction stripTrailingSlash(url: string) {\n  if (url[url.length - 1] === '/') {\n    return url.slice(0, -1);\n  }\n\n  return url;\n}\n\n/**\n * Normalize a OpenAPI server URL by ensuring that it has a proper HTTP protocol and doesn't have a\n * trailing slash.\n *\n * @param api The API definition that we're processing.\n * @param selected The index of the `servers` array in the API definition that we want to normalize.\n */\nfunction normalizedUrl(api: RMOAS.OASDocument, selected: number) {\n  const exampleDotCom = 'https://example.com';\n  let url;\n  try {\n    url = api.servers[selected].url;\n    // This is to catch the case where servers = [{}]\n    if (!url) throw new Error('no url');\n\n    // Stripping the '/' off the end\n    url = stripTrailingSlash(url);\n\n    // Check if the URL is just a path a missing an origin, for example `/api/v3`. If so, then make\n    // `example.com` the origin to avoid it becoming something invalid like `https:///api/v3`.\n    // RM-1044\n    if (url.startsWith('/') && !url.startsWith('//')) {\n      const urlWithOrigin = new URL(exampleDotCom);\n      urlWithOrigin.pathname = url;\n      url = urlWithOrigin.href;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  } catch (e) {\n    url = exampleDotCom;\n  }\n\n  return ensureProtocol(url);\n}\n\n/**\n * With a URL that may contain server variables, transform those server variables into regex that\n * we can query against.\n *\n * For example, when given `https://{region}.node.example.com/v14` this will return back:\n *\n *    https://([-_a-zA-Z0-9:.[\\\\]]+).node.example.com/v14\n *\n * @param url URL to transform\n */\nfunction transformUrlIntoRegex(url: string) {\n  return stripTrailingSlash(url.replace(SERVER_VARIABLE_REGEX, '([-_a-zA-Z0-9:.[\\\\]]+)'));\n}\n\n/**\n * Normalize a path so that we can use it with `path-to-regexp` to do operation lookups.\n *\n * @param path Path to normalize.\n */\nfunction normalizePath(path: string) {\n  return (\n    path\n      // This regex transforms `{pathParam}` into `:pathParam` so we can regex against it. We're\n      // also handling quirks here like if there's an optional proceeding or trailing curly bracket\n      // (`{{pathParam}` or `{pathParam}}`) as any unescaped curlys, which would be present in\n      // `:pathParam}`, will throw a regex exception.\n      .replace(/({?){(.*?)}(}?)/g, (str, ...args) => {\n        // If a path contains a path parameter with hyphens, like `:dlc-release`, when it's regexd\n        // with `path-to-regexp` it match against the `:dlc` portion of the parameter, breaking all\n        // matching against the full path.\n        //\n        // For example on `/games/:game/dlc/:dlc-release` the regex that's actually used to search\n        // against a path like `/games/destiny-2/dlc/witch-queen` is the following:\n        //    /^\\/games(?:\\/([^\\/#\\?]+?))\\/dlc(?:\\/([^\\/#\\?]+?))-release[\\/#\\?]?$/i\n        //\n        // However if `:dlc-release` is rewritten to `:dlcrelease` we end up with a functional\n        // regex: /^\\/games(?:\\/([^\\/#\\?]+?))\\/dlc(?:\\/([^\\/#\\?]+?))[\\/#\\?]?$/i.\n        return `:${args[1].replace('-', '')}`;\n      })\n\n      // In addition to transforming `{pathParam}` into `:pathParam` we also need to escape cases\n      // where a non-variabled colon is next to a variabled-colon because if we don't then\n      // `path-to-regexp` won't be able to correct identify where the variable starts.\n      //\n      // For example if the URL is `/post/:param1::param2` we'll be escaping it to\n      // `/post/:param1\\::param2`.\n      .replace(/::/, '\\\\::')\n\n      // We also need to escape question marks too because they're treated as regex modifiers.\n      .split('?')[0]\n  );\n}\n\n/**\n * Generate path matches for a given path and origin on a set of OpenAPI path objects.\n *\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#paths-object}\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#paths-object}\n * @param paths The OpenAPI Paths Object to process.\n * @param pathName Path to look for a match.\n * @param origin The origin that we're matching against.\n */\nfunction generatePathMatches(paths: RMOAS.PathsObject, pathName: string, origin: string) {\n  const prunedPathName = pathName.split('?')[0];\n  return Object.keys(paths)\n    .map(path => {\n      const cleanedPath = normalizePath(path);\n\n      let matchResult: PathMatch['match'];\n      try {\n        const matchStatement = match(cleanedPath, { decode: decodeURIComponent });\n        matchResult = matchStatement(prunedPathName);\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      } catch (err) {\n        // If path matching fails for whatever reason (maybe they have a malformed path parameter)\n        // then we shouldn't also fail.\n        return;\n      }\n\n      const slugs: Record<string, string> = {};\n\n      if (matchResult && Object.keys(matchResult.params).length) {\n        Object.keys(matchResult.params).forEach(param => {\n          slugs[`:${param}`] = (matchResult.params as Record<string, string>)[param];\n        });\n      }\n\n      // eslint-disable-next-line consistent-return\n      return {\n        url: {\n          origin,\n          path: cleanedPath.replace(/\\\\::/, '::'),\n          nonNormalizedPath: path,\n          slugs,\n        },\n        operation: paths[path],\n        match: matchResult,\n      };\n    })\n    .filter(Boolean)\n    .filter(p => p.match) as PathMatches;\n}\n\n/**\n * @param pathMatches Array of path matches to filter down.\n * @param targetMethod HTTP method to look for.\n * @returns Filtered down path matches.\n */\nfunction filterPathMethods(pathMatches: PathMatches, targetMethod: RMOAS.HttpMethods) {\n  const regExp = pathToRegexp(targetMethod);\n  return pathMatches\n    .map(p => {\n      const captures = Object.keys(p.operation).filter(r => regExp.regexp.exec(r));\n\n      if (captures.length) {\n        const method = captures[0];\n        p.url.method = method.toUpperCase() as RMOAS.HttpMethods;\n\n        return {\n          url: p.url,\n          operation: p.operation[method],\n        };\n      }\n\n      return false;\n    })\n    .filter(Boolean) as { operation: RMOAS.OperationObject; url: PathMatch['url'] }[];\n}\n\n/**\n * @param pathMatches URL and PathsObject matches to narrow down to find a target path.\n * @returns An object containing matches that were discovered in the API definition.\n */\nfunction findTargetPath(pathMatches: { operation: RMOAS.PathsObject; url: PathMatch['url'] }[]) {\n  let minCount = Object.keys(pathMatches[0].url.slugs).length;\n  let operation;\n\n  for (let m = 0; m < pathMatches.length; m += 1) {\n    const selection = pathMatches[m];\n    const paramCount = Object.keys(selection.url.slugs).length;\n    if (paramCount <= minCount) {\n      minCount = paramCount;\n      operation = selection;\n    }\n  }\n\n  return operation;\n}\n\nexport default class Oas {\n  /**\n   * An OpenAPI API Definition.\n   */\n  api: RMOAS.OASDocument;\n\n  /**\n   * The current user that we should use when pulling auth tokens from security schemes.\n   */\n  user: RMOAS.User;\n\n  /**\n   * Internal storage array that the library utilizes to keep track of the times the\n   * {@see Oas.dereference} has been called so that if you initiate multiple promises they'll all\n   * end up returning the same data set once the initial dereference call completed.\n   */\n  protected promises: {\n    reject: any;\n    resolve: any;\n  }[];\n\n  /**\n   * Internal storage array that the library utilizes to keep track of its `dereferencing` state so\n   * it doesn't initiate multiple dereferencing processes.\n   */\n  protected dereferencing: {\n    circularRefs: string[];\n    complete: boolean;\n    processing: boolean;\n  };\n\n  /**\n   * @param oas An OpenAPI definition.\n   * @param user The information about a user that we should use when pulling auth tokens from\n   *    security schemes.\n   */\n  constructor(oas: RMOAS.OASDocument | string, user?: RMOAS.User) {\n    if (typeof oas === 'string') {\n      // eslint-disable-next-line try-catch-failsafe/json-parse\n      oas = JSON.parse(oas) as RMOAS.OASDocument;\n    }\n\n    this.api = oas || ({} as RMOAS.OASDocument);\n    this.user = user || {};\n\n    this.promises = [];\n    this.dereferencing = {\n      processing: false,\n      complete: false,\n      circularRefs: [],\n    };\n  }\n\n  /**\n   * This will initialize a new instance of the `Oas` class. This method is useful if you're using\n   * Typescript and are attempting to supply an untyped JSON object into `Oas` as it will force-type\n   * that object to an `OASDocument` for you.\n   *\n   * @param oas An OpenAPI definition.\n   * @param user The information about a user that we should use when pulling auth tokens from\n   *    security schemes.\n   */\n  static init(oas: Record<string, unknown> | RMOAS.OASDocument, user?: RMOAS.User): Oas {\n    return new Oas(oas as RMOAS.OASDocument, user);\n  }\n\n  /**\n   * Retrieve the OpenAPI version that this API definition is targeted for.\n   */\n  getVersion(): string {\n    if (this.api.openapi) {\n      return this.api.openapi;\n    }\n\n    throw new Error('Unable to recognize what specification version this API definition conforms to.');\n  }\n\n  /**\n   * Retrieve the current OpenAPI API Definition.\n   *\n   */\n  getDefinition(): RMOAS.OASDocument {\n    return this.api;\n  }\n\n  url(selected = 0, variables?: RMOAS.ServerVariable): string {\n    const url = normalizedUrl(this.api, selected);\n    return this.replaceUrl(url, variables || this.defaultVariables(selected)).trim();\n  }\n\n  variables(selected = 0): RMOAS.ServerVariablesObject {\n    let variables: RMOAS.ServerVariablesObject;\n    try {\n      variables = this.api.servers[selected].variables;\n      if (!variables) throw new Error('no variables');\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    } catch (e) {\n      variables = {};\n    }\n\n    return variables;\n  }\n\n  defaultVariables(selected = 0): RMOAS.ServerVariable {\n    const variables = this.variables(selected);\n    const defaults: RMOAS.ServerVariable = {};\n\n    Object.keys(variables).forEach(key => {\n      defaults[key] = getUserVariable(this.user, key) || variables[key].default || '';\n    });\n\n    return defaults;\n  }\n\n  splitUrl(selected = 0): (\n    | {\n        /**\n         * A unique key, where the `value` is concatenated to its index\n         */\n        key: string;\n        type: 'text';\n        value: string;\n      }\n    | {\n        /**\n         * An optional description for the server variable.\n         *\n         * @see {@link https://spec.openapis.org/oas/v3.1.0#fixed-fields-4}\n         */\n        description?: string;\n\n        /**\n         * An enumeration of string values to be used if the substitution options are from a limited set.\n         *\n         * @see {@link https://spec.openapis.org/oas/v3.1.0#fixed-fields-4}\n         */\n        enum?: string[];\n\n        /**\n         * A unique key, where the `value` is concatenated to its index\n         */\n        key: string;\n        type: 'variable';\n        value: string;\n      }\n  )[] {\n    const url = normalizedUrl(this.api, selected);\n    const variables = this.variables(selected);\n\n    return url\n      .split(/({.+?})/)\n      .filter(Boolean)\n      .map((part, i) => {\n        const isVariable = part.match(/[{}]/);\n        const value = part.replace(/[{}]/g, '');\n        // To ensure unique keys, we're going to create a key\n        // with the value concatenated to its index.\n        const key = `${value}-${i}`;\n\n        if (!isVariable) {\n          return {\n            type: 'text',\n            value,\n            key,\n          };\n        }\n\n        const variable = variables?.[value];\n\n        return {\n          type: 'variable',\n          value,\n          key,\n          description: variable?.description,\n          enum: variable?.enum,\n        };\n      });\n  }\n\n  /**\n   * With a fully composed server URL, run through our list of known OAS servers and return back\n   * which server URL was selected along with any contained server variables split out.\n   *\n   * For example, if you have an OAS server URL of `https://{name}.example.com:{port}/{basePath}`,\n   * and pass in `https://buster.example.com:3000/pet` to this function, you'll get back the\n   * following:\n   *\n   *    { selected: 0, variables: { name: 'buster', port: 3000, basePath: 'pet' } }\n   *\n   * Re-supplying this data to `oas.url()` should return the same URL you passed into this method.\n   *\n   * @param baseUrl A given URL to extract server variables out of.\n   */\n  splitVariables(baseUrl: string): RMOAS.Servers | false {\n    const matchedServer = (this.api.servers || [])\n      .map((server, i) => {\n        const rgx = transformUrlIntoRegex(server.url);\n        const found = new RegExp(rgx).exec(baseUrl);\n        if (!found) {\n          return false;\n        }\n\n        // While it'd be nice to use named regex groups to extract path parameters from the URL and\n        // match them up with the variables that we have present in it, JS unfortunately doesn't\n        // support having the groups duplicated. So instead of doing that we need to re-regex the\n        // server URL, this time splitting on the path parameters -- this way we'll be able to\n        // extract the parameter names and match them up with the matched server that we obtained\n        // above.\n        const variables: Record<string, number | string> = {};\n        Array.from(server.url.matchAll(SERVER_VARIABLE_REGEX)).forEach((variable, y) => {\n          variables[variable[1]] = found[y + 1];\n        });\n\n        return {\n          selected: i,\n          variables,\n        };\n      })\n      .filter(Boolean);\n\n    return matchedServer.length ? matchedServer[0] : false;\n  }\n\n  /**\n   * Replace templated variables with supplied data in a given URL.\n   *\n   * There are a couple ways that this will utilize variable data:\n   *\n   *  - Supplying a `variables` object. If this is supplied, this data will always take priority.\n   *    This incoming `variables` object can be two formats:\n   *    `{ variableName: { default: 'value' } }` and `{ variableName: 'value' }`. If the former is\n   *    present, that will take precedence over the latter.\n   *  - If the supplied `variables` object is empty or does not match the current template name,\n   *    we fallback to the data stored in `this.user` and attempt to match against that.\n   *    See `getUserVariable` for some more information on how this data is pulled from `this.user`.\n   *\n   * If no variables supplied match up with the template name, the template name will instead be\n   * used as the variable data.\n   *\n   * @param url A URL to swap variables into.\n   * @param variables An object containing variables to swap into the URL.\n   */\n  replaceUrl(url: string, variables: RMOAS.ServerVariable = {}): string {\n    // When we're constructing URLs, server URLs with trailing slashes cause problems with doing\n    // lookups, so if we have one here on, slice it off.\n    return stripTrailingSlash(\n      url.replace(SERVER_VARIABLE_REGEX, (original: string, key: string) => {\n        if (key in variables) {\n          const data = variables[key];\n          if (typeof data === 'object') {\n            if (!Array.isArray(data) && data !== null && 'default' in data) {\n              return data.default as string;\n            }\n          } else {\n            return data as string;\n          }\n        }\n\n        const userVariable = getUserVariable(this.user, key);\n        if (userVariable) {\n          return userVariable as string;\n        }\n\n        return original;\n      }),\n    );\n  }\n\n  /**\n   * Retrieve an Operation of Webhook class instance for a given path and method.\n   *\n   * @param path Path to lookup and retrieve.\n   * @param method HTTP Method to retrieve on the path.\n   */\n  operation(\n    path: string,\n    method: RMOAS.HttpMethods,\n    opts: {\n      /**\n       * If you prefer to first look for a webhook with this path and method.\n       */\n      isWebhook?: boolean;\n    } = {},\n  ): Operation {\n    // If we're unable to locate an operation for this path+method combination within the API\n    // definition, we should still set an empty schema on the operation in the `Operation` class\n    // because if we don't trying to use any of the accessors on that class are going to fail as\n    // `schema` will be `undefined`.\n    let operation: RMOAS.OperationObject = {\n      parameters: [],\n    };\n\n    if (opts.isWebhook) {\n      const api = this.api as OpenAPIV3_1.Document;\n      // Typecasting this to a `PathsObject` because we don't have `$ref` pointers here.\n      if ((api?.webhooks[path] as RMOAS.PathsObject)?.[method]) {\n        operation = (api.webhooks[path] as RMOAS.PathsObject)[method] as RMOAS.OperationObject;\n        return new Webhook(api, path, method, operation);\n      }\n    }\n\n    if (this?.api?.paths?.[path]?.[method]) {\n      operation = this.api.paths[path][method];\n    }\n\n    return new Operation(this.api, path, method, operation);\n  }\n\n  findOperationMatches(url: string): PathMatches {\n    const { origin, hostname } = new URL(url);\n    const originRegExp = new RegExp(origin, 'i');\n    const { servers, paths } = this.api;\n\n    let pathName;\n    let targetServer;\n    let matchedServer;\n\n    if (!servers || !servers.length) {\n      // If this API definition doesn't have any servers set up let's treat it as if it were\n      // https://example.com because that's the default origin we add in `normalizedUrl` under the\n      // same circumstances. Without this we won't be able to match paths within what is otherwise\n      // a valid OpenAPI definition.\n      matchedServer = {\n        url: 'https://example.com',\n      };\n    } else {\n      matchedServer = servers.find(s => originRegExp.exec(this.replaceUrl(s.url, s.variables || {})));\n      if (!matchedServer) {\n        const hostnameRegExp = new RegExp(hostname);\n        matchedServer = servers.find(s => hostnameRegExp.exec(this.replaceUrl(s.url, s.variables || {})));\n      }\n    }\n\n    // If we **still** haven't found a matching server, then the OAS server URL might have server\n    // variables and we should loosen it up with regex to try to discover a matching path.\n    //\n    // For example if an OAS has `https://{region}.node.example.com/v14` set as its server URL, and\n    // the `this.user` object has a `region` value of `us`, if we're trying to locate an operation\n    // for https://eu.node.example.com/v14/api/esm we won't be able to because normally the users\n    // `region` of `us` will be transposed in and we'll be trying to locate `eu.node.example.com`\n    // in `us.node.example.com` -- which won't work.\n    //\n    // So what this does is transform `https://{region}.node.example.com/v14` into\n    // `https://([-_a-zA-Z0-9[\\\\]]+).node.example.com/v14`, and from there we'll be able to match\n    // https://eu.node.example.com/v14/api/esm and ultimately find the operation matches for\n    // `/api/esm`.\n    if (!matchedServer) {\n      const matchedServerAndPath = servers\n        .map(server => {\n          const rgx = transformUrlIntoRegex(server.url);\n          const found = new RegExp(rgx).exec(url);\n          if (!found) {\n            return undefined;\n          }\n\n          return {\n            matchedServer: server,\n            pathName: url.split(new RegExp(rgx)).slice(-1).pop(),\n          };\n        })\n        .filter(Boolean);\n\n      if (!matchedServerAndPath.length) {\n        return undefined;\n      }\n\n      pathName = matchedServerAndPath[0].pathName;\n      targetServer = {\n        ...matchedServerAndPath[0].matchedServer,\n      };\n    } else {\n      // Instead of setting `url` directly against `matchedServer` we need to set it to an\n      // intermediary object as directly modifying `matchedServer.url` will in turn update\n      // `this.servers[idx].url` which we absolutely do not want to happen.\n      targetServer = {\n        ...matchedServer,\n        url: this.replaceUrl(matchedServer.url, matchedServer.variables || {}),\n      };\n\n      [, pathName] = url.split(new RegExp(targetServer.url, 'i'));\n    }\n\n    if (pathName === undefined) return undefined;\n    if (pathName === '') pathName = '/';\n    const annotatedPaths = generatePathMatches(paths, pathName, targetServer.url);\n    if (!annotatedPaths.length) return undefined;\n\n    return annotatedPaths;\n  }\n\n  /**\n   * Discover an operation in an OAS from a fully-formed URL and HTTP method. Will return an object\n   * containing a `url` object and another one for `operation`. This differs from `getOperation()`\n   * in that it does not return an instance of the `Operation` class.\n   *\n   * @param url A full URL to look up.\n   * @param method The cooresponding HTTP method to look up.\n   */\n  findOperation(url: string, method: RMOAS.HttpMethods): PathMatch {\n    const annotatedPaths = this.findOperationMatches(url);\n    if (!annotatedPaths) {\n      return undefined;\n    }\n\n    const matches = filterPathMethods(annotatedPaths, method) as {\n      operation: RMOAS.PathsObject;\n      url: PathMatch['url']; // @fixme this should actually be an `OperationObject`.\n    }[];\n    if (!matches.length) return undefined;\n    return findTargetPath(matches);\n  }\n\n  /**\n   * Discover an operation in an OAS from a fully-formed URL without an HTTP method. Will return an\n   * object containing a `url` object and another one for `operation`.\n   *\n   * @param url A full URL to look up.\n   */\n  findOperationWithoutMethod(url: string): PathMatch {\n    const annotatedPaths = this.findOperationMatches(url);\n    if (!annotatedPaths) {\n      return undefined;\n    }\n    return findTargetPath(annotatedPaths);\n  }\n\n  /**\n   * Retrieve an operation in an OAS from a fully-formed URL and HTTP method. Differs from\n   * `findOperation` in that while this method will return an `Operation` instance,\n   * `findOperation()` does not.\n   *\n   * @param url A full URL to look up.\n   * @param method The cooresponding HTTP method to look up.\n   */\n  getOperation(url: string, method: RMOAS.HttpMethods): Operation {\n    const op = this.findOperation(url, method);\n    if (op === undefined) {\n      return undefined;\n    }\n\n    return this.operation(op.url.nonNormalizedPath, method);\n  }\n\n  /**\n   * Retrieve an operation in an OAS by an `operationId`.\n   *\n   * If an operation does not have an `operationId` one will be generated in place, using the\n   * default behavior of `Operation.getOperationId()`, and then asserted against your query.\n   *\n   * Note that because `operationId`s are unique that uniqueness does include casing so the ID\n   * you are looking for will be asserted as an exact match.\n   *\n   * @see {Operation.getOperationId()}\n   * @param id The `operationId` to look up.\n   */\n  getOperationById(id: string): Operation | Webhook {\n    let found: Operation | Webhook;\n\n    Object.values(this.getPaths()).forEach(operations => {\n      if (found) return;\n      found = Object.values(operations).find(operation => operation.getOperationId() === id);\n    });\n\n    if (found) {\n      return found;\n    }\n\n    Object.entries(this.getWebhooks()).forEach(([, webhooks]) => {\n      if (found) return;\n      found = Object.values(webhooks).find(webhook => webhook.getOperationId() === id);\n    });\n\n    return found;\n  }\n\n  /**\n   * With an object of user information, retrieve the appropriate API auth keys from the current\n   * OAS definition.\n   *\n   * @see {@link https://docs.readme.com/docs/passing-data-to-jwt}\n   * @param user User\n   * @param selectedApp The user app to retrieve an auth key for.\n   */\n  getAuth(user: RMOAS.User, selectedApp?: number | string): RMOAS.AuthForHAR {\n    if (!this.api?.components?.securitySchemes) {\n      return {};\n    }\n\n    return getAuth(this.api, user, selectedApp);\n  }\n\n  /**\n   * Returns the `paths` object that exists in this API definition but with every `method` mapped\n   * to an instance of the `Operation` class.\n   *\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md#openapi-object}\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#openapi-object}\n   */\n  getPaths(): Record<string, Record<RMOAS.HttpMethods, Operation | Webhook>> {\n    /**\n     * Because a path doesn't need to contain a keyed-object of HTTP methods, we should exclude\n     * anything from within the paths object that isn't a known HTTP method.\n     *\n     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md#fixed-fields-7}\n     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#fixed-fields-7}\n     */\n    const paths: Record<string, Record<RMOAS.HttpMethods, Operation | Webhook>> = {};\n\n    Object.keys(this.api.paths ? this.api.paths : []).forEach(path => {\n      // If this is a specification extension then we should ignore it.\n      if (path.startsWith('x-')) {\n        return;\n      }\n\n      paths[path] = {} as Record<RMOAS.HttpMethods, Operation | Webhook>;\n\n      // Though this library is generally unaware of `$ref` pointers we're making a singular\n      // exception with this accessor out of convenience.\n      if ('$ref' in this.api.paths[path]) {\n        this.api.paths[path] = findSchemaDefinition(this.api.paths[path].$ref, this.api);\n      }\n\n      Object.keys(this.api.paths[path]).forEach((method: RMOAS.HttpMethods) => {\n        if (!supportedMethods.includes(method)) return;\n\n        paths[path][method] = this.operation(path, method);\n      });\n    });\n\n    return paths;\n  }\n\n  /**\n   * Returns the `webhooks` object that exists in this API definition but with every `method`\n   * mapped to an instance of the `Webhook` class.\n   *\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md#openapi-object}\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#openapi-object}\n   */\n  getWebhooks(): Record<string, Record<RMOAS.HttpMethods, Webhook>> {\n    const webhooks: Record<string, Record<RMOAS.HttpMethods, Webhook>> = {};\n    const api = this.api as OpenAPIV3_1.Document;\n\n    Object.keys(api.webhooks ? api.webhooks : []).forEach(id => {\n      webhooks[id] = {} as Record<RMOAS.HttpMethods, Webhook>;\n      Object.keys(api.webhooks[id]).forEach((method: RMOAS.HttpMethods) => {\n        webhooks[id][method] = this.operation(id, method, { isWebhook: true }) as Webhook;\n      });\n    });\n\n    return webhooks;\n  }\n\n  /**\n   * Return an array of all tag names that exist on this API definition.\n   *\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md#openapi-object}\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#openapi-object}\n   * @param setIfMissing If a tag is not present on an operation that operations path will be added\n   *    into the list of tags returned.\n   */\n  getTags(setIfMissing = false): string[] {\n    const allTags = new Set<string>();\n\n    const oasTags =\n      this.api.tags?.map(tag => {\n        return tag.name;\n      }) || [];\n\n    const disableTagSorting = getExtension('disable-tag-sorting', this.api);\n\n    Object.entries(this.getPaths()).forEach(([path, operations]) => {\n      Object.values(operations).forEach(operation => {\n        const tags = operation.getTags();\n        if (setIfMissing && !tags.length) {\n          allTags.add(path);\n          return;\n        }\n\n        tags.forEach(tag => {\n          allTags.add(tag.name);\n        });\n      });\n    });\n\n    Object.entries(this.getWebhooks()).forEach(([path, webhooks]) => {\n      Object.values(webhooks).forEach(webhook => {\n        const tags = webhook.getTags();\n        if (setIfMissing && !tags.length) {\n          allTags.add(path);\n          return;\n        }\n\n        tags.forEach(tag => {\n          allTags.add(tag.name);\n        });\n      });\n    });\n\n    // Tags that exist only on the endpoint\n    const endpointTags: string[] = [];\n    // Tags that the user has defined in the `tags` array\n    const tagsArray: string[] = [];\n\n    // Distinguish between which tags exist in the `tags` array and which tags\n    // exist only at the endpoint level. For tags that exist only at the\n    // endpoint level, we'll just tack that on to the end of the sorted tags.\n    if (disableTagSorting) {\n      return Array.from(allTags);\n    }\n\n    Array.from(allTags).forEach(tag => {\n      if (oasTags.includes(tag)) {\n        tagsArray.push(tag);\n      } else {\n        endpointTags.push(tag);\n      }\n    });\n\n    let sortedTags = tagsArray.sort((a, b) => {\n      return oasTags.indexOf(a) - oasTags.indexOf(b);\n    });\n\n    sortedTags = sortedTags.concat(endpointTags);\n\n    return sortedTags;\n  }\n\n  /**\n   * Determine if a given a custom specification extension exists within the API definition.\n   *\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#specification-extensions}\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#specification-extensions}\n   * @param extension Specification extension to lookup.\n   */\n  hasExtension(extension: string): boolean {\n    return hasRootExtension(extension, this.api);\n  }\n\n  /**\n   * Retrieve a custom specification extension off of the API definition.\n   *\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#specification-extensions}\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#specification-extensions}\n   * @param extension Specification extension to lookup.\n   */\n  getExtension(extension: string | keyof Extensions, operation?: Operation): any {\n    return getExtension(extension, this.api, operation);\n  }\n\n  /**\n   * Determine if a given OpenAPI custom extension is valid or not.\n   *\n   * @see {@link https://docs.readme.com/docs/openapi-extensions}\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#specification-extensions}\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#specification-extensions}\n   * @param extension Specification extension to validate.\n   * @throws\n   */\n  validateExtension(extension: keyof Extensions): void {\n    if (this.hasExtension('x-readme')) {\n      const data = this.getExtension('x-readme') as Extensions;\n      if (typeof data !== 'object' || Array.isArray(data) || data === null) {\n        throw new TypeError('\"x-readme\" must be of type \"Object\"');\n      }\n\n      if (extension in data) {\n        if ([CODE_SAMPLES, HEADERS, PARAMETER_ORDERING, SAMPLES_LANGUAGES].includes(extension)) {\n          if (!Array.isArray(data[extension])) {\n            throw new TypeError(`\"x-readme.${extension}\" must be of type \"Array\"`);\n          }\n\n          if (extension === PARAMETER_ORDERING) {\n            validateParameterOrdering(data[extension], `x-readme.${extension}`);\n          }\n        } else if (extension === OAUTH_OPTIONS) {\n          if (typeof data[extension] !== 'object') {\n            throw new TypeError(`\"x-readme.${extension}\" must be of type \"Object\"`);\n          }\n        } else if (typeof data[extension] !== 'boolean') {\n          throw new TypeError(`\"x-readme.${extension}\" must be of type \"Boolean\"`);\n        }\n      }\n    }\n\n    // If the extension isn't grouped under `x-readme`, we need to look for them with `x-` prefixes.\n    if (this.hasExtension(`x-${extension}`)) {\n      const data = this.getExtension(`x-${extension}`);\n      if ([CODE_SAMPLES, HEADERS, PARAMETER_ORDERING, SAMPLES_LANGUAGES].includes(extension)) {\n        if (!Array.isArray(data)) {\n          throw new TypeError(`\"x-${extension}\" must be of type \"Array\"`);\n        }\n\n        if (extension === PARAMETER_ORDERING) {\n          validateParameterOrdering(data, `x-${extension}`);\n        }\n      } else if (extension === OAUTH_OPTIONS) {\n        if (typeof data !== 'object') {\n          throw new TypeError(`\"x-${extension}\" must be of type \"Object\"`);\n        }\n      } else if (typeof data !== 'boolean') {\n        throw new TypeError(`\"x-${extension}\" must be of type \"Boolean\"`);\n      }\n    }\n  }\n\n  /**\n   * Validate all of our custom or known OpenAPI extensions, throwing exceptions when necessary.\n   *\n   * @see {@link https://docs.readme.com/docs/openapi-extensions}\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#specification-extensions}\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#specification-extensions}\n   */\n  validateExtensions(): void {\n    Object.keys(extensionDefaults).forEach((extension: keyof Extensions) => {\n      this.validateExtension(extension);\n    });\n  }\n\n  /**\n   * Retrieve any circular `$ref` pointers that maybe present within the API definition.\n   *\n   * This method requires that you first dereference the definition.\n   *\n   * @see Oas.dereference\n   */\n  getCircularReferences(): string[] {\n    if (!this.dereferencing.complete) {\n      throw new Error('#dereference() must be called first in order for this method to obtain circular references.');\n    }\n\n    return this.dereferencing.circularRefs;\n  }\n\n  /**\n   * Dereference the current OAS definition so it can be parsed free of worries of `$ref` schemas\n   * and circular structures.\n   *\n   */\n  async dereference(\n    opts: {\n      /**\n       * A callback method can be supplied to be called when dereferencing is complete. Used for\n       * debugging that the multi-promise handling within this method works.\n       *\n       * @private\n       */\n      cb?: () => void;\n\n      /**\n       * Preserve component schema names within themselves as a `title`.\n       */\n      preserveRefAsJSONSchemaTitle?: boolean;\n    } = { preserveRefAsJSONSchemaTitle: false },\n  ): Promise<(typeof this.promises)[] | boolean> {\n    if (this.dereferencing.complete) {\n      return new Promise(resolve => {\n        resolve(true);\n      });\n    }\n\n    if (this.dereferencing.processing) {\n      return new Promise((resolve, reject) => {\n        this.promises.push({ resolve, reject });\n      });\n    }\n\n    this.dereferencing.processing = true;\n\n    const { api, promises } = this;\n\n    // Because referencing will eliminate any lineage back to the original `$ref`, information that\n    // we might need at some point, we should run through all available component schemas and denote\n    // what their name is so that when dereferencing happens below those names will be preserved.\n    if (api.components && api.components.schemas && typeof api.components.schemas === 'object') {\n      Object.keys(api.components.schemas).forEach(schemaName => {\n        // As of OpenAPI 3.1 component schemas can be primitives or arrays. If this happens then we\n        // shouldn't try to add `title` or `x-readme-ref-name` properties because we can't. We'll\n        // have some data loss on these schemas but as they aren't objects they likely won't be used\n        // in ways that would require needing a `title` or `x-readme-ref-name` anyways.\n        if (\n          isPrimitive(api.components.schemas[schemaName]) ||\n          Array.isArray(api.components.schemas[schemaName]) ||\n          api.components.schemas[schemaName] === null\n        ) {\n          return;\n        }\n\n        if (opts.preserveRefAsJSONSchemaTitle) {\n          // This may result in some data loss if there's already a `title` present, but in the case\n          // where we want to generate code for the API definition (see http://npm.im/api), we'd\n          // prefer to retain original reference name as a title for any generated types.\n          (api.components.schemas[schemaName] as RMOAS.SchemaObject).title = schemaName;\n        }\n\n        (api.components.schemas[schemaName] as RMOAS.SchemaObject)['x-readme-ref-name'] = schemaName;\n      });\n    }\n\n    const circularRefs: Set<string> = new Set();\n\n    return dereference<RMOAS.OASDocument>(api, {\n      resolve: {\n        // We shouldn't be resolving external pointers at this point so just ignore them.\n        external: false,\n      },\n      dereference: {\n        // If circular `$refs` are ignored they'll remain in the OAS as `$ref: String`, otherwise\n        // `$ref‘ just won't exist. This allows us to do easy circular reference detection.\n        circular: 'ignore',\n\n        onCircular: (path: string) => {\n          // The circular references that are coming out of `json-schema-ref-parser` are prefixed\n          // with the schema path (file path, URL, whatever) that the schema exists in. Because\n          // we don't care about this information for this reporting mechanism, and only the\n          // `$ref` pointer, we're removing it.\n          circularRefs.add(`#${path.split('#')[1]}`);\n        },\n      },\n    })\n      .then((dereferenced: RMOAS.OASDocument) => {\n        this.api = dereferenced;\n\n        this.promises = promises;\n        this.dereferencing = {\n          processing: false,\n          complete: true,\n          // We need to convert our `Set` to an array in order to match the typings.\n          circularRefs: [...circularRefs],\n        };\n\n        // Used for debugging that dereferencing promise awaiting works.\n        if (opts.cb) {\n          opts.cb();\n        }\n      })\n      .then(() => {\n        return this.promises.map(deferred => deferred.resolve());\n      });\n  }\n}\n","import type * as RMOAS from '../types.js';\nimport type { OpenAPIV3, OpenAPIV3_1 } from 'openapi-types';\n\ntype authKey = unknown | { password: number | string; user: number | string } | null;\n\n/**\n * @param user User to retrieve retrieve an auth key for.\n * @param scheme The type of security scheme that we want a key for.\n */\nfunction getKey(user: RMOAS.User, scheme: RMOAS.KeyedSecuritySchemeObject): authKey {\n  switch (scheme.type) {\n    case 'oauth2':\n    case 'apiKey':\n      return user[scheme._key] || user.apiKey || scheme['x-default'] || null;\n\n    case 'http':\n      if (scheme.scheme === 'basic') {\n        return user[scheme._key] || { user: user.user || null, pass: user.pass || null };\n      }\n\n      if (scheme.scheme === 'bearer') {\n        return user[scheme._key] || user.apiKey || scheme['x-default'] || null;\n      }\n      return null;\n\n    default:\n      return null;\n  }\n}\n\n/**\n * Retrieve auth keys for a specific security scheme for a given user for a specific \"app\" that\n * they have configured.\n *\n * For `scheme` we're typing it to a union of `SecurityScheme` and `any` because we have handling\n * and tests for an unknown or unrecognized `type` and though it's not possible with the\n * `SecurityScheme.type` to be unrecognized it may still be possible to get an unrecognized scheme\n * with this method in the wild as we have API definitions in our database that were ingested\n * before we had good validation in place.\n *\n * @param user User\n * @param scheme Security scheme to get auth keys for.\n * @param selectedApp The user app to retrieve an auth key for.\n */\nexport function getByScheme(\n  user: RMOAS.User,\n  scheme = <RMOAS.KeyedSecuritySchemeObject>{},\n  selectedApp?: number | string,\n): authKey {\n  if (user?.keys && user.keys.length) {\n    if (selectedApp) {\n      return getKey(\n        user.keys.find(key => key.name === selectedApp),\n        scheme,\n      );\n    }\n\n    return getKey(user.keys[0], scheme);\n  }\n\n  return getKey(user, scheme);\n}\n\n/**\n * Retrieve auth keys for an API definition from a given user for a specific \"app\" that they have\n * configured.\n *\n * @param api API definition\n * @param user User\n * @param selectedApp The user app to retrieve an auth key for.\n */\nexport function getAuth(\n  api: OpenAPIV3_1.Document | OpenAPIV3.Document,\n  user: RMOAS.User,\n  selectedApp?: number | string,\n): RMOAS.AuthForHAR {\n  return Object.keys(api?.components?.securitySchemes || {})\n    .map(scheme => {\n      return {\n        [scheme]: getByScheme(\n          user,\n          {\n            // This sucks but since we dereference we'll never have a `$ref` pointer here with a\n            // `ReferenceObject` type.\n            ...(api.components.securitySchemes[scheme] as RMOAS.SecuritySchemeObject),\n            _key: scheme,\n          },\n          selectedApp,\n        ),\n      };\n    })\n    .reduce((prev, next) => Object.assign(prev, next), {});\n}\n","import type * as RMOAS from '../types.js';\n\n/**\n * Retrieve a user variable off of a given user.\n *\n * @see {@link https://docs.readme.com/docs/passing-data-to-jwt}\n * @param user The user to get a user variable for.\n * @param property The name of the variable to retrieve.\n * @param selectedApp The user app to retrieve an auth key for.\n */\nexport default function getUserVariable(user: RMOAS.User, property: string, selectedApp?: number | string): unknown {\n  let key = user;\n\n  if ('keys' in user && Array.isArray(user.keys) && user.keys.length) {\n    if (selectedApp) {\n      key = user.keys.find(k => k.name === selectedApp);\n    } else {\n      key = user.keys[0];\n    }\n  }\n\n  return key[property] || user[property] || null;\n}\n"],"mappings":"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","names":[]}