{"version":3,"sources":["/Users/erunion/code/readme/oas/packages/oas/dist/chunk-QBBP72GC.cjs","../src/lib/clone-object.ts","../src/lib/helpers.ts","../src/lib/matches-mimetype.ts","../src/lib/openapi-to-json-schema.ts","../src/operation/lib/get-parameters-as-json-schema.ts"],"names":["types","components","schema"],"mappings":"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","file":"/Users/erunion/code/readme/oas/packages/oas/dist/chunk-QBBP72GC.cjs","sourcesContent":[null,"export default function cloneObject<T>(obj: T): T {\n  if (typeof obj === 'undefined') {\n    return undefined;\n  }\n\n  // eslint-disable-next-line try-catch-failsafe/json-parse\n  return JSON.parse(JSON.stringify(obj));\n}\n","import type { SchemaObject } from '../types.js';\n\nexport function hasSchemaType(schema: SchemaObject, discriminator: 'array' | 'object'): boolean {\n  if (Array.isArray(schema.type)) {\n    return schema.type.includes(discriminator);\n  }\n\n  return schema.type === discriminator;\n}\n\nexport function isObject(val: unknown): val is Record<string, unknown> {\n  return typeof val === 'object' && val !== null && !Array.isArray(val);\n}\n\nexport function isPrimitive(val: unknown): val is boolean | number | string {\n  return typeof val === 'string' || typeof val === 'number' || typeof val === 'boolean';\n}\n","function matchesMediaType(types: string[], mediaType: string): boolean {\n  return types.some(type => {\n    return mediaType.indexOf(type) > -1;\n  });\n}\n\nexport default {\n  formUrlEncoded: (mimeType: string): boolean => {\n    return matchesMediaType(['application/x-www-form-urlencoded'], mimeType);\n  },\n\n  json: (contentType: string): boolean => {\n    return matchesMediaType(\n      ['application/json', 'application/x-json', 'text/json', 'text/x-json', '+json'],\n      contentType,\n    );\n  },\n\n  multipart: (contentType: string): boolean => {\n    return matchesMediaType(\n      ['multipart/mixed', 'multipart/related', 'multipart/form-data', 'multipart/alternative'],\n      contentType,\n    );\n  },\n\n  wildcard: (contentType: string): boolean => {\n    return contentType === '*/*';\n  },\n\n  xml: (contentType: string): boolean => {\n    return matchesMediaType(\n      [\n        'application/xml',\n        'application/xml-external-parsed-entity',\n        'application/xml-dtd',\n        'text/xml',\n        'text/xml-external-parsed-entity',\n        '+xml',\n      ],\n      contentType,\n    );\n  },\n};\n","/* eslint-disable no-continue */\nimport type { SchemaObject } from '../types.js';\nimport type { JSONSchema7TypeName } from 'json-schema';\nimport type { OpenAPIV3_1 } from 'openapi-types';\n\nimport mergeJSONSchemaAllOf from 'json-schema-merge-allof';\nimport jsonpointer from 'jsonpointer';\nimport removeUndefinedObjects from 'remove-undefined-objects';\n\nimport * as RMOAS from '../types.js';\n\nimport { hasSchemaType, isObject, isPrimitive } from './helpers.js';\n\n/**\n * This list has been pulled from `openapi-schema-to-json-schema` but been slightly modified to fit\n * within the constraints in which ReadMe uses the output from this library in schema form\n * rendering as while properties like `readOnly` aren't represented within JSON Schema, we support\n * it within that library's handling of OpenAPI-friendly JSON Schema.\n *\n * @see {@link https://github.com/openapi-contrib/openapi-schema-to-json-schema/blob/main/src/consts.ts}\n */\nconst UNSUPPORTED_SCHEMA_PROPS = [\n  'example', // OpenAPI supports `example` but we're mapping it to `examples` in this library.\n  'externalDocs',\n  'xml',\n] as const;\n\nexport interface toJSONSchemaOptions {\n  /**\n   * Whether or not to extend descriptions with a list of any present enums.\n   */\n  addEnumsToDescriptions?: boolean;\n\n  /**\n   * Current location within the schema -- this is a JSON pointer.\n   */\n  currentLocation?: string;\n\n  /**\n   * Object containing a global set of defaults that we should apply to schemas that match it.\n   */\n  globalDefaults?: Record<string, unknown>;\n\n  /**\n   * If you wish to hide properties that are marked as being `readOnly`.\n   */\n  hideReadOnlyProperties?: boolean;\n\n  /**\n   * If you wish to hide properties that are marked as being `writeOnly`.\n   */\n  hideWriteOnlyProperties?: boolean;\n\n  /**\n   * Is this schema the child of a polymorphic `allOf` schema?\n   */\n  isPolymorphicAllOfChild?: boolean;\n\n  /**\n   * Array of parent `default` schemas to utilize when attempting to path together schema defaults.\n   */\n  prevDefaultSchemas?: RMOAS.SchemaObject[];\n\n  /**\n   * Array of parent `example` schemas to utilize when attempting to path together schema examples.\n   */\n  prevExampleSchemas?: RMOAS.SchemaObject[];\n\n  /**\n   * A function that's called anytime a (circular) `$ref` is found.\n   */\n  refLogger?: (ref: string, type: 'discriminator' | 'ref') => void;\n\n  /**\n   * With a transformer you can transform any data within a given schema, like say if you want\n   * to rewrite a potentially unsafe `title` that might be eventually used as a JS variable\n   * name, just make sure to return your transformed schema.\n   */\n  transformer?: (schema: RMOAS.SchemaObject) => RMOAS.SchemaObject;\n}\n\n/**\n * Encode a string to be used as a JSON pointer.\n *\n * @see {@link https://tools.ietf.org/html/rfc6901}\n * @param str String to encode into string that can be used as a JSON pointer.\n */\nfunction encodePointer(str: string) {\n  return str.replace('~', '~0').replace('/', '~1');\n}\n\nexport function getSchemaVersionString(schema: RMOAS.SchemaObject, api: RMOAS.OASDocument): string {\n  // If we're not on version 3.1.0, we always fall back to the default schema version for pre-3.1.0.\n  if (!RMOAS.isOAS31(api)) {\n    // This should remain as an HTTP url, not HTTPS.\n    return 'http://json-schema.org/draft-04/schema#';\n  }\n\n  /**\n   * If the schema indicates the version, prefer that.\n   *\n   * We use `as` here because the schema *should* be an OAS 3.1 schema due to the `isOAS31` check\n   * above.\n   */\n  if ((schema as OpenAPIV3_1.SchemaObject).$schema) {\n    return (schema as OpenAPIV3_1.SchemaObject).$schema;\n  }\n\n  // If the user defined a global schema version on their OAS document, prefer that.\n  if (api.jsonSchemaDialect) {\n    return api.jsonSchemaDialect;\n  }\n\n  return 'https://json-schema.org/draft/2020-12/schema#';\n}\n\nfunction isPolymorphicSchema(schema: RMOAS.SchemaObject): boolean {\n  return 'allOf' in schema || 'anyOf' in schema || 'oneOf' in schema;\n}\n\nfunction isRequestBodySchema(schema: unknown): schema is RMOAS.RequestBodyObject {\n  return 'content' in (schema as RMOAS.RequestBodyObject);\n}\n\n/**\n * Given a JSON pointer, a type of property to look for, and an array of schemas do a reverse\n * search through them until we find the JSON pointer, or part of it, within the array.\n *\n * This function will allow you to take a pointer like `/tags/name` and return back `buster` from\n * the following array:\n *\n * ```\n *  [\n *    {\n *      example: {id: 20}\n *    },\n *    {\n *      examples: {\n *        distinctName: {\n *          tags: {name: 'buster'}\n *        }\n *      }\n *    }\n *  ]\n * ```\n *\n * As with most things however, this is not without its quirks! If a deeply nested property shares\n * the same name as an example that's further up the stack (like `tags.id` and an example for `id`),\n * there's a chance that it'll be misidentified as having an example and receive the wrong value.\n *\n * That said, any example is usually better than no example though, so while it's quirky behavior\n * it shouldn't raise immediate cause for alarm.\n *\n * @see {@link https://tools.ietf.org/html/rfc6901}\n * @param property Specific type of schema property to look for a value for.\n * @param pointer JSON pointer to search for an example for.\n * @param schemas Array of previous schemas we've found relating to this pointer.\n */\nfunction searchForValueByPropAndPointer(\n  property: 'default' | 'example',\n  pointer: string,\n  schemas: toJSONSchemaOptions['prevDefaultSchemas'] | toJSONSchemaOptions['prevExampleSchemas'] = [],\n) {\n  if (!schemas.length || !pointer.length) {\n    return undefined;\n  }\n\n  const locSplit = pointer.split('/').filter(Boolean).reverse();\n  const pointers = [];\n\n  let point = '';\n  for (let i = 0; i < locSplit.length; i += 1) {\n    point = `/${locSplit[i]}${point}`;\n    pointers.push(point);\n  }\n\n  let foundValue;\n  const rev = [...schemas].reverse();\n\n  for (let i = 0; i < pointers.length; i += 1) {\n    for (let ii = 0; ii < rev.length; ii += 1) {\n      let schema = rev[ii];\n\n      if (property === 'example') {\n        if ('example' in schema) {\n          schema = schema.example;\n        } else {\n          if (!Array.isArray(schema.examples) || !schema.examples.length) {\n            continue;\n          }\n\n          // Prevent us from crashing if `examples` is a completely empty object.\n          schema = [...schema.examples].shift();\n        }\n      } else {\n        schema = schema.default;\n      }\n\n      try {\n        foundValue = jsonpointer.get(schema, pointers[i]);\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      } catch (err) {\n        // If the schema we're looking at is `{obj: null}` and our pointer is `/obj/propertyName`\n        // `jsonpointer` will throw an error. If that happens, we should silently catch and toss it\n        // and return no example.\n      }\n\n      if (foundValue !== undefined) {\n        break;\n      }\n    }\n\n    if (foundValue !== undefined) {\n      break;\n    }\n  }\n\n  return foundValue;\n}\n\n/**\n * Given an OpenAPI-flavored JSON Schema, make an effort to modify it so it's shaped more towards\n * stock JSON Schema.\n *\n * Why do this?\n *\n *  1. OpenAPI 3.0.x supports its own flavor of JSON Schema that isn't fully compatible with most\n *    JSON Schema tooling (like `@readme/oas-form` or `@rjsf/core`).\n *  2. While validating an OpenAPI definition will prevent corrupted or improper schemas from\n *    occuring, we have a lot of legacy schemas in ReadMe that were ingested before we had proper\n *    validation in place, and as a result have some API definitions that will not pass validation\n *    right now. In addition to reshaping OAS-JSON Schema into JSON Schema this library will also\n *    fix these improper schemas: things like `type: object` having `items` instead of `properties`,\n *    or `type: array` missing `items`.\n *  3. To ease the burden of polymorphic handling on our form rendering engine we make an attempt\n *    to merge `allOf` schemas here.\n *  4. Additionally due to OpenAPI 3.0.x not supporting JSON Schema, in order to support the\n *    `example` keyword that OAS supports, we need to do some work in here to remap it into\n *    `examples`. However, since all we care about in respect to examples for usage within\n *    `@readme/oas-form`, we're only retaining primitives. This *slightly* deviates from JSON\n *    Schema in that JSON Schema allows for any schema to be an example, but since\n *    `@readme/oas-form` can only actually **render** primitives, that's what we're retaining.\n *  5. Though OpenAPI 3.1 does support full JSON Schema, this library should be able to handle it\n *    without any problems.\n *\n * And why use this over `@openapi-contrib/openapi-schema-to-json-schema`? Fortunately and\n * unfortunately we've got a lot of API definitions in our database that aren't currently valid so\n * we need to have a lot of bespoke handling for odd quirks, typos, and missing declarations that\n * might be present.\n *\n * @todo add support for `schema: false` and `not` cases.\n * @see {@link https://json-schema.org/draft/2019-09/json-schema-validation.html}\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#schema-object}\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#schema-object}\n * @param data OpenAPI Schema Object to convert to pure JSON Schema.\n */\nexport function toJSONSchema(data: RMOAS.SchemaObject | boolean, opts: toJSONSchemaOptions = {}): RMOAS.SchemaObject {\n  let schema = data === true ? {} : { ...data };\n  const schemaAdditionalProperties = RMOAS.isSchema(schema) ? schema.additionalProperties : null;\n\n  const {\n    addEnumsToDescriptions,\n    currentLocation,\n    globalDefaults,\n    hideReadOnlyProperties,\n    hideWriteOnlyProperties,\n    isPolymorphicAllOfChild,\n    prevDefaultSchemas,\n    prevExampleSchemas,\n    refLogger,\n    transformer,\n  } = {\n    addEnumsToDescriptions: false,\n    currentLocation: '',\n    globalDefaults: {},\n    hideReadOnlyProperties: false,\n    hideWriteOnlyProperties: false,\n    isPolymorphicAllOfChild: false,\n    prevDefaultSchemas: [] as toJSONSchemaOptions['prevDefaultSchemas'],\n    prevExampleSchemas: [] as toJSONSchemaOptions['prevExampleSchemas'],\n    refLogger: () => true,\n    transformer: (s: RMOAS.SchemaObject) => s,\n    ...opts,\n  };\n\n  // If this schema contains a `$ref`, it's circular and we shouldn't try to resolve it. Just\n  // return and move along.\n  if (RMOAS.isRef(schema)) {\n    refLogger(schema.$ref, 'ref');\n\n    return transformer({\n      $ref: schema.$ref,\n    });\n  }\n\n  // If we don't have a set type, but are dealing with an `anyOf`, `oneOf`, or `allOf`\n  // representation let's run through them and make sure they're good.\n  if (RMOAS.isSchema(schema, isPolymorphicAllOfChild)) {\n    // If this is an `allOf` schema we should make an attempt to merge so as to ease the burden on\n    // the tooling that ingests these schemas.\n    if ('allOf' in schema && Array.isArray(schema.allOf)) {\n      try {\n        schema = mergeJSONSchemaAllOf(schema as RMOAS.JSONSchema, {\n          ignoreAdditionalProperties: true,\n          resolvers: {\n            // `merge-json-schema-allof` by default takes the first `description` when you're\n            // merging an `allOf` but because generally when you're merging two schemas together\n            // with an `allOf` you want data in the subsequent schemas to be applied to the first\n            // and `description` should be a part of that.\n            description: (obj: string[]) => {\n              return obj.slice(-1)[0];\n            },\n\n            // `merge-json-schema-allof` doesn't support merging enum arrays but since that's a\n            // safe and simple operation as enums always contain primitives we can handle it\n            // ourselves with a custom resolver.\n            enum: (obj: unknown[]) => {\n              let arr: unknown[] = [];\n              obj.forEach(e => {\n                arr = arr.concat(e);\n              });\n\n              return arr;\n            },\n\n            // for any unknown keywords (e.g., `example`, `format`, `x-readme-ref-name`),\n            // we fallback to using the title resolver (which uses the first value found).\n            // https://github.com/mokkabonna/json-schema-merge-allof/blob/ea2e48ee34415022de5a50c236eb4793a943ad11/src/index.js#L292\n            // https://github.com/mokkabonna/json-schema-merge-allof/blob/ea2e48ee34415022de5a50c236eb4793a943ad11/README.md?plain=1#L147\n            defaultResolver: mergeJSONSchemaAllOf.options.resolvers.title,\n          } as unknown,\n        }) as RMOAS.SchemaObject;\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      } catch (e) {\n        // If we can't merge the `allOf` for whatever reason (like if one item is a `string` and\n        // the other is a `object`) then we should completely remove it from the schema and continue\n        // with whatever we've got. Why? If we don't, any tooling that's ingesting this will need\n        // to account for the incompatible `allOf` and it may be subject to more breakages than\n        // just not having it present would be.\n        const { ...schemaWithoutAllOf } = schema;\n        schema = schemaWithoutAllOf as RMOAS.SchemaObject;\n        delete schema.allOf;\n      }\n\n      // If after merging the `allOf` this schema still contains a `$ref` then it's circular and\n      // we shouldn't do anything else.\n      if (RMOAS.isRef(schema)) {\n        refLogger(schema.$ref, 'ref');\n\n        return transformer({\n          $ref: schema.$ref,\n        });\n      }\n    }\n\n    ['anyOf', 'oneOf'].forEach((polyType: 'anyOf' | 'oneOf') => {\n      if (polyType in schema && Array.isArray(schema[polyType])) {\n        schema[polyType].forEach((item, idx) => {\n          const polyOptions: toJSONSchemaOptions = {\n            addEnumsToDescriptions,\n            currentLocation: `${currentLocation}/${idx}`,\n            globalDefaults,\n            hideReadOnlyProperties,\n            hideWriteOnlyProperties,\n            isPolymorphicAllOfChild: false,\n            prevDefaultSchemas,\n            prevExampleSchemas,\n            refLogger,\n            transformer,\n          };\n\n          // When `properties` or `items` are present alongside a polymorphic schema instead of\n          // letting whatever JSON Schema interpreter is handling these constructed schemas we can\n          // guide its hand a bit by manually transforming it into an inferred `allOf` of the\n          // `properties` + the polymorph schema.\n          //\n          // This `allOf` schema will be merged together when fed through `toJSONSchema`.\n          if ('properties' in schema) {\n            schema[polyType][idx] = toJSONSchema(\n              { required: schema.required, allOf: [item, { properties: schema.properties }] } as RMOAS.SchemaObject,\n              polyOptions,\n            );\n          } else if ('items' in schema) {\n            schema[polyType][idx] = toJSONSchema(\n              { allOf: [item, { items: schema.items }] } as RMOAS.SchemaObject,\n              polyOptions,\n            );\n          } else {\n            schema[polyType][idx] = toJSONSchema(item as RMOAS.SchemaObject, polyOptions);\n          }\n\n          // Ensure that we don't have any invalid `required` booleans lying around.\n          if (\n            isObject(schema[polyType][idx]) &&\n            'required' in (schema[polyType][idx] as SchemaObject) &&\n            typeof (schema[polyType][idx] as SchemaObject).required === 'boolean'\n          ) {\n            delete (schema[polyType][idx] as SchemaObject).required;\n          }\n        });\n      }\n    });\n\n    if ('discriminator' in schema) {\n      if ('mapping' in schema.discriminator && typeof schema.discriminator.mapping === 'object') {\n        // Discriminator mappings aren't written as traditional `$ref` pointers so in order to log\n        // them to the supplied `refLogger`.\n        const mapping = schema.discriminator.mapping;\n        Object.keys(mapping).forEach(k => {\n          refLogger(mapping[k], 'discriminator');\n        });\n      }\n    }\n  }\n\n  // If this schema is malformed for some reason, let's do our best to repair it.\n  if (!('type' in schema) && !isPolymorphicSchema(schema) && !isRequestBodySchema(schema)) {\n    if ('properties' in schema) {\n      schema.type = 'object';\n    } else if ('items' in schema) {\n      schema.type = 'array';\n    } else {\n      // If there's still no `type` on the schema we should leave it alone because we don't have a\n      // great way to know if it's part of a nested schema that should, and couldn't be merged,\n      // into another, or it's just purely malformed.\n      //\n      // Whatever tooling that ingests the generated schema should handle it however it needs to.\n    }\n  }\n\n  if ('type' in schema) {\n    // `nullable` isn't a thing in JSON Schema but it was in OpenAPI 3.0 so we should retain and\n    // translate it into something that's compatible with JSON Schema.\n    if ('nullable' in schema) {\n      if (schema.nullable) {\n        if (Array.isArray(schema.type)) {\n          schema.type.push('null');\n        } else if (schema.type !== null && schema.type !== 'null') {\n          schema.type = [schema.type, 'null'];\n        }\n      }\n\n      delete schema.nullable;\n    }\n\n    if (schema.type === null) {\n      // `type: null` is possible in JSON Schema but we're translating it to a string version\n      // so we don't need to worry about asserting nullish types in our implementations of this\n      // generated schema.\n      schema.type = 'null';\n    } else if (Array.isArray(schema.type)) {\n      if (schema.type.includes(null)) {\n        schema.type[schema.type.indexOf(null)] = 'null';\n      }\n\n      schema.type = Array.from(new Set(schema.type));\n\n      // We don't need `type: [<type>]` when we can just as easily make it `type: <type>`.\n      if (schema.type.length === 1) {\n        schema.type = schema.type.shift();\n      } else if (schema.type.includes('array') || schema.type.includes('boolean') || schema.type.includes('object')) {\n        // If we have a `null` type but there's only two types present then we can remove `null`\n        // as an option and flag the whole schema as `nullable`.\n        const isNullable = schema.type.includes('null');\n\n        if (schema.type.length === 2 && isNullable) {\n          // If this is `array | null` or `object | null` then we don't need to do anything.\n        } else {\n          // If this mixed type has non-primitives then we for convenience of our implementation\n          // we're moving them into a `oneOf`.\n          const nonPrimitives: any[] = [];\n\n          // Because arrays, booleans, and objects are not compatible with any other schem type\n          // other than null we're moving them into an isolated `oneOf`, and as such want to take\n          // with it its specific properties that may be present on our current schema.\n          Object.entries({\n            // https://json-schema.org/understanding-json-schema/reference/array.html\n            array: [\n              'additionalItems',\n              'contains',\n              'items',\n              'maxContains',\n              'maxItems',\n              'minContains',\n              'minItems',\n              'prefixItems',\n              'uniqueItems',\n            ],\n\n            // https://json-schema.org/understanding-json-schema/reference/boolean.html\n            boolean: [\n              // Booleans don't have any boolean-specific properties.\n            ],\n\n            // https://json-schema.org/understanding-json-schema/reference/object.html\n            object: [\n              'additionalProperties',\n              'maxProperties',\n              'minProperties',\n              'nullable',\n              'patternProperties',\n              'properties',\n              'propertyNames',\n              'required',\n            ],\n          }).forEach(([typeKey, keywords]) => {\n            if (!schema.type.includes(typeKey as JSONSchema7TypeName)) {\n              return;\n            }\n\n            const reducedSchema: any = removeUndefinedObjects({\n              type: isNullable ? [typeKey, 'null'] : typeKey,\n\n              allowEmptyValue: (schema as any).allowEmptyValue ?? undefined,\n              deprecated: schema.deprecated ?? undefined,\n              description: schema.description ?? undefined,\n              readOnly: schema.readOnly ?? undefined,\n              title: schema.title ?? undefined,\n              writeOnly: schema.writeOnly ?? undefined,\n            });\n\n            keywords.forEach((t: keyof SchemaObject) => {\n              if (t in schema) {\n                reducedSchema[t] = schema[t];\n                delete schema[t];\n              }\n            });\n\n            nonPrimitives.push(reducedSchema);\n          });\n\n          schema.type = schema.type.filter(t => t !== 'array' && t !== 'boolean' && t !== 'object');\n          if (schema.type.length === 1) {\n            schema.type = schema.type.shift();\n          }\n\n          // Because we may have encountered a fully mixed non-primitive type like `array | object`\n          // we only want to retain the existing schema object if we still have types remaining\n          // in it.\n          if (schema.type.length > 1) {\n            schema = { oneOf: [schema, ...nonPrimitives] };\n          } else {\n            schema = { oneOf: nonPrimitives };\n          }\n        }\n      }\n    }\n  }\n\n  if (RMOAS.isSchema(schema, isPolymorphicAllOfChild)) {\n    if ('default' in schema && isObject(schema.default)) {\n      prevDefaultSchemas.push({ default: schema.default });\n    }\n\n    // JSON Schema doesn't support OpenAPI-style examples so we need to reshape them a bit.\n    if ('example' in schema) {\n      // Only bother adding primitive examples.\n      if (isPrimitive(schema.example)) {\n        schema.examples = [schema.example];\n      } else if (Array.isArray(schema.example)) {\n        schema.examples = schema.example.filter(example => isPrimitive(example));\n        if (!schema.examples.length) {\n          delete schema.examples;\n        }\n      } else {\n        prevExampleSchemas.push({ example: schema.example });\n      }\n\n      delete schema.example;\n    } else if ('examples' in schema) {\n      let reshapedExamples = false;\n      if (typeof schema.examples === 'object' && !Array.isArray(schema.examples)) {\n        const examples: unknown[] = [];\n        Object.keys(schema.examples).forEach(name => {\n          const example = schema.examples[name as unknown as number];\n          if ('$ref' in example) {\n            // no-op because any `$ref` example here after dereferencing is circular so we should\n            // ignore it\n            refLogger(example.$ref, 'ref');\n          } else if ('value' in example) {\n            if (isPrimitive(example.value)) {\n              examples.push(example.value);\n              reshapedExamples = true;\n            } else if (Array.isArray(example.value) && isPrimitive(example.value[0])) {\n              examples.push(example.value[0]);\n              reshapedExamples = true;\n            } else {\n              // If this example is neither a primitive or an array we should dump it into the\n              // `prevExampleSchemas` array because we might be able to extract an example from it\n              // further downstream.\n              prevExampleSchemas.push({\n                example: example.value,\n              });\n            }\n          }\n        });\n\n        if (examples.length) {\n          reshapedExamples = true;\n          schema.examples = examples;\n        }\n      } else if (Array.isArray(schema.examples) && isPrimitive(schema.examples[0])) {\n        // We haven't reshaped `examples` here, but since it's in a state that's preferrable to us\n        // let's keep it around.\n        reshapedExamples = true;\n      }\n\n      if (!reshapedExamples) {\n        delete schema.examples;\n      }\n    }\n\n    // If we didn't have any immediately defined examples, let's search backwards and see if we can\n    // find one. But as we're only looking for primitive example, only try to search for one if\n    // we're dealing with a primitive schema.\n    if (!hasSchemaType(schema, 'array') && !hasSchemaType(schema, 'object') && !schema.examples) {\n      const foundExample = searchForValueByPropAndPointer('example', currentLocation, prevExampleSchemas);\n      if (foundExample) {\n        // We can only really deal with primitives, so only promote those as the found example if\n        // it is.\n        if (isPrimitive(foundExample) || (Array.isArray(foundExample) && isPrimitive(foundExample[0]))) {\n          schema.examples = [foundExample];\n        }\n      }\n    }\n\n    if (hasSchemaType(schema, 'array')) {\n      if ('items' in schema) {\n        if (!Array.isArray(schema.items) && Object.keys(schema.items).length === 1 && RMOAS.isRef(schema.items)) {\n          // `items` contains a `$ref`, so since it's circular we should do a no-op here and log\n          // and ignore it.\n          refLogger(schema.items.$ref, 'ref');\n        } else if (schema.items !== true) {\n          // Run through the arrays contents and clean them up.\n          schema.items = toJSONSchema(schema.items as RMOAS.SchemaObject, {\n            addEnumsToDescriptions,\n            currentLocation: `${currentLocation}/0`,\n            globalDefaults,\n            hideReadOnlyProperties,\n            hideWriteOnlyProperties,\n            prevExampleSchemas,\n            refLogger,\n            transformer,\n          });\n\n          // If we have a non-array `required` entry in our `items` schema then it's invalid and we\n          // should remove it. We only support non-array boolean `required` properties inside object\n          // properties.\n          if (isObject(schema.items) && 'required' in schema.items && !Array.isArray(schema.items.required)) {\n            delete schema.items.required;\n          }\n        }\n      } else if ('properties' in schema || 'additionalProperties' in schema) {\n        // This is a fix to handle cases where someone may have typod `items` as `properties` on an\n        // array. Since throwing a complete failure isn't ideal, we can see that they meant for the\n        // type to be `object`, so we can do our best to shape the data into what they were\n        // intending it to be.\n        schema.type = 'object';\n      } else {\n        // This is a fix to handle cases where we have a malformed array with no `items` property\n        // present.\n        (schema as any).items = {};\n      }\n    } else if (hasSchemaType(schema, 'object')) {\n      if ('properties' in schema) {\n        Object.keys(schema.properties).forEach(prop => {\n          if (\n            Array.isArray(schema.properties[prop]) ||\n            (typeof schema.properties[prop] === 'object' && schema.properties[prop] !== null)\n          ) {\n            const newPropSchema = toJSONSchema(schema.properties[prop] as RMOAS.SchemaObject, {\n              addEnumsToDescriptions,\n              currentLocation: `${currentLocation}/${encodePointer(prop)}`,\n              globalDefaults,\n              hideReadOnlyProperties,\n              hideWriteOnlyProperties,\n              prevDefaultSchemas,\n              prevExampleSchemas,\n              refLogger,\n              transformer,\n            });\n\n            // If this property is read or write only then we should fully hide it from its parent schema.\n            let propShouldBeUpdated = true;\n            if ((hideReadOnlyProperties || hideWriteOnlyProperties) && !Object.keys(newPropSchema).length) {\n              // We should only delete this schema if it wasn't already empty though. We do this\n              // because we (un)fortunately have handling in our API Explorer form system for\n              // schemas that are devoid of any `type` declaration.\n              if (Object.keys(schema.properties[prop]).length > 0) {\n                delete schema.properties[prop];\n                propShouldBeUpdated = false;\n              }\n            }\n\n            if (propShouldBeUpdated) {\n              schema.properties[prop] = newPropSchema;\n\n              /**\n               * JSON Schema does not have any support for `required: <boolean>` but because some\n               * of our users do this, and it does not throw OpenAPI validation errors thanks to\n               * some extremely loose typings around `schema` in the official JSON Schema\n               * definitions that the OAI offers, we're opting to support these users and upgrade\n               * their invalid `required` definitions into ones that our tooling can interpret.\n               *\n               * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/schemas/v3.1/schema.json#L1114-L1121}\n               */\n              if (\n                isObject(newPropSchema) &&\n                'required' in newPropSchema &&\n                typeof newPropSchema.required === 'boolean' &&\n                newPropSchema.required === true\n              ) {\n                if ('required' in schema && Array.isArray(schema.required)) {\n                  schema.required.push(prop);\n                } else {\n                  schema.required = [prop];\n                }\n\n                delete (schema.properties[prop] as SchemaObject).required;\n              }\n            }\n          }\n        });\n\n        // If we want to hide all readOnly or writeOnly properites and it happens to be that this\n        // object was comprised of only those then we shouldn't render this object.\n        if (hideReadOnlyProperties || hideWriteOnlyProperties) {\n          if (!Object.keys(schema.properties).length) {\n            return transformer({});\n          }\n        }\n      }\n\n      if (typeof schemaAdditionalProperties === 'object' && schemaAdditionalProperties !== null) {\n        // If this `additionalProperties` is completely empty and devoid of any sort of schema,\n        // treat it as such. Otherwise let's recurse into it and see if we can sort it out.\n        if (\n          !('type' in schemaAdditionalProperties) &&\n          !('$ref' in schemaAdditionalProperties) &&\n          // We know it will be a schema object because it's dereferenced\n          !isPolymorphicSchema(schemaAdditionalProperties as RMOAS.SchemaObject)\n        ) {\n          schema.additionalProperties = true;\n        } else {\n          // We know it will be a schema object because it's dereferenced\n          schema.additionalProperties = toJSONSchema(schemaAdditionalProperties as RMOAS.SchemaObject, {\n            addEnumsToDescriptions,\n            currentLocation,\n            globalDefaults,\n            hideReadOnlyProperties,\n            hideWriteOnlyProperties,\n            prevDefaultSchemas,\n            prevExampleSchemas,\n            refLogger,\n            transformer,\n          });\n        }\n      }\n\n      // Since neither `properties` and `additionalProperties` are actually required to be present\n      // on an object, since we construct this schema work to build up a form we still need\n      // *something* for the user to enter in for this object so we'll add back in\n      // `additionalProperties` for that.\n      if (!isPolymorphicSchema(schema) && !('properties' in schema) && !('additionalProperties' in schema)) {\n        schema.additionalProperties = true;\n      }\n    }\n  }\n\n  /**\n   * Users can pass in parameter defaults via JWT User Data. We're checking to see if the defaults\n   * being passed in exist on endpoints via jsonpointer\n   *\n   * @see {@link https://docs.readme.com/docs/passing-data-to-jwt}\n   */\n  if (\n    RMOAS.isSchema(schema, isPolymorphicAllOfChild) &&\n    globalDefaults &&\n    Object.keys(globalDefaults).length > 0 &&\n    currentLocation\n  ) {\n    try {\n      const userJwtDefault = jsonpointer.get(globalDefaults, currentLocation);\n      if (userJwtDefault) {\n        schema.default = userJwtDefault;\n      }\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    } catch (err) {\n      // If jsonpointer returns an error, we won't show any defaults for that path.\n    }\n  }\n\n  // Only add a default value if we actually have one.\n  if ('default' in schema && typeof schema.default !== 'undefined') {\n    if (hasSchemaType(schema, 'object')) {\n      // Defaults for `object` and types have been dereferenced into their children schemas already\n      // above so we don't need to preserve this default anymore.\n      delete schema.default;\n    } else if (\n      ('allowEmptyValue' in schema && schema.allowEmptyValue && schema.default === '') ||\n      schema.default !== ''\n    ) {\n      // If we have `allowEmptyValue` present, and the default is actually an empty string, let it\n      // through as it's allowed.\n    } else {\n      // If the default is empty and we don't want to allowEmptyValue, we need to remove the\n      // default.\n      delete schema.default;\n    }\n  } else if (prevDefaultSchemas.length) {\n    const foundDefault = searchForValueByPropAndPointer('default', currentLocation, prevDefaultSchemas);\n\n    // We shouldn't ever set an object default out of the parent lineage tree defaults because\n    // the contents of that object will be set on the schema that they're a part of. Setting\n    // that object as well would result us in duplicating the defaults for that schema in two\n    // places.\n    if (\n      isPrimitive(foundDefault) ||\n      foundDefault === null ||\n      (Array.isArray(foundDefault) && hasSchemaType(schema, 'array'))\n    ) {\n      schema.default = foundDefault;\n    }\n  }\n\n  if (RMOAS.isSchema(schema, isPolymorphicAllOfChild) && 'enum' in schema && Array.isArray(schema.enum)) {\n    // Enums should not have duplicated items as those will break AJV validation.\n    // If we ever target ES6 for typescript we can drop this array.from.\n    // https://stackoverflow.com/questions/33464504/using-spread-syntax-and-new-set-with-typescript/56870548\n    schema.enum = Array.from(new Set(schema.enum));\n\n    // If we want to add enums to descriptions (like in the case of response JSON Schema)\n    // generation we need to convert them into a list of Markdown tilda'd strings. We're also\n    // filtering away empty and falsy strings here because adding empty `` blocks to the description\n    // will serve nobody any good.\n    if (addEnumsToDescriptions) {\n      const enums = schema.enum\n        .filter(Boolean)\n        .map(str => `\\`${str}\\``)\n        .join(' ');\n\n      if (enums.length) {\n        if ('description' in schema) {\n          schema.description += `\\n\\n${enums}`;\n        } else {\n          schema.description = enums;\n        }\n      }\n    }\n  }\n\n  // Clean up any remaining `items` or `properties` schema fragments lying around if there's also\n  // polymorphism present.\n  if ('anyOf' in schema || 'oneOf' in schema) {\n    if ('properties' in schema) {\n      delete schema.properties;\n    }\n\n    if ('items' in schema) {\n      delete schema.items;\n    }\n  }\n\n  // Remove unsupported JSON Schema props.\n  for (let i = 0; i < UNSUPPORTED_SCHEMA_PROPS.length; i += 1) {\n    // Using the as here because the purpose is to delete keys we don't expect, so of course the\n    // typing won't work\n    delete (schema as Record<string, unknown>)[UNSUPPORTED_SCHEMA_PROPS[i]];\n  }\n\n  // If we want to hide any `readOnly` or `writeOnly` schemas, and this one is that, then we\n  // shouldn't return anything.\n  if (hideReadOnlyProperties && 'readOnly' in schema && schema.readOnly === true) {\n    return {};\n  } else if (hideWriteOnlyProperties && 'writeOnly' in schema && schema.writeOnly === true) {\n    return {};\n  }\n\n  return transformer(schema);\n}\n","import type { toJSONSchemaOptions } from '../../lib/openapi-to-json-schema.js';\nimport type { ComponentsObject, ExampleObject, OASDocument, ParameterObject, SchemaObject } from '../../types.js';\nimport type { Operation } from '../index.js';\nimport type { OpenAPIV3_1 } from 'openapi-types';\n\nimport { PARAMETER_ORDERING, getExtension } from '../../extensions.js';\nimport cloneObject from '../../lib/clone-object.js';\nimport { isPrimitive } from '../../lib/helpers.js';\nimport matchesMimetype from '../../lib/matches-mimetype.js';\nimport { toJSONSchema, getSchemaVersionString } from '../../lib/openapi-to-json-schema.js';\n\nexport interface SchemaWrapper {\n  $schema?: string;\n  deprecatedProps?: SchemaWrapper;\n  description?: string;\n  label?: string;\n  schema: SchemaObject;\n  type: string;\n}\n\n/**\n * The order of this object determines how they will be sorted in the compiled JSON Schema\n * representation.\n *\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#parameter-object}\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#parameter-object}\n */\nexport const types: Record<keyof OASDocument, string> = {\n  path: 'Path Params',\n  query: 'Query Params',\n  body: 'Body Params',\n  cookie: 'Cookie Params',\n  formData: 'Form Data',\n  header: 'Headers',\n  metadata: 'Metadata', // This a special type reserved for https://npm.im/api\n};\n\nexport interface getParametersAsJSONSchemaOptions {\n  /**\n   * Contains an object of user defined schema defaults.\n   */\n  globalDefaults?: Record<string, unknown>;\n\n  /**\n   * If you wish to hide properties that are marked as being `readOnly`.\n   */\n  hideReadOnlyProperties?: boolean;\n\n  /**\n   * If you wish to hide properties that are marked as being `writeOnly`.\n   */\n  hideWriteOnlyProperties?: boolean;\n\n  /**\n   * If you wish to include discriminator mapping `$ref` components alongside your\n   * `discriminator` in schemas. Defaults to `true`.\n   */\n  includeDiscriminatorMappingRefs?: boolean;\n\n  /**\n   * If you want the output to be two objects: body (contains `body` and `formData` JSON\n   * Schema) and metadata (contains `path`, `query`, `cookie`, and `header`).\n   */\n  mergeIntoBodyAndMetadata?: boolean;\n\n  /**\n   * If you wish to **not** split out deprecated properties into a separate `deprecatedProps`\n   * object.\n   */\n  retainDeprecatedProperties?: boolean;\n\n  /**\n   * With a transformer you can transform any data within a given schema, like say if you want\n   * to rewrite a potentially unsafe `title` that might be eventually used as a JS variable\n   * name, just make sure to return your transformed schema.\n   */\n  transformer?: (schema: SchemaObject) => SchemaObject;\n}\n\nexport function getParametersAsJSONSchema(\n  operation: Operation,\n  api: OASDocument,\n  opts?: getParametersAsJSONSchemaOptions,\n): SchemaWrapper[] {\n  let hasCircularRefs = false;\n  let hasDiscriminatorMappingRefs = false;\n\n  function refLogger(ref: string, type: 'discriminator' | 'ref') {\n    if (type === 'ref') {\n      hasCircularRefs = true;\n    } else {\n      hasDiscriminatorMappingRefs = true;\n    }\n  }\n\n  function getDeprecated(schema: SchemaObject, type: string) {\n    // If we wish to retain deprecated properties then we shouldn't split them out into the\n    // `deprecatedProps` object.\n    if (opts.retainDeprecatedProperties) {\n      return null;\n    }\n\n    // If there's no properties, bail\n    if (!schema || !schema.properties) return null;\n\n    // Clone the original schema so this doesn't interfere with it\n    const deprecatedBody = cloneObject(schema);\n\n    // Booleans are not valid for required in draft 4, 7 or 2020. Not sure why the typing thinks\n    // they are.\n    const requiredParams = (schema.required || []) as string[];\n\n    // Find all top-level deprecated properties from the schema - required and readOnly params are\n    // excluded.\n    const allDeprecatedProps: Record<string, SchemaObject> = {};\n\n    Object.keys(deprecatedBody.properties).forEach(key => {\n      const deprecatedProp = deprecatedBody.properties[key] as SchemaObject;\n      if (deprecatedProp.deprecated && !requiredParams.includes(key) && !deprecatedProp.readOnly) {\n        allDeprecatedProps[key] = deprecatedProp;\n      }\n    });\n\n    // We know this is the right type. todo: don't use as\n    (deprecatedBody.properties as Record<string, SchemaObject>) = allDeprecatedProps;\n    const deprecatedSchema = toJSONSchema(deprecatedBody, {\n      globalDefaults: opts.globalDefaults,\n      hideReadOnlyProperties: opts.hideReadOnlyProperties,\n      hideWriteOnlyProperties: opts.hideWriteOnlyProperties,\n      prevExampleSchemas: [],\n      refLogger,\n      transformer: opts.transformer,\n    });\n\n    // Check if the schema wasn't created or there's no deprecated properties\n    if (Object.keys(deprecatedSchema).length === 0 || Object.keys(deprecatedSchema.properties).length === 0) {\n      return null;\n    }\n\n    // Remove deprecated properties from the original schema\n    // Not using the clone here becuase we WANT this to affect the original\n    Object.keys(schema.properties).forEach(key => {\n      // We know this will always be a SchemaObject\n      if ((schema.properties[key] as SchemaObject).deprecated && !requiredParams.includes(key)) {\n        delete schema.properties[key];\n      }\n    });\n\n    return {\n      type,\n      schema: isPrimitive(deprecatedSchema)\n        ? deprecatedSchema\n        : {\n            ...deprecatedSchema,\n            $schema: getSchemaVersionString(deprecatedSchema, api),\n          },\n    };\n  }\n\n  /**\n   *\n   */\n  function transformRequestBody(): SchemaWrapper {\n    const requestBody = operation.getRequestBody();\n    if (!requestBody || !Array.isArray(requestBody)) return null;\n\n    const [mediaType, mediaTypeObject, description] = requestBody;\n    const type = mediaType === 'application/x-www-form-urlencoded' ? 'formData' : 'body';\n\n    // If this schema is completely empty, don't bother processing it.\n    if (!mediaTypeObject.schema || !Object.keys(mediaTypeObject.schema).length) {\n      return null;\n    }\n\n    const prevExampleSchemas: toJSONSchemaOptions['prevExampleSchemas'] = [];\n    if ('example' in mediaTypeObject) {\n      prevExampleSchemas.push({ example: mediaTypeObject.example });\n    } else if ('examples' in mediaTypeObject) {\n      prevExampleSchemas.push({\n        examples: Object.values(mediaTypeObject.examples)\n          .map((example: ExampleObject) => example.value)\n          .filter(val => val !== undefined),\n      });\n    }\n\n    // We're cloning the request schema because we've had issues with request schemas that were\n    // dereferenced being processed multiple times because their component is also processed.\n    const requestSchema = cloneObject(mediaTypeObject.schema);\n\n    const cleanedSchema = toJSONSchema(requestSchema, {\n      globalDefaults: opts.globalDefaults,\n      hideReadOnlyProperties: opts.hideReadOnlyProperties,\n      hideWriteOnlyProperties: opts.hideWriteOnlyProperties,\n      prevExampleSchemas,\n      refLogger,\n      transformer: opts.transformer,\n    });\n\n    // If this schema is **still** empty, don't bother returning it.\n    if (!Object.keys(cleanedSchema).length) {\n      return null;\n    }\n\n    return {\n      type,\n      label: types[type],\n      schema: isPrimitive(cleanedSchema)\n        ? cleanedSchema\n        : {\n            ...cleanedSchema,\n            $schema: getSchemaVersionString(cleanedSchema, api),\n          },\n      deprecatedProps: getDeprecated(cleanedSchema, type),\n      ...(description ? { description } : {}),\n    };\n  }\n\n  function transformComponents(): ComponentsObject {\n    if (!('components' in api)) {\n      return false;\n    }\n\n    const components: Partial<ComponentsObject> = {\n      ...Object.keys(api.components)\n        .map(componentType => ({ [componentType]: {} }))\n        .reduce((prev, next) => Object.assign(prev, next), {}),\n    };\n\n    Object.keys(api.components).forEach((componentType: keyof ComponentsObject) => {\n      if (typeof api.components[componentType] === 'object' && !Array.isArray(api.components[componentType])) {\n        Object.keys(api.components[componentType]).forEach(schemaName => {\n          const componentSchema = cloneObject(api.components[componentType][schemaName]);\n          components[componentType][schemaName] = toJSONSchema(componentSchema as SchemaObject, {\n            globalDefaults: opts.globalDefaults,\n            hideReadOnlyProperties: opts.hideReadOnlyProperties,\n            hideWriteOnlyProperties: opts.hideWriteOnlyProperties,\n            refLogger,\n            transformer: opts.transformer,\n          });\n        });\n      }\n    });\n\n    // If none of our above component type placeholders got used let's clean them up.\n    Object.keys(components).forEach((componentType: keyof ComponentsObject) => {\n      if (!Object.keys(components[componentType]).length) {\n        delete components[componentType];\n      }\n    });\n\n    return components;\n  }\n\n  function transformParameters(): SchemaWrapper[] {\n    const operationParams = operation.getParameters();\n\n    const transformed = Object.keys(types)\n      .map(type => {\n        const required: string[] = [];\n\n        // This `as` actually *could* be a ref, but we don't want refs to pass through here, so\n        // `.in` will never match `type`\n        const parameters = operationParams.filter(param => (param as ParameterObject).in === type);\n        if (parameters.length === 0) {\n          return null;\n        }\n\n        const properties = parameters.reduce((prev: Record<string, SchemaObject>, current: ParameterObject) => {\n          let schema: SchemaObject = {};\n          if ('schema' in current) {\n            const currentSchema: SchemaObject = current.schema ? cloneObject(current.schema) : {};\n\n            if (current.example) {\n              // `example` can be present outside of the `schema` block so if it's there we should\n              // pull it in so it can be handled and returned if it's valid.\n              currentSchema.example = current.example;\n            } else if (current.examples) {\n              // `examples` isn't actually supported here in OAS 3.0, but we might as well support\n              // it because `examples` is JSON Schema and that's fully supported in OAS 3.1.\n              currentSchema.examples = current.examples as unknown as unknown[];\n            }\n\n            if (current.deprecated) currentSchema.deprecated = current.deprecated;\n\n            const interimSchema = toJSONSchema(currentSchema, {\n              currentLocation: `/${current.name}`,\n              globalDefaults: opts.globalDefaults,\n              hideReadOnlyProperties: opts.hideReadOnlyProperties,\n              hideWriteOnlyProperties: opts.hideWriteOnlyProperties,\n              refLogger,\n              transformer: opts.transformer,\n            });\n\n            schema = isPrimitive(interimSchema)\n              ? interimSchema\n              : {\n                  ...interimSchema,\n\n                  // Note: this applies a `$schema` version to each field in the larger schema\n                  // object. It's not really **correct** but it's what we have to do because\n                  // there's a chance that the end user has indicated the schemas are different.\n                  $schema: getSchemaVersionString(currentSchema, api),\n                };\n          } else if ('content' in current && typeof current.content === 'object') {\n            const contentKeys = Object.keys(current.content);\n            if (contentKeys.length) {\n              let contentType;\n              if (contentKeys.length === 1) {\n                contentType = contentKeys[0];\n              } else {\n                // We should always try to prioritize `application/json` over any other possible\n                // content that might be present on this schema.\n                const jsonLikeContentTypes = contentKeys.filter(k => matchesMimetype.json(k));\n                if (jsonLikeContentTypes.length) {\n                  contentType = jsonLikeContentTypes[0];\n                } else {\n                  contentType = contentKeys[0];\n                }\n              }\n\n              if (typeof current.content[contentType] === 'object' && 'schema' in current.content[contentType]) {\n                const currentSchema: SchemaObject = current.content[contentType].schema\n                  ? cloneObject(current.content[contentType].schema)\n                  : {};\n\n                if (current.example) {\n                  // `example` can be present outside of the `schema` block so if it's there we\n                  // should pull it in so it can be handled and returned if it's valid.\n                  currentSchema.example = current.example;\n                } else if (current.examples) {\n                  // `examples` isn't actually supported here in OAS 3.0, but we might as well\n                  // support it because `examples` is JSON Schema and that's fully supported in OAS\n                  // 3.1.\n                  currentSchema.examples = current.examples as unknown as unknown[];\n                }\n\n                if (current.deprecated) currentSchema.deprecated = current.deprecated;\n\n                const interimSchema = toJSONSchema(currentSchema, {\n                  currentLocation: `/${current.name}`,\n                  globalDefaults: opts.globalDefaults,\n                  hideReadOnlyProperties: opts.hideReadOnlyProperties,\n                  hideWriteOnlyProperties: opts.hideWriteOnlyProperties,\n                  refLogger,\n                  transformer: opts.transformer,\n                });\n\n                schema = isPrimitive(interimSchema)\n                  ? interimSchema\n                  : {\n                      ...interimSchema,\n\n                      // Note: this applies a `$schema` version to each field in the larger schema\n                      // object. It's not really **correct** but it's what we have to do because\n                      // there's a chance that the end user has indicated the schemas are different.\n                      $schema: getSchemaVersionString(currentSchema, api),\n                    };\n              }\n            }\n          }\n\n          // Parameter descriptions don't exist in `current.schema` so `constructSchema` will never\n          // have access to it.\n          if (current.description) {\n            if (!isPrimitive(schema)) {\n              schema.description = current.description;\n            }\n          }\n\n          prev[current.name] = schema;\n\n          if (current.required) {\n            required.push(current.name);\n          }\n\n          return prev;\n        }, {});\n\n        // This typing is technically WRONG :( but it's the best we can do for now.\n        const schema: OpenAPIV3_1.SchemaObject = {\n          type: 'object',\n          properties: properties as Record<string, OpenAPIV3_1.SchemaObject>,\n          required,\n        };\n\n        return {\n          type,\n          label: types[type],\n          schema,\n          deprecatedProps: getDeprecated(schema, type),\n        };\n      })\n      .filter(Boolean);\n\n    if (!opts.mergeIntoBodyAndMetadata) {\n      return transformed;\n    } else if (!transformed.length) {\n      return [];\n    }\n\n    // If we want to merge parameters into a single metadata entry then we need to pull all\n    // available schemas and `deprecatedProps` (if we don't want to retain them via the\n    // `retainDeprecatedProps` option) under one roof.\n    const deprecatedProps = transformed.map(r => r.deprecatedProps?.schema || null).filter(Boolean);\n    return [\n      {\n        type: 'metadata',\n        label: types.metadata,\n        schema: {\n          allOf: transformed.map(r => r.schema),\n        } as SchemaObject,\n        deprecatedProps: deprecatedProps.length\n          ? {\n              type: 'metadata',\n              schema: {\n                allOf: deprecatedProps,\n              } as SchemaObject,\n            }\n          : null,\n      },\n    ];\n  }\n\n  // If this operation neither has any parameters or a request body then we should return null\n  // because there won't be any JSON Schema.\n  if (!operation.hasParameters() && !operation.hasRequestBody()) {\n    return null;\n  }\n\n  // `metadata` is `api` SDK specific, is not a part of the `PARAMETER_ORDERING` extension, and\n  // should always be sorted last. We also define `formData` as `form` in the extension because\n  // we don't want folks to have to deal with casing issues so we need to rewrite it to `formData`.\n  const typeKeys = (getExtension(PARAMETER_ORDERING, api, operation) as string[]).map(k => k.toLowerCase());\n  typeKeys[typeKeys.indexOf('form')] = 'formData';\n  typeKeys.push('metadata');\n\n  const jsonSchema = [transformRequestBody()].concat(...transformParameters()).filter(Boolean);\n\n  // We should only include `components`, or even bother transforming components into JSON Schema,\n  // if we either have circular refs or if we have discriminator mapping refs somewhere and want to\n  // include them.\n  const shouldIncludeComponents =\n    hasCircularRefs || (hasDiscriminatorMappingRefs && opts.includeDiscriminatorMappingRefs);\n\n  const components = shouldIncludeComponents ? transformComponents() : false;\n\n  return jsonSchema\n    .map(group => {\n      /**\n       * Since this library assumes that the schema has already been dereferenced, adding every\n       * component here that **isn't** circular adds a ton of bloat so it'd be cool if `components`\n       * was just the remaining `$ref` pointers that are still being referenced.\n       *\n       * @todo\n       */\n      if (components && shouldIncludeComponents) {\n        // Fixing typing and confused version mismatches\n        (group.schema.components as ComponentsObject) = components;\n      }\n\n      // Delete deprecatedProps if it's null on the schema.\n      if (!group.deprecatedProps) delete group.deprecatedProps;\n\n      return group;\n    })\n    .sort((a, b) => {\n      return typeKeys.indexOf(a.type) - typeKeys.indexOf(b.type);\n    });\n}\n"]}