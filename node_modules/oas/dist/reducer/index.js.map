{"version":3,"sources":["../../src/reducer/index.ts"],"sourcesContent":["import type { ComponentsObject, HttpMethods, OASDocument, TagObject } from '../types.js';\n\nimport jsonPointer from 'jsonpointer';\n\nimport { query } from '../analyzer/util.js';\n\ninterface ReducerOptions {\n  /** A key-value object of path + method combinations to reduce by. */\n  paths?: Record<string, string[] | '*'>;\n  /** An array of tags in the OpenAPI definition to reduce by. */\n  tags?: string[];\n}\n\n/**\n * Query a JSON Schema object for any `$ref` pointers. Return any pointers that were found.\n *\n * @param schema JSON Schema object to look for any `$ref` pointers within it.\n */\nfunction getUsedRefs(schema: any) {\n  return query([\"$..['$ref']\"], schema);\n}\n\n/**\n * Recursively process a `$ref` pointer and accumulate any other `$ref` pointers that it or its\n * children use.\n *\n * @param schema JSON Schema object to look for and accumulate any `$ref` pointers that it may have.\n * @param $refs Known set of `$ref` pointers.\n * @param $ref `$ref` pointer to fetch a schema from out of the supplied schema.\n */\nfunction accumulateUsedRefs(schema: Record<string, unknown>, $refs: Set<string>, $ref: any): void {\n  let $refSchema;\n  if (typeof $ref === 'string') $refSchema = jsonPointer.get(schema, $ref.substring(1));\n  if ($refSchema === undefined) {\n    // If the schema we have wasn't fully dereferenced or bundled for whatever reason and this\n    // `$ref` that we have doesn't exist here we shouldn't try to search for more `$ref` pointers\n    // in a schema that doesn't exist.\n    return;\n  }\n\n  getUsedRefs($refSchema).forEach(({ value: currRef }) => {\n    // Because it's possible to have a parameter named `$ref`, which our lookup would pick up as a\n    // false positive, we want to exclude that from `$ref` matching as it's not really a reference.\n    if (typeof currRef !== 'string') {\n      return;\n    }\n\n    // If we've already processed this $ref don't send us into an infinite loop.\n    if ($refs.has(currRef)) {\n      return;\n    }\n\n    $refs.add(currRef);\n    accumulateUsedRefs(schema, $refs, currRef);\n  });\n}\n\n/**\n * With an array of tags or object of paths+method combinations, reduce an OpenAPI definition to a\n * new definition that just contains those tags or path + methods.\n *\n * @example <caption>Reduce by an array of tags only.</caption>\n * reducer(apiDefinition, { tags: ['pet'] })\n *\n * @example <caption>Reduce by a specific path and methods.</caption>\n * reducer(apiDefinition, { paths: { '/pet': ['get', 'post'] } })\n *\n * @example <caption>Reduce by a specific path and all methods it has.</caption>\n * reducer(apiDefinition, { paths: { '/pet': '*' } })\n *\n * @param definition A valid OpenAPI 3.x definition\n */\nexport default function reducer(definition: OASDocument, opts: ReducerOptions = {}): OASDocument {\n  // Convert tags and paths to lowercase since casing should not matter.\n  const reduceTags = 'tags' in opts ? opts.tags.map(tag => tag.toLowerCase()) : [];\n  const reducePaths =\n    'paths' in opts\n      ? Object.entries(opts.paths).reduce((acc: Record<string, string[] | string>, [key, value]) => {\n          const newKey = key.toLowerCase();\n          const newValue = Array.isArray(value) ? value.map(v => v.toLowerCase()) : value.toLowerCase();\n          acc[newKey] = newValue;\n          return acc;\n        }, {})\n      : {};\n\n  const $refs: Set<string> = new Set();\n  const usedTags: Set<string> = new Set();\n\n  if (!definition.openapi) {\n    throw new Error('Sorry, only OpenAPI definitions are supported.');\n  }\n\n  // Stringify and parse so we get a full non-reference clone of the API definition to work with.\n  // eslint-disable-next-line try-catch-failsafe/json-parse\n  const reduced = JSON.parse(JSON.stringify(definition)) as OASDocument;\n\n  // Retain any root-level security definitions.\n  if ('security' in reduced) {\n    Object.values(reduced.security).forEach(sec => {\n      Object.keys(sec).forEach(scheme => {\n        $refs.add(`#/components/securitySchemes/${scheme}`);\n      });\n    });\n  }\n\n  if ('paths' in reduced) {\n    Object.keys(reduced.paths).forEach(path => {\n      const pathLC = path.toLowerCase();\n\n      if (Object.keys(reducePaths).length) {\n        if (!(pathLC in reducePaths)) {\n          delete reduced.paths[path];\n          return;\n        }\n      }\n\n      Object.keys(reduced.paths[path]).forEach((method: HttpMethods | 'parameters') => {\n        // If this method is `parameters` we should always retain it.\n        if (method !== 'parameters') {\n          if (Object.keys(reducePaths).length) {\n            if (\n              reducePaths[pathLC] !== '*' &&\n              Array.isArray(reducePaths[pathLC]) &&\n              !reducePaths[pathLC].includes(method)\n            ) {\n              delete reduced.paths[path][method];\n              return;\n            }\n          }\n        }\n\n        const operation = reduced.paths[path][method];\n\n        // If we're reducing by tags and this operation doesn't live in one of those, remove it.\n        if (reduceTags.length) {\n          if (!('tags' in operation)) {\n            delete reduced.paths[path][method];\n            return;\n          } else if (!operation.tags.filter(tag => reduceTags.includes(tag.toLowerCase())).length) {\n            delete reduced.paths[path][method];\n            return;\n          }\n        }\n\n        // Accumulate a list of used tags so we can filter out any ones that we don't need later.\n        if ('tags' in operation) {\n          operation.tags.forEach((tag: string) => {\n            usedTags.add(tag);\n          });\n        }\n\n        // Accumulate a list of $ref pointers that are used within this operation.\n        getUsedRefs(operation).forEach(({ value: ref }) => {\n          $refs.add(ref);\n        });\n\n        // Accumulate any used security schemas that we need to retain.\n        if ('security' in operation) {\n          Object.values(operation.security).forEach(sec => {\n            Object.keys(sec).forEach(scheme => {\n              $refs.add(`#/components/securitySchemes/${scheme}`);\n            });\n          });\n        }\n      });\n\n      // If this path no longer has any methods, delete it.\n      if (!Object.keys(reduced.paths[path]).length) {\n        delete reduced.paths[path];\n      }\n    });\n\n    // If we don't have any more paths after cleanup, throw an error because an OpenAPI file must\n    // have at least one path.\n    if (!Object.keys(reduced.paths).length) {\n      throw new Error('All paths in the API definition were removed. Did you supply the right path name to reduce by?');\n    }\n  }\n\n  // Recursively accumulate any components that are in use.\n  $refs.forEach($ref => accumulateUsedRefs(reduced, $refs, $ref));\n\n  // Remove any unused components.\n  if ('components' in reduced) {\n    Object.keys(reduced.components).forEach((componentType: keyof ComponentsObject) => {\n      Object.keys(reduced.components[componentType]).forEach(component => {\n        // If our `$ref` either is a full, or deep match, then we should preserve it.\n        const refIsUsed =\n          $refs.has(`#/components/${componentType}/${component}`) ||\n          Array.from($refs).some(ref => {\n            // Because you can have a `$ref` like `#/components/examples/event-min/value`, which\n            // would be accumulated via our `$refs` query, we want to make sure we account for them.\n            // If we don't look for these then we'll end up removing them from the overall reduced\n            // definition, resulting in data loss and schema corruption.\n            return ref.startsWith(`#/components/${componentType}/${component}/`);\n          });\n\n        if (!refIsUsed) {\n          delete reduced.components[componentType][component];\n        }\n      });\n\n      // If this component group is now empty, delete it.\n      if (!Object.keys(reduced.components[componentType]).length) {\n        delete reduced.components[componentType];\n      }\n    });\n\n    // If this path no longer has any components, delete it.\n    if (!Object.keys(reduced.components).length) {\n      delete reduced.components;\n    }\n  }\n\n  // Remove any unused tags.\n  if ('tags' in reduced) {\n    reduced.tags.forEach((tag: TagObject, k: number) => {\n      if (!usedTags.has(tag.name)) {\n        delete reduced.tags[k];\n      }\n    });\n\n    // Remove any now empty items from the tags array.\n    reduced.tags = reduced.tags.filter(Boolean);\n\n    if (!reduced.tags.length) {\n      delete reduced.tags;\n    }\n  }\n\n  return reduced;\n}\n"],"mappings":"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","names":[]}