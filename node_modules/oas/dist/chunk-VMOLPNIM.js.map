{"version":3,"sources":["../src/lib/clone-object.ts","../src/lib/helpers.ts","../src/lib/matches-mimetype.ts","../src/lib/openapi-to-json-schema.ts","../src/operation/lib/get-parameters-as-json-schema.ts"],"sourcesContent":["export default function cloneObject<T>(obj: T): T {\n  if (typeof obj === 'undefined') {\n    return undefined;\n  }\n\n  // eslint-disable-next-line try-catch-failsafe/json-parse\n  return JSON.parse(JSON.stringify(obj));\n}\n","import type { SchemaObject } from '../types.js';\n\nexport function hasSchemaType(schema: SchemaObject, discriminator: 'array' | 'object'): boolean {\n  if (Array.isArray(schema.type)) {\n    return schema.type.includes(discriminator);\n  }\n\n  return schema.type === discriminator;\n}\n\nexport function isObject(val: unknown): val is Record<string, unknown> {\n  return typeof val === 'object' && val !== null && !Array.isArray(val);\n}\n\nexport function isPrimitive(val: unknown): val is boolean | number | string {\n  return typeof val === 'string' || typeof val === 'number' || typeof val === 'boolean';\n}\n","function matchesMediaType(types: string[], mediaType: string): boolean {\n  return types.some(type => {\n    return mediaType.indexOf(type) > -1;\n  });\n}\n\nexport default {\n  formUrlEncoded: (mimeType: string): boolean => {\n    return matchesMediaType(['application/x-www-form-urlencoded'], mimeType);\n  },\n\n  json: (contentType: string): boolean => {\n    return matchesMediaType(\n      ['application/json', 'application/x-json', 'text/json', 'text/x-json', '+json'],\n      contentType,\n    );\n  },\n\n  multipart: (contentType: string): boolean => {\n    return matchesMediaType(\n      ['multipart/mixed', 'multipart/related', 'multipart/form-data', 'multipart/alternative'],\n      contentType,\n    );\n  },\n\n  wildcard: (contentType: string): boolean => {\n    return contentType === '*/*';\n  },\n\n  xml: (contentType: string): boolean => {\n    return matchesMediaType(\n      [\n        'application/xml',\n        'application/xml-external-parsed-entity',\n        'application/xml-dtd',\n        'text/xml',\n        'text/xml-external-parsed-entity',\n        '+xml',\n      ],\n      contentType,\n    );\n  },\n};\n","/* eslint-disable no-continue */\nimport type { SchemaObject } from '../types.js';\nimport type { JSONSchema7TypeName } from 'json-schema';\nimport type { OpenAPIV3_1 } from 'openapi-types';\n\nimport mergeJSONSchemaAllOf from 'json-schema-merge-allof';\nimport jsonpointer from 'jsonpointer';\nimport removeUndefinedObjects from 'remove-undefined-objects';\n\nimport * as RMOAS from '../types.js';\n\nimport { hasSchemaType, isObject, isPrimitive } from './helpers.js';\n\n/**\n * This list has been pulled from `openapi-schema-to-json-schema` but been slightly modified to fit\n * within the constraints in which ReadMe uses the output from this library in schema form\n * rendering as while properties like `readOnly` aren't represented within JSON Schema, we support\n * it within that library's handling of OpenAPI-friendly JSON Schema.\n *\n * @see {@link https://github.com/openapi-contrib/openapi-schema-to-json-schema/blob/main/src/consts.ts}\n */\nconst UNSUPPORTED_SCHEMA_PROPS = [\n  'example', // OpenAPI supports `example` but we're mapping it to `examples` in this library.\n  'externalDocs',\n  'xml',\n] as const;\n\nexport interface toJSONSchemaOptions {\n  /**\n   * Whether or not to extend descriptions with a list of any present enums.\n   */\n  addEnumsToDescriptions?: boolean;\n\n  /**\n   * Current location within the schema -- this is a JSON pointer.\n   */\n  currentLocation?: string;\n\n  /**\n   * Object containing a global set of defaults that we should apply to schemas that match it.\n   */\n  globalDefaults?: Record<string, unknown>;\n\n  /**\n   * If you wish to hide properties that are marked as being `readOnly`.\n   */\n  hideReadOnlyProperties?: boolean;\n\n  /**\n   * If you wish to hide properties that are marked as being `writeOnly`.\n   */\n  hideWriteOnlyProperties?: boolean;\n\n  /**\n   * Is this schema the child of a polymorphic `allOf` schema?\n   */\n  isPolymorphicAllOfChild?: boolean;\n\n  /**\n   * Array of parent `default` schemas to utilize when attempting to path together schema defaults.\n   */\n  prevDefaultSchemas?: RMOAS.SchemaObject[];\n\n  /**\n   * Array of parent `example` schemas to utilize when attempting to path together schema examples.\n   */\n  prevExampleSchemas?: RMOAS.SchemaObject[];\n\n  /**\n   * A function that's called anytime a (circular) `$ref` is found.\n   */\n  refLogger?: (ref: string, type: 'discriminator' | 'ref') => void;\n\n  /**\n   * With a transformer you can transform any data within a given schema, like say if you want\n   * to rewrite a potentially unsafe `title` that might be eventually used as a JS variable\n   * name, just make sure to return your transformed schema.\n   */\n  transformer?: (schema: RMOAS.SchemaObject) => RMOAS.SchemaObject;\n}\n\n/**\n * Encode a string to be used as a JSON pointer.\n *\n * @see {@link https://tools.ietf.org/html/rfc6901}\n * @param str String to encode into string that can be used as a JSON pointer.\n */\nfunction encodePointer(str: string) {\n  return str.replace('~', '~0').replace('/', '~1');\n}\n\nexport function getSchemaVersionString(schema: RMOAS.SchemaObject, api: RMOAS.OASDocument): string {\n  // If we're not on version 3.1.0, we always fall back to the default schema version for pre-3.1.0.\n  if (!RMOAS.isOAS31(api)) {\n    // This should remain as an HTTP url, not HTTPS.\n    return 'http://json-schema.org/draft-04/schema#';\n  }\n\n  /**\n   * If the schema indicates the version, prefer that.\n   *\n   * We use `as` here because the schema *should* be an OAS 3.1 schema due to the `isOAS31` check\n   * above.\n   */\n  if ((schema as OpenAPIV3_1.SchemaObject).$schema) {\n    return (schema as OpenAPIV3_1.SchemaObject).$schema;\n  }\n\n  // If the user defined a global schema version on their OAS document, prefer that.\n  if (api.jsonSchemaDialect) {\n    return api.jsonSchemaDialect;\n  }\n\n  return 'https://json-schema.org/draft/2020-12/schema#';\n}\n\nfunction isPolymorphicSchema(schema: RMOAS.SchemaObject): boolean {\n  return 'allOf' in schema || 'anyOf' in schema || 'oneOf' in schema;\n}\n\nfunction isRequestBodySchema(schema: unknown): schema is RMOAS.RequestBodyObject {\n  return 'content' in (schema as RMOAS.RequestBodyObject);\n}\n\n/**\n * Given a JSON pointer, a type of property to look for, and an array of schemas do a reverse\n * search through them until we find the JSON pointer, or part of it, within the array.\n *\n * This function will allow you to take a pointer like `/tags/name` and return back `buster` from\n * the following array:\n *\n * ```\n *  [\n *    {\n *      example: {id: 20}\n *    },\n *    {\n *      examples: {\n *        distinctName: {\n *          tags: {name: 'buster'}\n *        }\n *      }\n *    }\n *  ]\n * ```\n *\n * As with most things however, this is not without its quirks! If a deeply nested property shares\n * the same name as an example that's further up the stack (like `tags.id` and an example for `id`),\n * there's a chance that it'll be misidentified as having an example and receive the wrong value.\n *\n * That said, any example is usually better than no example though, so while it's quirky behavior\n * it shouldn't raise immediate cause for alarm.\n *\n * @see {@link https://tools.ietf.org/html/rfc6901}\n * @param property Specific type of schema property to look for a value for.\n * @param pointer JSON pointer to search for an example for.\n * @param schemas Array of previous schemas we've found relating to this pointer.\n */\nfunction searchForValueByPropAndPointer(\n  property: 'default' | 'example',\n  pointer: string,\n  schemas: toJSONSchemaOptions['prevDefaultSchemas'] | toJSONSchemaOptions['prevExampleSchemas'] = [],\n) {\n  if (!schemas.length || !pointer.length) {\n    return undefined;\n  }\n\n  const locSplit = pointer.split('/').filter(Boolean).reverse();\n  const pointers = [];\n\n  let point = '';\n  for (let i = 0; i < locSplit.length; i += 1) {\n    point = `/${locSplit[i]}${point}`;\n    pointers.push(point);\n  }\n\n  let foundValue;\n  const rev = [...schemas].reverse();\n\n  for (let i = 0; i < pointers.length; i += 1) {\n    for (let ii = 0; ii < rev.length; ii += 1) {\n      let schema = rev[ii];\n\n      if (property === 'example') {\n        if ('example' in schema) {\n          schema = schema.example;\n        } else {\n          if (!Array.isArray(schema.examples) || !schema.examples.length) {\n            continue;\n          }\n\n          // Prevent us from crashing if `examples` is a completely empty object.\n          schema = [...schema.examples].shift();\n        }\n      } else {\n        schema = schema.default;\n      }\n\n      try {\n        foundValue = jsonpointer.get(schema, pointers[i]);\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      } catch (err) {\n        // If the schema we're looking at is `{obj: null}` and our pointer is `/obj/propertyName`\n        // `jsonpointer` will throw an error. If that happens, we should silently catch and toss it\n        // and return no example.\n      }\n\n      if (foundValue !== undefined) {\n        break;\n      }\n    }\n\n    if (foundValue !== undefined) {\n      break;\n    }\n  }\n\n  return foundValue;\n}\n\n/**\n * Given an OpenAPI-flavored JSON Schema, make an effort to modify it so it's shaped more towards\n * stock JSON Schema.\n *\n * Why do this?\n *\n *  1. OpenAPI 3.0.x supports its own flavor of JSON Schema that isn't fully compatible with most\n *    JSON Schema tooling (like `@readme/oas-form` or `@rjsf/core`).\n *  2. While validating an OpenAPI definition will prevent corrupted or improper schemas from\n *    occuring, we have a lot of legacy schemas in ReadMe that were ingested before we had proper\n *    validation in place, and as a result have some API definitions that will not pass validation\n *    right now. In addition to reshaping OAS-JSON Schema into JSON Schema this library will also\n *    fix these improper schemas: things like `type: object` having `items` instead of `properties`,\n *    or `type: array` missing `items`.\n *  3. To ease the burden of polymorphic handling on our form rendering engine we make an attempt\n *    to merge `allOf` schemas here.\n *  4. Additionally due to OpenAPI 3.0.x not supporting JSON Schema, in order to support the\n *    `example` keyword that OAS supports, we need to do some work in here to remap it into\n *    `examples`. However, since all we care about in respect to examples for usage within\n *    `@readme/oas-form`, we're only retaining primitives. This *slightly* deviates from JSON\n *    Schema in that JSON Schema allows for any schema to be an example, but since\n *    `@readme/oas-form` can only actually **render** primitives, that's what we're retaining.\n *  5. Though OpenAPI 3.1 does support full JSON Schema, this library should be able to handle it\n *    without any problems.\n *\n * And why use this over `@openapi-contrib/openapi-schema-to-json-schema`? Fortunately and\n * unfortunately we've got a lot of API definitions in our database that aren't currently valid so\n * we need to have a lot of bespoke handling for odd quirks, typos, and missing declarations that\n * might be present.\n *\n * @todo add support for `schema: false` and `not` cases.\n * @see {@link https://json-schema.org/draft/2019-09/json-schema-validation.html}\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#schema-object}\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#schema-object}\n * @param data OpenAPI Schema Object to convert to pure JSON Schema.\n */\nexport function toJSONSchema(data: RMOAS.SchemaObject | boolean, opts: toJSONSchemaOptions = {}): RMOAS.SchemaObject {\n  let schema = data === true ? {} : { ...data };\n  const schemaAdditionalProperties = RMOAS.isSchema(schema) ? schema.additionalProperties : null;\n\n  const {\n    addEnumsToDescriptions,\n    currentLocation,\n    globalDefaults,\n    hideReadOnlyProperties,\n    hideWriteOnlyProperties,\n    isPolymorphicAllOfChild,\n    prevDefaultSchemas,\n    prevExampleSchemas,\n    refLogger,\n    transformer,\n  } = {\n    addEnumsToDescriptions: false,\n    currentLocation: '',\n    globalDefaults: {},\n    hideReadOnlyProperties: false,\n    hideWriteOnlyProperties: false,\n    isPolymorphicAllOfChild: false,\n    prevDefaultSchemas: [] as toJSONSchemaOptions['prevDefaultSchemas'],\n    prevExampleSchemas: [] as toJSONSchemaOptions['prevExampleSchemas'],\n    refLogger: () => true,\n    transformer: (s: RMOAS.SchemaObject) => s,\n    ...opts,\n  };\n\n  // If this schema contains a `$ref`, it's circular and we shouldn't try to resolve it. Just\n  // return and move along.\n  if (RMOAS.isRef(schema)) {\n    refLogger(schema.$ref, 'ref');\n\n    return transformer({\n      $ref: schema.$ref,\n    });\n  }\n\n  // If we don't have a set type, but are dealing with an `anyOf`, `oneOf`, or `allOf`\n  // representation let's run through them and make sure they're good.\n  if (RMOAS.isSchema(schema, isPolymorphicAllOfChild)) {\n    // If this is an `allOf` schema we should make an attempt to merge so as to ease the burden on\n    // the tooling that ingests these schemas.\n    if ('allOf' in schema && Array.isArray(schema.allOf)) {\n      try {\n        schema = mergeJSONSchemaAllOf(schema as RMOAS.JSONSchema, {\n          ignoreAdditionalProperties: true,\n          resolvers: {\n            // `merge-json-schema-allof` by default takes the first `description` when you're\n            // merging an `allOf` but because generally when you're merging two schemas together\n            // with an `allOf` you want data in the subsequent schemas to be applied to the first\n            // and `description` should be a part of that.\n            description: (obj: string[]) => {\n              return obj.slice(-1)[0];\n            },\n\n            // `merge-json-schema-allof` doesn't support merging enum arrays but since that's a\n            // safe and simple operation as enums always contain primitives we can handle it\n            // ourselves with a custom resolver.\n            enum: (obj: unknown[]) => {\n              let arr: unknown[] = [];\n              obj.forEach(e => {\n                arr = arr.concat(e);\n              });\n\n              return arr;\n            },\n\n            // for any unknown keywords (e.g., `example`, `format`, `x-readme-ref-name`),\n            // we fallback to using the title resolver (which uses the first value found).\n            // https://github.com/mokkabonna/json-schema-merge-allof/blob/ea2e48ee34415022de5a50c236eb4793a943ad11/src/index.js#L292\n            // https://github.com/mokkabonna/json-schema-merge-allof/blob/ea2e48ee34415022de5a50c236eb4793a943ad11/README.md?plain=1#L147\n            defaultResolver: mergeJSONSchemaAllOf.options.resolvers.title,\n          } as unknown,\n        }) as RMOAS.SchemaObject;\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      } catch (e) {\n        // If we can't merge the `allOf` for whatever reason (like if one item is a `string` and\n        // the other is a `object`) then we should completely remove it from the schema and continue\n        // with whatever we've got. Why? If we don't, any tooling that's ingesting this will need\n        // to account for the incompatible `allOf` and it may be subject to more breakages than\n        // just not having it present would be.\n        const { ...schemaWithoutAllOf } = schema;\n        schema = schemaWithoutAllOf as RMOAS.SchemaObject;\n        delete schema.allOf;\n      }\n\n      // If after merging the `allOf` this schema still contains a `$ref` then it's circular and\n      // we shouldn't do anything else.\n      if (RMOAS.isRef(schema)) {\n        refLogger(schema.$ref, 'ref');\n\n        return transformer({\n          $ref: schema.$ref,\n        });\n      }\n    }\n\n    ['anyOf', 'oneOf'].forEach((polyType: 'anyOf' | 'oneOf') => {\n      if (polyType in schema && Array.isArray(schema[polyType])) {\n        schema[polyType].forEach((item, idx) => {\n          const polyOptions: toJSONSchemaOptions = {\n            addEnumsToDescriptions,\n            currentLocation: `${currentLocation}/${idx}`,\n            globalDefaults,\n            hideReadOnlyProperties,\n            hideWriteOnlyProperties,\n            isPolymorphicAllOfChild: false,\n            prevDefaultSchemas,\n            prevExampleSchemas,\n            refLogger,\n            transformer,\n          };\n\n          // When `properties` or `items` are present alongside a polymorphic schema instead of\n          // letting whatever JSON Schema interpreter is handling these constructed schemas we can\n          // guide its hand a bit by manually transforming it into an inferred `allOf` of the\n          // `properties` + the polymorph schema.\n          //\n          // This `allOf` schema will be merged together when fed through `toJSONSchema`.\n          if ('properties' in schema) {\n            schema[polyType][idx] = toJSONSchema(\n              { required: schema.required, allOf: [item, { properties: schema.properties }] } as RMOAS.SchemaObject,\n              polyOptions,\n            );\n          } else if ('items' in schema) {\n            schema[polyType][idx] = toJSONSchema(\n              { allOf: [item, { items: schema.items }] } as RMOAS.SchemaObject,\n              polyOptions,\n            );\n          } else {\n            schema[polyType][idx] = toJSONSchema(item as RMOAS.SchemaObject, polyOptions);\n          }\n\n          // Ensure that we don't have any invalid `required` booleans lying around.\n          if (\n            isObject(schema[polyType][idx]) &&\n            'required' in (schema[polyType][idx] as SchemaObject) &&\n            typeof (schema[polyType][idx] as SchemaObject).required === 'boolean'\n          ) {\n            delete (schema[polyType][idx] as SchemaObject).required;\n          }\n        });\n      }\n    });\n\n    if ('discriminator' in schema) {\n      if ('mapping' in schema.discriminator && typeof schema.discriminator.mapping === 'object') {\n        // Discriminator mappings aren't written as traditional `$ref` pointers so in order to log\n        // them to the supplied `refLogger`.\n        const mapping = schema.discriminator.mapping;\n        Object.keys(mapping).forEach(k => {\n          refLogger(mapping[k], 'discriminator');\n        });\n      }\n    }\n  }\n\n  // If this schema is malformed for some reason, let's do our best to repair it.\n  if (!('type' in schema) && !isPolymorphicSchema(schema) && !isRequestBodySchema(schema)) {\n    if ('properties' in schema) {\n      schema.type = 'object';\n    } else if ('items' in schema) {\n      schema.type = 'array';\n    } else {\n      // If there's still no `type` on the schema we should leave it alone because we don't have a\n      // great way to know if it's part of a nested schema that should, and couldn't be merged,\n      // into another, or it's just purely malformed.\n      //\n      // Whatever tooling that ingests the generated schema should handle it however it needs to.\n    }\n  }\n\n  if ('type' in schema) {\n    // `nullable` isn't a thing in JSON Schema but it was in OpenAPI 3.0 so we should retain and\n    // translate it into something that's compatible with JSON Schema.\n    if ('nullable' in schema) {\n      if (schema.nullable) {\n        if (Array.isArray(schema.type)) {\n          schema.type.push('null');\n        } else if (schema.type !== null && schema.type !== 'null') {\n          schema.type = [schema.type, 'null'];\n        }\n      }\n\n      delete schema.nullable;\n    }\n\n    if (schema.type === null) {\n      // `type: null` is possible in JSON Schema but we're translating it to a string version\n      // so we don't need to worry about asserting nullish types in our implementations of this\n      // generated schema.\n      schema.type = 'null';\n    } else if (Array.isArray(schema.type)) {\n      if (schema.type.includes(null)) {\n        schema.type[schema.type.indexOf(null)] = 'null';\n      }\n\n      schema.type = Array.from(new Set(schema.type));\n\n      // We don't need `type: [<type>]` when we can just as easily make it `type: <type>`.\n      if (schema.type.length === 1) {\n        schema.type = schema.type.shift();\n      } else if (schema.type.includes('array') || schema.type.includes('boolean') || schema.type.includes('object')) {\n        // If we have a `null` type but there's only two types present then we can remove `null`\n        // as an option and flag the whole schema as `nullable`.\n        const isNullable = schema.type.includes('null');\n\n        if (schema.type.length === 2 && isNullable) {\n          // If this is `array | null` or `object | null` then we don't need to do anything.\n        } else {\n          // If this mixed type has non-primitives then we for convenience of our implementation\n          // we're moving them into a `oneOf`.\n          const nonPrimitives: any[] = [];\n\n          // Because arrays, booleans, and objects are not compatible with any other schem type\n          // other than null we're moving them into an isolated `oneOf`, and as such want to take\n          // with it its specific properties that may be present on our current schema.\n          Object.entries({\n            // https://json-schema.org/understanding-json-schema/reference/array.html\n            array: [\n              'additionalItems',\n              'contains',\n              'items',\n              'maxContains',\n              'maxItems',\n              'minContains',\n              'minItems',\n              'prefixItems',\n              'uniqueItems',\n            ],\n\n            // https://json-schema.org/understanding-json-schema/reference/boolean.html\n            boolean: [\n              // Booleans don't have any boolean-specific properties.\n            ],\n\n            // https://json-schema.org/understanding-json-schema/reference/object.html\n            object: [\n              'additionalProperties',\n              'maxProperties',\n              'minProperties',\n              'nullable',\n              'patternProperties',\n              'properties',\n              'propertyNames',\n              'required',\n            ],\n          }).forEach(([typeKey, keywords]) => {\n            if (!schema.type.includes(typeKey as JSONSchema7TypeName)) {\n              return;\n            }\n\n            const reducedSchema: any = removeUndefinedObjects({\n              type: isNullable ? [typeKey, 'null'] : typeKey,\n\n              allowEmptyValue: (schema as any).allowEmptyValue ?? undefined,\n              deprecated: schema.deprecated ?? undefined,\n              description: schema.description ?? undefined,\n              readOnly: schema.readOnly ?? undefined,\n              title: schema.title ?? undefined,\n              writeOnly: schema.writeOnly ?? undefined,\n            });\n\n            keywords.forEach((t: keyof SchemaObject) => {\n              if (t in schema) {\n                reducedSchema[t] = schema[t];\n                delete schema[t];\n              }\n            });\n\n            nonPrimitives.push(reducedSchema);\n          });\n\n          schema.type = schema.type.filter(t => t !== 'array' && t !== 'boolean' && t !== 'object');\n          if (schema.type.length === 1) {\n            schema.type = schema.type.shift();\n          }\n\n          // Because we may have encountered a fully mixed non-primitive type like `array | object`\n          // we only want to retain the existing schema object if we still have types remaining\n          // in it.\n          if (schema.type.length > 1) {\n            schema = { oneOf: [schema, ...nonPrimitives] };\n          } else {\n            schema = { oneOf: nonPrimitives };\n          }\n        }\n      }\n    }\n  }\n\n  if (RMOAS.isSchema(schema, isPolymorphicAllOfChild)) {\n    if ('default' in schema && isObject(schema.default)) {\n      prevDefaultSchemas.push({ default: schema.default });\n    }\n\n    // JSON Schema doesn't support OpenAPI-style examples so we need to reshape them a bit.\n    if ('example' in schema) {\n      // Only bother adding primitive examples.\n      if (isPrimitive(schema.example)) {\n        schema.examples = [schema.example];\n      } else if (Array.isArray(schema.example)) {\n        schema.examples = schema.example.filter(example => isPrimitive(example));\n        if (!schema.examples.length) {\n          delete schema.examples;\n        }\n      } else {\n        prevExampleSchemas.push({ example: schema.example });\n      }\n\n      delete schema.example;\n    } else if ('examples' in schema) {\n      let reshapedExamples = false;\n      if (typeof schema.examples === 'object' && !Array.isArray(schema.examples)) {\n        const examples: unknown[] = [];\n        Object.keys(schema.examples).forEach(name => {\n          const example = schema.examples[name as unknown as number];\n          if ('$ref' in example) {\n            // no-op because any `$ref` example here after dereferencing is circular so we should\n            // ignore it\n            refLogger(example.$ref, 'ref');\n          } else if ('value' in example) {\n            if (isPrimitive(example.value)) {\n              examples.push(example.value);\n              reshapedExamples = true;\n            } else if (Array.isArray(example.value) && isPrimitive(example.value[0])) {\n              examples.push(example.value[0]);\n              reshapedExamples = true;\n            } else {\n              // If this example is neither a primitive or an array we should dump it into the\n              // `prevExampleSchemas` array because we might be able to extract an example from it\n              // further downstream.\n              prevExampleSchemas.push({\n                example: example.value,\n              });\n            }\n          }\n        });\n\n        if (examples.length) {\n          reshapedExamples = true;\n          schema.examples = examples;\n        }\n      } else if (Array.isArray(schema.examples) && isPrimitive(schema.examples[0])) {\n        // We haven't reshaped `examples` here, but since it's in a state that's preferrable to us\n        // let's keep it around.\n        reshapedExamples = true;\n      }\n\n      if (!reshapedExamples) {\n        delete schema.examples;\n      }\n    }\n\n    // If we didn't have any immediately defined examples, let's search backwards and see if we can\n    // find one. But as we're only looking for primitive example, only try to search for one if\n    // we're dealing with a primitive schema.\n    if (!hasSchemaType(schema, 'array') && !hasSchemaType(schema, 'object') && !schema.examples) {\n      const foundExample = searchForValueByPropAndPointer('example', currentLocation, prevExampleSchemas);\n      if (foundExample) {\n        // We can only really deal with primitives, so only promote those as the found example if\n        // it is.\n        if (isPrimitive(foundExample) || (Array.isArray(foundExample) && isPrimitive(foundExample[0]))) {\n          schema.examples = [foundExample];\n        }\n      }\n    }\n\n    if (hasSchemaType(schema, 'array')) {\n      if ('items' in schema) {\n        if (!Array.isArray(schema.items) && Object.keys(schema.items).length === 1 && RMOAS.isRef(schema.items)) {\n          // `items` contains a `$ref`, so since it's circular we should do a no-op here and log\n          // and ignore it.\n          refLogger(schema.items.$ref, 'ref');\n        } else if (schema.items !== true) {\n          // Run through the arrays contents and clean them up.\n          schema.items = toJSONSchema(schema.items as RMOAS.SchemaObject, {\n            addEnumsToDescriptions,\n            currentLocation: `${currentLocation}/0`,\n            globalDefaults,\n            hideReadOnlyProperties,\n            hideWriteOnlyProperties,\n            prevExampleSchemas,\n            refLogger,\n            transformer,\n          });\n\n          // If we have a non-array `required` entry in our `items` schema then it's invalid and we\n          // should remove it. We only support non-array boolean `required` properties inside object\n          // properties.\n          if (isObject(schema.items) && 'required' in schema.items && !Array.isArray(schema.items.required)) {\n            delete schema.items.required;\n          }\n        }\n      } else if ('properties' in schema || 'additionalProperties' in schema) {\n        // This is a fix to handle cases where someone may have typod `items` as `properties` on an\n        // array. Since throwing a complete failure isn't ideal, we can see that they meant for the\n        // type to be `object`, so we can do our best to shape the data into what they were\n        // intending it to be.\n        schema.type = 'object';\n      } else {\n        // This is a fix to handle cases where we have a malformed array with no `items` property\n        // present.\n        (schema as any).items = {};\n      }\n    } else if (hasSchemaType(schema, 'object')) {\n      if ('properties' in schema) {\n        Object.keys(schema.properties).forEach(prop => {\n          if (\n            Array.isArray(schema.properties[prop]) ||\n            (typeof schema.properties[prop] === 'object' && schema.properties[prop] !== null)\n          ) {\n            const newPropSchema = toJSONSchema(schema.properties[prop] as RMOAS.SchemaObject, {\n              addEnumsToDescriptions,\n              currentLocation: `${currentLocation}/${encodePointer(prop)}`,\n              globalDefaults,\n              hideReadOnlyProperties,\n              hideWriteOnlyProperties,\n              prevDefaultSchemas,\n              prevExampleSchemas,\n              refLogger,\n              transformer,\n            });\n\n            // If this property is read or write only then we should fully hide it from its parent schema.\n            let propShouldBeUpdated = true;\n            if ((hideReadOnlyProperties || hideWriteOnlyProperties) && !Object.keys(newPropSchema).length) {\n              // We should only delete this schema if it wasn't already empty though. We do this\n              // because we (un)fortunately have handling in our API Explorer form system for\n              // schemas that are devoid of any `type` declaration.\n              if (Object.keys(schema.properties[prop]).length > 0) {\n                delete schema.properties[prop];\n                propShouldBeUpdated = false;\n              }\n            }\n\n            if (propShouldBeUpdated) {\n              schema.properties[prop] = newPropSchema;\n\n              /**\n               * JSON Schema does not have any support for `required: <boolean>` but because some\n               * of our users do this, and it does not throw OpenAPI validation errors thanks to\n               * some extremely loose typings around `schema` in the official JSON Schema\n               * definitions that the OAI offers, we're opting to support these users and upgrade\n               * their invalid `required` definitions into ones that our tooling can interpret.\n               *\n               * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/schemas/v3.1/schema.json#L1114-L1121}\n               */\n              if (\n                isObject(newPropSchema) &&\n                'required' in newPropSchema &&\n                typeof newPropSchema.required === 'boolean' &&\n                newPropSchema.required === true\n              ) {\n                if ('required' in schema && Array.isArray(schema.required)) {\n                  schema.required.push(prop);\n                } else {\n                  schema.required = [prop];\n                }\n\n                delete (schema.properties[prop] as SchemaObject).required;\n              }\n            }\n          }\n        });\n\n        // If we want to hide all readOnly or writeOnly properites and it happens to be that this\n        // object was comprised of only those then we shouldn't render this object.\n        if (hideReadOnlyProperties || hideWriteOnlyProperties) {\n          if (!Object.keys(schema.properties).length) {\n            return transformer({});\n          }\n        }\n      }\n\n      if (typeof schemaAdditionalProperties === 'object' && schemaAdditionalProperties !== null) {\n        // If this `additionalProperties` is completely empty and devoid of any sort of schema,\n        // treat it as such. Otherwise let's recurse into it and see if we can sort it out.\n        if (\n          !('type' in schemaAdditionalProperties) &&\n          !('$ref' in schemaAdditionalProperties) &&\n          // We know it will be a schema object because it's dereferenced\n          !isPolymorphicSchema(schemaAdditionalProperties as RMOAS.SchemaObject)\n        ) {\n          schema.additionalProperties = true;\n        } else {\n          // We know it will be a schema object because it's dereferenced\n          schema.additionalProperties = toJSONSchema(schemaAdditionalProperties as RMOAS.SchemaObject, {\n            addEnumsToDescriptions,\n            currentLocation,\n            globalDefaults,\n            hideReadOnlyProperties,\n            hideWriteOnlyProperties,\n            prevDefaultSchemas,\n            prevExampleSchemas,\n            refLogger,\n            transformer,\n          });\n        }\n      }\n\n      // Since neither `properties` and `additionalProperties` are actually required to be present\n      // on an object, since we construct this schema work to build up a form we still need\n      // *something* for the user to enter in for this object so we'll add back in\n      // `additionalProperties` for that.\n      if (!isPolymorphicSchema(schema) && !('properties' in schema) && !('additionalProperties' in schema)) {\n        schema.additionalProperties = true;\n      }\n    }\n  }\n\n  /**\n   * Users can pass in parameter defaults via JWT User Data. We're checking to see if the defaults\n   * being passed in exist on endpoints via jsonpointer\n   *\n   * @see {@link https://docs.readme.com/docs/passing-data-to-jwt}\n   */\n  if (\n    RMOAS.isSchema(schema, isPolymorphicAllOfChild) &&\n    globalDefaults &&\n    Object.keys(globalDefaults).length > 0 &&\n    currentLocation\n  ) {\n    try {\n      const userJwtDefault = jsonpointer.get(globalDefaults, currentLocation);\n      if (userJwtDefault) {\n        schema.default = userJwtDefault;\n      }\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    } catch (err) {\n      // If jsonpointer returns an error, we won't show any defaults for that path.\n    }\n  }\n\n  // Only add a default value if we actually have one.\n  if ('default' in schema && typeof schema.default !== 'undefined') {\n    if (hasSchemaType(schema, 'object')) {\n      // Defaults for `object` and types have been dereferenced into their children schemas already\n      // above so we don't need to preserve this default anymore.\n      delete schema.default;\n    } else if (\n      ('allowEmptyValue' in schema && schema.allowEmptyValue && schema.default === '') ||\n      schema.default !== ''\n    ) {\n      // If we have `allowEmptyValue` present, and the default is actually an empty string, let it\n      // through as it's allowed.\n    } else {\n      // If the default is empty and we don't want to allowEmptyValue, we need to remove the\n      // default.\n      delete schema.default;\n    }\n  } else if (prevDefaultSchemas.length) {\n    const foundDefault = searchForValueByPropAndPointer('default', currentLocation, prevDefaultSchemas);\n\n    // We shouldn't ever set an object default out of the parent lineage tree defaults because\n    // the contents of that object will be set on the schema that they're a part of. Setting\n    // that object as well would result us in duplicating the defaults for that schema in two\n    // places.\n    if (\n      isPrimitive(foundDefault) ||\n      foundDefault === null ||\n      (Array.isArray(foundDefault) && hasSchemaType(schema, 'array'))\n    ) {\n      schema.default = foundDefault;\n    }\n  }\n\n  if (RMOAS.isSchema(schema, isPolymorphicAllOfChild) && 'enum' in schema && Array.isArray(schema.enum)) {\n    // Enums should not have duplicated items as those will break AJV validation.\n    // If we ever target ES6 for typescript we can drop this array.from.\n    // https://stackoverflow.com/questions/33464504/using-spread-syntax-and-new-set-with-typescript/56870548\n    schema.enum = Array.from(new Set(schema.enum));\n\n    // If we want to add enums to descriptions (like in the case of response JSON Schema)\n    // generation we need to convert them into a list of Markdown tilda'd strings. We're also\n    // filtering away empty and falsy strings here because adding empty `` blocks to the description\n    // will serve nobody any good.\n    if (addEnumsToDescriptions) {\n      const enums = schema.enum\n        .filter(Boolean)\n        .map(str => `\\`${str}\\``)\n        .join(' ');\n\n      if (enums.length) {\n        if ('description' in schema) {\n          schema.description += `\\n\\n${enums}`;\n        } else {\n          schema.description = enums;\n        }\n      }\n    }\n  }\n\n  // Clean up any remaining `items` or `properties` schema fragments lying around if there's also\n  // polymorphism present.\n  if ('anyOf' in schema || 'oneOf' in schema) {\n    if ('properties' in schema) {\n      delete schema.properties;\n    }\n\n    if ('items' in schema) {\n      delete schema.items;\n    }\n  }\n\n  // Remove unsupported JSON Schema props.\n  for (let i = 0; i < UNSUPPORTED_SCHEMA_PROPS.length; i += 1) {\n    // Using the as here because the purpose is to delete keys we don't expect, so of course the\n    // typing won't work\n    delete (schema as Record<string, unknown>)[UNSUPPORTED_SCHEMA_PROPS[i]];\n  }\n\n  // If we want to hide any `readOnly` or `writeOnly` schemas, and this one is that, then we\n  // shouldn't return anything.\n  if (hideReadOnlyProperties && 'readOnly' in schema && schema.readOnly === true) {\n    return {};\n  } else if (hideWriteOnlyProperties && 'writeOnly' in schema && schema.writeOnly === true) {\n    return {};\n  }\n\n  return transformer(schema);\n}\n","import type { toJSONSchemaOptions } from '../../lib/openapi-to-json-schema.js';\nimport type { ComponentsObject, ExampleObject, OASDocument, ParameterObject, SchemaObject } from '../../types.js';\nimport type { Operation } from '../index.js';\nimport type { OpenAPIV3_1 } from 'openapi-types';\n\nimport { PARAMETER_ORDERING, getExtension } from '../../extensions.js';\nimport cloneObject from '../../lib/clone-object.js';\nimport { isPrimitive } from '../../lib/helpers.js';\nimport matchesMimetype from '../../lib/matches-mimetype.js';\nimport { toJSONSchema, getSchemaVersionString } from '../../lib/openapi-to-json-schema.js';\n\nexport interface SchemaWrapper {\n  $schema?: string;\n  deprecatedProps?: SchemaWrapper;\n  description?: string;\n  label?: string;\n  schema: SchemaObject;\n  type: string;\n}\n\n/**\n * The order of this object determines how they will be sorted in the compiled JSON Schema\n * representation.\n *\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#parameter-object}\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#parameter-object}\n */\nexport const types: Record<keyof OASDocument, string> = {\n  path: 'Path Params',\n  query: 'Query Params',\n  body: 'Body Params',\n  cookie: 'Cookie Params',\n  formData: 'Form Data',\n  header: 'Headers',\n  metadata: 'Metadata', // This a special type reserved for https://npm.im/api\n};\n\nexport interface getParametersAsJSONSchemaOptions {\n  /**\n   * Contains an object of user defined schema defaults.\n   */\n  globalDefaults?: Record<string, unknown>;\n\n  /**\n   * If you wish to hide properties that are marked as being `readOnly`.\n   */\n  hideReadOnlyProperties?: boolean;\n\n  /**\n   * If you wish to hide properties that are marked as being `writeOnly`.\n   */\n  hideWriteOnlyProperties?: boolean;\n\n  /**\n   * If you wish to include discriminator mapping `$ref` components alongside your\n   * `discriminator` in schemas. Defaults to `true`.\n   */\n  includeDiscriminatorMappingRefs?: boolean;\n\n  /**\n   * If you want the output to be two objects: body (contains `body` and `formData` JSON\n   * Schema) and metadata (contains `path`, `query`, `cookie`, and `header`).\n   */\n  mergeIntoBodyAndMetadata?: boolean;\n\n  /**\n   * If you wish to **not** split out deprecated properties into a separate `deprecatedProps`\n   * object.\n   */\n  retainDeprecatedProperties?: boolean;\n\n  /**\n   * With a transformer you can transform any data within a given schema, like say if you want\n   * to rewrite a potentially unsafe `title` that might be eventually used as a JS variable\n   * name, just make sure to return your transformed schema.\n   */\n  transformer?: (schema: SchemaObject) => SchemaObject;\n}\n\nexport function getParametersAsJSONSchema(\n  operation: Operation,\n  api: OASDocument,\n  opts?: getParametersAsJSONSchemaOptions,\n): SchemaWrapper[] {\n  let hasCircularRefs = false;\n  let hasDiscriminatorMappingRefs = false;\n\n  function refLogger(ref: string, type: 'discriminator' | 'ref') {\n    if (type === 'ref') {\n      hasCircularRefs = true;\n    } else {\n      hasDiscriminatorMappingRefs = true;\n    }\n  }\n\n  function getDeprecated(schema: SchemaObject, type: string) {\n    // If we wish to retain deprecated properties then we shouldn't split them out into the\n    // `deprecatedProps` object.\n    if (opts.retainDeprecatedProperties) {\n      return null;\n    }\n\n    // If there's no properties, bail\n    if (!schema || !schema.properties) return null;\n\n    // Clone the original schema so this doesn't interfere with it\n    const deprecatedBody = cloneObject(schema);\n\n    // Booleans are not valid for required in draft 4, 7 or 2020. Not sure why the typing thinks\n    // they are.\n    const requiredParams = (schema.required || []) as string[];\n\n    // Find all top-level deprecated properties from the schema - required and readOnly params are\n    // excluded.\n    const allDeprecatedProps: Record<string, SchemaObject> = {};\n\n    Object.keys(deprecatedBody.properties).forEach(key => {\n      const deprecatedProp = deprecatedBody.properties[key] as SchemaObject;\n      if (deprecatedProp.deprecated && !requiredParams.includes(key) && !deprecatedProp.readOnly) {\n        allDeprecatedProps[key] = deprecatedProp;\n      }\n    });\n\n    // We know this is the right type. todo: don't use as\n    (deprecatedBody.properties as Record<string, SchemaObject>) = allDeprecatedProps;\n    const deprecatedSchema = toJSONSchema(deprecatedBody, {\n      globalDefaults: opts.globalDefaults,\n      hideReadOnlyProperties: opts.hideReadOnlyProperties,\n      hideWriteOnlyProperties: opts.hideWriteOnlyProperties,\n      prevExampleSchemas: [],\n      refLogger,\n      transformer: opts.transformer,\n    });\n\n    // Check if the schema wasn't created or there's no deprecated properties\n    if (Object.keys(deprecatedSchema).length === 0 || Object.keys(deprecatedSchema.properties).length === 0) {\n      return null;\n    }\n\n    // Remove deprecated properties from the original schema\n    // Not using the clone here becuase we WANT this to affect the original\n    Object.keys(schema.properties).forEach(key => {\n      // We know this will always be a SchemaObject\n      if ((schema.properties[key] as SchemaObject).deprecated && !requiredParams.includes(key)) {\n        delete schema.properties[key];\n      }\n    });\n\n    return {\n      type,\n      schema: isPrimitive(deprecatedSchema)\n        ? deprecatedSchema\n        : {\n            ...deprecatedSchema,\n            $schema: getSchemaVersionString(deprecatedSchema, api),\n          },\n    };\n  }\n\n  /**\n   *\n   */\n  function transformRequestBody(): SchemaWrapper {\n    const requestBody = operation.getRequestBody();\n    if (!requestBody || !Array.isArray(requestBody)) return null;\n\n    const [mediaType, mediaTypeObject, description] = requestBody;\n    const type = mediaType === 'application/x-www-form-urlencoded' ? 'formData' : 'body';\n\n    // If this schema is completely empty, don't bother processing it.\n    if (!mediaTypeObject.schema || !Object.keys(mediaTypeObject.schema).length) {\n      return null;\n    }\n\n    const prevExampleSchemas: toJSONSchemaOptions['prevExampleSchemas'] = [];\n    if ('example' in mediaTypeObject) {\n      prevExampleSchemas.push({ example: mediaTypeObject.example });\n    } else if ('examples' in mediaTypeObject) {\n      prevExampleSchemas.push({\n        examples: Object.values(mediaTypeObject.examples)\n          .map((example: ExampleObject) => example.value)\n          .filter(val => val !== undefined),\n      });\n    }\n\n    // We're cloning the request schema because we've had issues with request schemas that were\n    // dereferenced being processed multiple times because their component is also processed.\n    const requestSchema = cloneObject(mediaTypeObject.schema);\n\n    const cleanedSchema = toJSONSchema(requestSchema, {\n      globalDefaults: opts.globalDefaults,\n      hideReadOnlyProperties: opts.hideReadOnlyProperties,\n      hideWriteOnlyProperties: opts.hideWriteOnlyProperties,\n      prevExampleSchemas,\n      refLogger,\n      transformer: opts.transformer,\n    });\n\n    // If this schema is **still** empty, don't bother returning it.\n    if (!Object.keys(cleanedSchema).length) {\n      return null;\n    }\n\n    return {\n      type,\n      label: types[type],\n      schema: isPrimitive(cleanedSchema)\n        ? cleanedSchema\n        : {\n            ...cleanedSchema,\n            $schema: getSchemaVersionString(cleanedSchema, api),\n          },\n      deprecatedProps: getDeprecated(cleanedSchema, type),\n      ...(description ? { description } : {}),\n    };\n  }\n\n  function transformComponents(): ComponentsObject {\n    if (!('components' in api)) {\n      return false;\n    }\n\n    const components: Partial<ComponentsObject> = {\n      ...Object.keys(api.components)\n        .map(componentType => ({ [componentType]: {} }))\n        .reduce((prev, next) => Object.assign(prev, next), {}),\n    };\n\n    Object.keys(api.components).forEach((componentType: keyof ComponentsObject) => {\n      if (typeof api.components[componentType] === 'object' && !Array.isArray(api.components[componentType])) {\n        Object.keys(api.components[componentType]).forEach(schemaName => {\n          const componentSchema = cloneObject(api.components[componentType][schemaName]);\n          components[componentType][schemaName] = toJSONSchema(componentSchema as SchemaObject, {\n            globalDefaults: opts.globalDefaults,\n            hideReadOnlyProperties: opts.hideReadOnlyProperties,\n            hideWriteOnlyProperties: opts.hideWriteOnlyProperties,\n            refLogger,\n            transformer: opts.transformer,\n          });\n        });\n      }\n    });\n\n    // If none of our above component type placeholders got used let's clean them up.\n    Object.keys(components).forEach((componentType: keyof ComponentsObject) => {\n      if (!Object.keys(components[componentType]).length) {\n        delete components[componentType];\n      }\n    });\n\n    return components;\n  }\n\n  function transformParameters(): SchemaWrapper[] {\n    const operationParams = operation.getParameters();\n\n    const transformed = Object.keys(types)\n      .map(type => {\n        const required: string[] = [];\n\n        // This `as` actually *could* be a ref, but we don't want refs to pass through here, so\n        // `.in` will never match `type`\n        const parameters = operationParams.filter(param => (param as ParameterObject).in === type);\n        if (parameters.length === 0) {\n          return null;\n        }\n\n        const properties = parameters.reduce((prev: Record<string, SchemaObject>, current: ParameterObject) => {\n          let schema: SchemaObject = {};\n          if ('schema' in current) {\n            const currentSchema: SchemaObject = current.schema ? cloneObject(current.schema) : {};\n\n            if (current.example) {\n              // `example` can be present outside of the `schema` block so if it's there we should\n              // pull it in so it can be handled and returned if it's valid.\n              currentSchema.example = current.example;\n            } else if (current.examples) {\n              // `examples` isn't actually supported here in OAS 3.0, but we might as well support\n              // it because `examples` is JSON Schema and that's fully supported in OAS 3.1.\n              currentSchema.examples = current.examples as unknown as unknown[];\n            }\n\n            if (current.deprecated) currentSchema.deprecated = current.deprecated;\n\n            const interimSchema = toJSONSchema(currentSchema, {\n              currentLocation: `/${current.name}`,\n              globalDefaults: opts.globalDefaults,\n              hideReadOnlyProperties: opts.hideReadOnlyProperties,\n              hideWriteOnlyProperties: opts.hideWriteOnlyProperties,\n              refLogger,\n              transformer: opts.transformer,\n            });\n\n            schema = isPrimitive(interimSchema)\n              ? interimSchema\n              : {\n                  ...interimSchema,\n\n                  // Note: this applies a `$schema` version to each field in the larger schema\n                  // object. It's not really **correct** but it's what we have to do because\n                  // there's a chance that the end user has indicated the schemas are different.\n                  $schema: getSchemaVersionString(currentSchema, api),\n                };\n          } else if ('content' in current && typeof current.content === 'object') {\n            const contentKeys = Object.keys(current.content);\n            if (contentKeys.length) {\n              let contentType;\n              if (contentKeys.length === 1) {\n                contentType = contentKeys[0];\n              } else {\n                // We should always try to prioritize `application/json` over any other possible\n                // content that might be present on this schema.\n                const jsonLikeContentTypes = contentKeys.filter(k => matchesMimetype.json(k));\n                if (jsonLikeContentTypes.length) {\n                  contentType = jsonLikeContentTypes[0];\n                } else {\n                  contentType = contentKeys[0];\n                }\n              }\n\n              if (typeof current.content[contentType] === 'object' && 'schema' in current.content[contentType]) {\n                const currentSchema: SchemaObject = current.content[contentType].schema\n                  ? cloneObject(current.content[contentType].schema)\n                  : {};\n\n                if (current.example) {\n                  // `example` can be present outside of the `schema` block so if it's there we\n                  // should pull it in so it can be handled and returned if it's valid.\n                  currentSchema.example = current.example;\n                } else if (current.examples) {\n                  // `examples` isn't actually supported here in OAS 3.0, but we might as well\n                  // support it because `examples` is JSON Schema and that's fully supported in OAS\n                  // 3.1.\n                  currentSchema.examples = current.examples as unknown as unknown[];\n                }\n\n                if (current.deprecated) currentSchema.deprecated = current.deprecated;\n\n                const interimSchema = toJSONSchema(currentSchema, {\n                  currentLocation: `/${current.name}`,\n                  globalDefaults: opts.globalDefaults,\n                  hideReadOnlyProperties: opts.hideReadOnlyProperties,\n                  hideWriteOnlyProperties: opts.hideWriteOnlyProperties,\n                  refLogger,\n                  transformer: opts.transformer,\n                });\n\n                schema = isPrimitive(interimSchema)\n                  ? interimSchema\n                  : {\n                      ...interimSchema,\n\n                      // Note: this applies a `$schema` version to each field in the larger schema\n                      // object. It's not really **correct** but it's what we have to do because\n                      // there's a chance that the end user has indicated the schemas are different.\n                      $schema: getSchemaVersionString(currentSchema, api),\n                    };\n              }\n            }\n          }\n\n          // Parameter descriptions don't exist in `current.schema` so `constructSchema` will never\n          // have access to it.\n          if (current.description) {\n            if (!isPrimitive(schema)) {\n              schema.description = current.description;\n            }\n          }\n\n          prev[current.name] = schema;\n\n          if (current.required) {\n            required.push(current.name);\n          }\n\n          return prev;\n        }, {});\n\n        // This typing is technically WRONG :( but it's the best we can do for now.\n        const schema: OpenAPIV3_1.SchemaObject = {\n          type: 'object',\n          properties: properties as Record<string, OpenAPIV3_1.SchemaObject>,\n          required,\n        };\n\n        return {\n          type,\n          label: types[type],\n          schema,\n          deprecatedProps: getDeprecated(schema, type),\n        };\n      })\n      .filter(Boolean);\n\n    if (!opts.mergeIntoBodyAndMetadata) {\n      return transformed;\n    } else if (!transformed.length) {\n      return [];\n    }\n\n    // If we want to merge parameters into a single metadata entry then we need to pull all\n    // available schemas and `deprecatedProps` (if we don't want to retain them via the\n    // `retainDeprecatedProps` option) under one roof.\n    const deprecatedProps = transformed.map(r => r.deprecatedProps?.schema || null).filter(Boolean);\n    return [\n      {\n        type: 'metadata',\n        label: types.metadata,\n        schema: {\n          allOf: transformed.map(r => r.schema),\n        } as SchemaObject,\n        deprecatedProps: deprecatedProps.length\n          ? {\n              type: 'metadata',\n              schema: {\n                allOf: deprecatedProps,\n              } as SchemaObject,\n            }\n          : null,\n      },\n    ];\n  }\n\n  // If this operation neither has any parameters or a request body then we should return null\n  // because there won't be any JSON Schema.\n  if (!operation.hasParameters() && !operation.hasRequestBody()) {\n    return null;\n  }\n\n  // `metadata` is `api` SDK specific, is not a part of the `PARAMETER_ORDERING` extension, and\n  // should always be sorted last. We also define `formData` as `form` in the extension because\n  // we don't want folks to have to deal with casing issues so we need to rewrite it to `formData`.\n  const typeKeys = (getExtension(PARAMETER_ORDERING, api, operation) as string[]).map(k => k.toLowerCase());\n  typeKeys[typeKeys.indexOf('form')] = 'formData';\n  typeKeys.push('metadata');\n\n  const jsonSchema = [transformRequestBody()].concat(...transformParameters()).filter(Boolean);\n\n  // We should only include `components`, or even bother transforming components into JSON Schema,\n  // if we either have circular refs or if we have discriminator mapping refs somewhere and want to\n  // include them.\n  const shouldIncludeComponents =\n    hasCircularRefs || (hasDiscriminatorMappingRefs && opts.includeDiscriminatorMappingRefs);\n\n  const components = shouldIncludeComponents ? transformComponents() : false;\n\n  return jsonSchema\n    .map(group => {\n      /**\n       * Since this library assumes that the schema has already been dereferenced, adding every\n       * component here that **isn't** circular adds a ton of bloat so it'd be cool if `components`\n       * was just the remaining `$ref` pointers that are still being referenced.\n       *\n       * @todo\n       */\n      if (components && shouldIncludeComponents) {\n        // Fixing typing and confused version mismatches\n        (group.schema.components as ComponentsObject) = components;\n      }\n\n      // Delete deprecatedProps if it's null on the schema.\n      if (!group.deprecatedProps) delete group.deprecatedProps;\n\n      return group;\n    })\n    .sort((a, b) => {\n      return typeKeys.indexOf(a.type) - typeKeys.indexOf(b.type);\n    });\n}\n"],"mappings":";;;;;;;;;;;AAAe,SAAR,YAAgC,KAAW;AAChD,MAAI,OAAO,QAAQ,aAAa;AAC9B,WAAO;AAAA,EACT;AAGA,SAAO,KAAK,MAAM,KAAK,UAAU,GAAG,CAAC;AACvC;;;ACLO,SAAS,cAAc,QAAsB,eAA4C;AAC9F,MAAI,MAAM,QAAQ,OAAO,IAAI,GAAG;AAC9B,WAAO,OAAO,KAAK,SAAS,aAAa;AAAA,EAC3C;AAEA,SAAO,OAAO,SAAS;AACzB;AAEO,SAAS,SAAS,KAA8C;AACrE,SAAO,OAAO,QAAQ,YAAY,QAAQ,QAAQ,CAAC,MAAM,QAAQ,GAAG;AACtE;AAEO,SAAS,YAAY,KAAgD;AAC1E,SAAO,OAAO,QAAQ,YAAY,OAAO,QAAQ,YAAY,OAAO,QAAQ;AAC9E;;;AChBA,SAAS,iBAAiBA,QAAiB,WAA4B;AACrE,SAAOA,OAAM,KAAK,UAAQ;AACxB,WAAO,UAAU,QAAQ,IAAI,IAAI;AAAA,EACnC,CAAC;AACH;AAEA,IAAO,2BAAQ;AAAA,EACb,gBAAgB,CAAC,aAA8B;AAC7C,WAAO,iBAAiB,CAAC,mCAAmC,GAAG,QAAQ;AAAA,EACzE;AAAA,EAEA,MAAM,CAAC,gBAAiC;AACtC,WAAO;AAAA,MACL,CAAC,oBAAoB,sBAAsB,aAAa,eAAe,OAAO;AAAA,MAC9E;AAAA,IACF;AAAA,EACF;AAAA,EAEA,WAAW,CAAC,gBAAiC;AAC3C,WAAO;AAAA,MACL,CAAC,mBAAmB,qBAAqB,uBAAuB,uBAAuB;AAAA,MACvF;AAAA,IACF;AAAA,EACF;AAAA,EAEA,UAAU,CAAC,gBAAiC;AAC1C,WAAO,gBAAgB;AAAA,EACzB;AAAA,EAEA,KAAK,CAAC,gBAAiC;AACrC,WAAO;AAAA,MACL;AAAA,QACE;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,MACA;AAAA,IACF;AAAA,EACF;AACF;;;ACrCA,OAAO,0BAA0B;AACjC,OAAO,iBAAiB;AACxB,OAAO,4BAA4B;AAcnC,IAAM,2BAA2B;AAAA,EAC/B;AAAA;AAAA,EACA;AAAA,EACA;AACF;AA8DA,SAAS,cAAc,KAAa;AAClC,SAAO,IAAI,QAAQ,KAAK,IAAI,EAAE,QAAQ,KAAK,IAAI;AACjD;AAEO,SAAS,uBAAuB,QAA4B,KAAgC;AAEjG,MAAI,CAAO,QAAQ,GAAG,GAAG;AAEvB,WAAO;AAAA,EACT;AAQA,MAAK,OAAoC,SAAS;AAChD,WAAQ,OAAoC;AAAA,EAC9C;AAGA,MAAI,IAAI,mBAAmB;AACzB,WAAO,IAAI;AAAA,EACb;AAEA,SAAO;AACT;AAEA,SAAS,oBAAoB,QAAqC;AAChE,SAAO,WAAW,UAAU,WAAW,UAAU,WAAW;AAC9D;AAEA,SAAS,oBAAoB,QAAoD;AAC/E,SAAO,aAAc;AACvB;AAoCA,SAAS,+BACP,UACA,SACA,UAAiG,CAAC,GAClG;AACA,MAAI,CAAC,QAAQ,UAAU,CAAC,QAAQ,QAAQ;AACtC,WAAO;AAAA,EACT;AAEA,QAAM,WAAW,QAAQ,MAAM,GAAG,EAAE,OAAO,OAAO,EAAE,QAAQ;AAC5D,QAAM,WAAW,CAAC;AAElB,MAAI,QAAQ;AACZ,WAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK,GAAG;AAC3C,YAAQ,IAAI,SAAS,CAAC,CAAC,GAAG,KAAK;AAC/B,aAAS,KAAK,KAAK;AAAA,EACrB;AAEA,MAAI;AACJ,QAAM,MAAM,CAAC,GAAG,OAAO,EAAE,QAAQ;AAEjC,WAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK,GAAG;AAC3C,aAAS,KAAK,GAAG,KAAK,IAAI,QAAQ,MAAM,GAAG;AACzC,UAAI,SAAS,IAAI,EAAE;AAEnB,UAAI,aAAa,WAAW;AAC1B,YAAI,aAAa,QAAQ;AACvB,mBAAS,OAAO;AAAA,QAClB,OAAO;AACL,cAAI,CAAC,MAAM,QAAQ,OAAO,QAAQ,KAAK,CAAC,OAAO,SAAS,QAAQ;AAC9D;AAAA,UACF;AAGA,mBAAS,CAAC,GAAG,OAAO,QAAQ,EAAE,MAAM;AAAA,QACtC;AAAA,MACF,OAAO;AACL,iBAAS,OAAO;AAAA,MAClB;AAEA,UAAI;AACF,qBAAa,YAAY,IAAI,QAAQ,SAAS,CAAC,CAAC;AAAA,MAElD,SAAS,KAAK;AAAA,MAId;AAEA,UAAI,eAAe,QAAW;AAC5B;AAAA,MACF;AAAA,IACF;AAEA,QAAI,eAAe,QAAW;AAC5B;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAsCO,SAAS,aAAa,MAAoC,OAA4B,CAAC,GAAuB;AACnH,MAAI,SAAS,SAAS,OAAO,CAAC,IAAI,EAAE,GAAG,KAAK;AAC5C,QAAM,6BAAmC,SAAS,MAAM,IAAI,OAAO,uBAAuB;AAE1F,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI;AAAA,IACF,wBAAwB;AAAA,IACxB,iBAAiB;AAAA,IACjB,gBAAgB,CAAC;AAAA,IACjB,wBAAwB;AAAA,IACxB,yBAAyB;AAAA,IACzB,yBAAyB;AAAA,IACzB,oBAAoB,CAAC;AAAA,IACrB,oBAAoB,CAAC;AAAA,IACrB,WAAW,MAAM;AAAA,IACjB,aAAa,CAAC,MAA0B;AAAA,IACxC,GAAG;AAAA,EACL;AAIA,MAAU,MAAM,MAAM,GAAG;AACvB,cAAU,OAAO,MAAM,KAAK;AAE5B,WAAO,YAAY;AAAA,MACjB,MAAM,OAAO;AAAA,IACf,CAAC;AAAA,EACH;AAIA,MAAU,SAAS,QAAQ,uBAAuB,GAAG;AAGnD,QAAI,WAAW,UAAU,MAAM,QAAQ,OAAO,KAAK,GAAG;AACpD,UAAI;AACF,iBAAS,qBAAqB,QAA4B;AAAA,UACxD,4BAA4B;AAAA,UAC5B,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA,YAKT,aAAa,CAAC,QAAkB;AAC9B,qBAAO,IAAI,MAAM,EAAE,EAAE,CAAC;AAAA,YACxB;AAAA;AAAA;AAAA;AAAA,YAKA,MAAM,CAAC,QAAmB;AACxB,kBAAI,MAAiB,CAAC;AACtB,kBAAI,QAAQ,OAAK;AACf,sBAAM,IAAI,OAAO,CAAC;AAAA,cACpB,CAAC;AAED,qBAAO;AAAA,YACT;AAAA;AAAA;AAAA;AAAA;AAAA,YAMA,iBAAiB,qBAAqB,QAAQ,UAAU;AAAA,UAC1D;AAAA,QACF,CAAC;AAAA,MAEH,SAAS,GAAG;AAMV,cAAM,EAAE,GAAG,mBAAmB,IAAI;AAClC,iBAAS;AACT,eAAO,OAAO;AAAA,MAChB;AAIA,UAAU,MAAM,MAAM,GAAG;AACvB,kBAAU,OAAO,MAAM,KAAK;AAE5B,eAAO,YAAY;AAAA,UACjB,MAAM,OAAO;AAAA,QACf,CAAC;AAAA,MACH;AAAA,IACF;AAEA,KAAC,SAAS,OAAO,EAAE,QAAQ,CAAC,aAAgC;AAC1D,UAAI,YAAY,UAAU,MAAM,QAAQ,OAAO,QAAQ,CAAC,GAAG;AACzD,eAAO,QAAQ,EAAE,QAAQ,CAAC,MAAM,QAAQ;AACtC,gBAAM,cAAmC;AAAA,YACvC;AAAA,YACA,iBAAiB,GAAG,eAAe,IAAI,GAAG;AAAA,YAC1C;AAAA,YACA;AAAA,YACA;AAAA,YACA,yBAAyB;AAAA,YACzB;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACF;AAQA,cAAI,gBAAgB,QAAQ;AAC1B,mBAAO,QAAQ,EAAE,GAAG,IAAI;AAAA,cACtB,EAAE,UAAU,OAAO,UAAU,OAAO,CAAC,MAAM,EAAE,YAAY,OAAO,WAAW,CAAC,EAAE;AAAA,cAC9E;AAAA,YACF;AAAA,UACF,WAAW,WAAW,QAAQ;AAC5B,mBAAO,QAAQ,EAAE,GAAG,IAAI;AAAA,cACtB,EAAE,OAAO,CAAC,MAAM,EAAE,OAAO,OAAO,MAAM,CAAC,EAAE;AAAA,cACzC;AAAA,YACF;AAAA,UACF,OAAO;AACL,mBAAO,QAAQ,EAAE,GAAG,IAAI,aAAa,MAA4B,WAAW;AAAA,UAC9E;AAGA,cACE,SAAS,OAAO,QAAQ,EAAE,GAAG,CAAC,KAC9B,cAAe,OAAO,QAAQ,EAAE,GAAG,KACnC,OAAQ,OAAO,QAAQ,EAAE,GAAG,EAAmB,aAAa,WAC5D;AACA,mBAAQ,OAAO,QAAQ,EAAE,GAAG,EAAmB;AAAA,UACjD;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF,CAAC;AAED,QAAI,mBAAmB,QAAQ;AAC7B,UAAI,aAAa,OAAO,iBAAiB,OAAO,OAAO,cAAc,YAAY,UAAU;AAGzF,cAAM,UAAU,OAAO,cAAc;AACrC,eAAO,KAAK,OAAO,EAAE,QAAQ,OAAK;AAChC,oBAAU,QAAQ,CAAC,GAAG,eAAe;AAAA,QACvC,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AAGA,MAAI,EAAE,UAAU,WAAW,CAAC,oBAAoB,MAAM,KAAK,CAAC,oBAAoB,MAAM,GAAG;AACvF,QAAI,gBAAgB,QAAQ;AAC1B,aAAO,OAAO;AAAA,IAChB,WAAW,WAAW,QAAQ;AAC5B,aAAO,OAAO;AAAA,IAChB,OAAO;AAAA,IAMP;AAAA,EACF;AAEA,MAAI,UAAU,QAAQ;AAGpB,QAAI,cAAc,QAAQ;AACxB,UAAI,OAAO,UAAU;AACnB,YAAI,MAAM,QAAQ,OAAO,IAAI,GAAG;AAC9B,iBAAO,KAAK,KAAK,MAAM;AAAA,QACzB,WAAW,OAAO,SAAS,QAAQ,OAAO,SAAS,QAAQ;AACzD,iBAAO,OAAO,CAAC,OAAO,MAAM,MAAM;AAAA,QACpC;AAAA,MACF;AAEA,aAAO,OAAO;AAAA,IAChB;AAEA,QAAI,OAAO,SAAS,MAAM;AAIxB,aAAO,OAAO;AAAA,IAChB,WAAW,MAAM,QAAQ,OAAO,IAAI,GAAG;AACrC,UAAI,OAAO,KAAK,SAAS,IAAI,GAAG;AAC9B,eAAO,KAAK,OAAO,KAAK,QAAQ,IAAI,CAAC,IAAI;AAAA,MAC3C;AAEA,aAAO,OAAO,MAAM,KAAK,IAAI,IAAI,OAAO,IAAI,CAAC;AAG7C,UAAI,OAAO,KAAK,WAAW,GAAG;AAC5B,eAAO,OAAO,OAAO,KAAK,MAAM;AAAA,MAClC,WAAW,OAAO,KAAK,SAAS,OAAO,KAAK,OAAO,KAAK,SAAS,SAAS,KAAK,OAAO,KAAK,SAAS,QAAQ,GAAG;AAG7G,cAAM,aAAa,OAAO,KAAK,SAAS,MAAM;AAE9C,YAAI,OAAO,KAAK,WAAW,KAAK,YAAY;AAAA,QAE5C,OAAO;AAGL,gBAAM,gBAAuB,CAAC;AAK9B,iBAAO,QAAQ;AAAA;AAAA,YAEb,OAAO;AAAA,cACL;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,YACF;AAAA;AAAA,YAGA,SAAS;AAAA;AAAA,YAET;AAAA;AAAA,YAGA,QAAQ;AAAA,cACN;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,YACF;AAAA,UACF,CAAC,EAAE,QAAQ,CAAC,CAAC,SAAS,QAAQ,MAAM;AAClC,gBAAI,CAAC,OAAO,KAAK,SAAS,OAA8B,GAAG;AACzD;AAAA,YACF;AAEA,kBAAM,gBAAqB,uBAAuB;AAAA,cAChD,MAAM,aAAa,CAAC,SAAS,MAAM,IAAI;AAAA,cAEvC,iBAAkB,OAAe,mBAAmB;AAAA,cACpD,YAAY,OAAO,cAAc;AAAA,cACjC,aAAa,OAAO,eAAe;AAAA,cACnC,UAAU,OAAO,YAAY;AAAA,cAC7B,OAAO,OAAO,SAAS;AAAA,cACvB,WAAW,OAAO,aAAa;AAAA,YACjC,CAAC;AAED,qBAAS,QAAQ,CAAC,MAA0B;AAC1C,kBAAI,KAAK,QAAQ;AACf,8BAAc,CAAC,IAAI,OAAO,CAAC;AAC3B,uBAAO,OAAO,CAAC;AAAA,cACjB;AAAA,YACF,CAAC;AAED,0BAAc,KAAK,aAAa;AAAA,UAClC,CAAC;AAED,iBAAO,OAAO,OAAO,KAAK,OAAO,OAAK,MAAM,WAAW,MAAM,aAAa,MAAM,QAAQ;AACxF,cAAI,OAAO,KAAK,WAAW,GAAG;AAC5B,mBAAO,OAAO,OAAO,KAAK,MAAM;AAAA,UAClC;AAKA,cAAI,OAAO,KAAK,SAAS,GAAG;AAC1B,qBAAS,EAAE,OAAO,CAAC,QAAQ,GAAG,aAAa,EAAE;AAAA,UAC/C,OAAO;AACL,qBAAS,EAAE,OAAO,cAAc;AAAA,UAClC;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,MAAU,SAAS,QAAQ,uBAAuB,GAAG;AACnD,QAAI,aAAa,UAAU,SAAS,OAAO,OAAO,GAAG;AACnD,yBAAmB,KAAK,EAAE,SAAS,OAAO,QAAQ,CAAC;AAAA,IACrD;AAGA,QAAI,aAAa,QAAQ;AAEvB,UAAI,YAAY,OAAO,OAAO,GAAG;AAC/B,eAAO,WAAW,CAAC,OAAO,OAAO;AAAA,MACnC,WAAW,MAAM,QAAQ,OAAO,OAAO,GAAG;AACxC,eAAO,WAAW,OAAO,QAAQ,OAAO,aAAW,YAAY,OAAO,CAAC;AACvE,YAAI,CAAC,OAAO,SAAS,QAAQ;AAC3B,iBAAO,OAAO;AAAA,QAChB;AAAA,MACF,OAAO;AACL,2BAAmB,KAAK,EAAE,SAAS,OAAO,QAAQ,CAAC;AAAA,MACrD;AAEA,aAAO,OAAO;AAAA,IAChB,WAAW,cAAc,QAAQ;AAC/B,UAAI,mBAAmB;AACvB,UAAI,OAAO,OAAO,aAAa,YAAY,CAAC,MAAM,QAAQ,OAAO,QAAQ,GAAG;AAC1E,cAAM,WAAsB,CAAC;AAC7B,eAAO,KAAK,OAAO,QAAQ,EAAE,QAAQ,UAAQ;AAC3C,gBAAM,UAAU,OAAO,SAAS,IAAyB;AACzD,cAAI,UAAU,SAAS;AAGrB,sBAAU,QAAQ,MAAM,KAAK;AAAA,UAC/B,WAAW,WAAW,SAAS;AAC7B,gBAAI,YAAY,QAAQ,KAAK,GAAG;AAC9B,uBAAS,KAAK,QAAQ,KAAK;AAC3B,iCAAmB;AAAA,YACrB,WAAW,MAAM,QAAQ,QAAQ,KAAK,KAAK,YAAY,QAAQ,MAAM,CAAC,CAAC,GAAG;AACxE,uBAAS,KAAK,QAAQ,MAAM,CAAC,CAAC;AAC9B,iCAAmB;AAAA,YACrB,OAAO;AAIL,iCAAmB,KAAK;AAAA,gBACtB,SAAS,QAAQ;AAAA,cACnB,CAAC;AAAA,YACH;AAAA,UACF;AAAA,QACF,CAAC;AAED,YAAI,SAAS,QAAQ;AACnB,6BAAmB;AACnB,iBAAO,WAAW;AAAA,QACpB;AAAA,MACF,WAAW,MAAM,QAAQ,OAAO,QAAQ,KAAK,YAAY,OAAO,SAAS,CAAC,CAAC,GAAG;AAG5E,2BAAmB;AAAA,MACrB;AAEA,UAAI,CAAC,kBAAkB;AACrB,eAAO,OAAO;AAAA,MAChB;AAAA,IACF;AAKA,QAAI,CAAC,cAAc,QAAQ,OAAO,KAAK,CAAC,cAAc,QAAQ,QAAQ,KAAK,CAAC,OAAO,UAAU;AAC3F,YAAM,eAAe,+BAA+B,WAAW,iBAAiB,kBAAkB;AAClG,UAAI,cAAc;AAGhB,YAAI,YAAY,YAAY,KAAM,MAAM,QAAQ,YAAY,KAAK,YAAY,aAAa,CAAC,CAAC,GAAI;AAC9F,iBAAO,WAAW,CAAC,YAAY;AAAA,QACjC;AAAA,MACF;AAAA,IACF;AAEA,QAAI,cAAc,QAAQ,OAAO,GAAG;AAClC,UAAI,WAAW,QAAQ;AACrB,YAAI,CAAC,MAAM,QAAQ,OAAO,KAAK,KAAK,OAAO,KAAK,OAAO,KAAK,EAAE,WAAW,KAAW,MAAM,OAAO,KAAK,GAAG;AAGvG,oBAAU,OAAO,MAAM,MAAM,KAAK;AAAA,QACpC,WAAW,OAAO,UAAU,MAAM;AAEhC,iBAAO,QAAQ,aAAa,OAAO,OAA6B;AAAA,YAC9D;AAAA,YACA,iBAAiB,GAAG,eAAe;AAAA,YACnC;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACF,CAAC;AAKD,cAAI,SAAS,OAAO,KAAK,KAAK,cAAc,OAAO,SAAS,CAAC,MAAM,QAAQ,OAAO,MAAM,QAAQ,GAAG;AACjG,mBAAO,OAAO,MAAM;AAAA,UACtB;AAAA,QACF;AAAA,MACF,WAAW,gBAAgB,UAAU,0BAA0B,QAAQ;AAKrE,eAAO,OAAO;AAAA,MAChB,OAAO;AAGL,QAAC,OAAe,QAAQ,CAAC;AAAA,MAC3B;AAAA,IACF,WAAW,cAAc,QAAQ,QAAQ,GAAG;AAC1C,UAAI,gBAAgB,QAAQ;AAC1B,eAAO,KAAK,OAAO,UAAU,EAAE,QAAQ,UAAQ;AAC7C,cACE,MAAM,QAAQ,OAAO,WAAW,IAAI,CAAC,KACpC,OAAO,OAAO,WAAW,IAAI,MAAM,YAAY,OAAO,WAAW,IAAI,MAAM,MAC5E;AACA,kBAAM,gBAAgB,aAAa,OAAO,WAAW,IAAI,GAAyB;AAAA,cAChF;AAAA,cACA,iBAAiB,GAAG,eAAe,IAAI,cAAc,IAAI,CAAC;AAAA,cAC1D;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,YACF,CAAC;AAGD,gBAAI,sBAAsB;AAC1B,iBAAK,0BAA0B,4BAA4B,CAAC,OAAO,KAAK,aAAa,EAAE,QAAQ;AAI7F,kBAAI,OAAO,KAAK,OAAO,WAAW,IAAI,CAAC,EAAE,SAAS,GAAG;AACnD,uBAAO,OAAO,WAAW,IAAI;AAC7B,sCAAsB;AAAA,cACxB;AAAA,YACF;AAEA,gBAAI,qBAAqB;AACvB,qBAAO,WAAW,IAAI,IAAI;AAW1B,kBACE,SAAS,aAAa,KACtB,cAAc,iBACd,OAAO,cAAc,aAAa,aAClC,cAAc,aAAa,MAC3B;AACA,oBAAI,cAAc,UAAU,MAAM,QAAQ,OAAO,QAAQ,GAAG;AAC1D,yBAAO,SAAS,KAAK,IAAI;AAAA,gBAC3B,OAAO;AACL,yBAAO,WAAW,CAAC,IAAI;AAAA,gBACzB;AAEA,uBAAQ,OAAO,WAAW,IAAI,EAAmB;AAAA,cACnD;AAAA,YACF;AAAA,UACF;AAAA,QACF,CAAC;AAID,YAAI,0BAA0B,yBAAyB;AACrD,cAAI,CAAC,OAAO,KAAK,OAAO,UAAU,EAAE,QAAQ;AAC1C,mBAAO,YAAY,CAAC,CAAC;AAAA,UACvB;AAAA,QACF;AAAA,MACF;AAEA,UAAI,OAAO,+BAA+B,YAAY,+BAA+B,MAAM;AAGzF,YACE,EAAE,UAAU,+BACZ,EAAE,UAAU;AAAA,QAEZ,CAAC,oBAAoB,0BAAgD,GACrE;AACA,iBAAO,uBAAuB;AAAA,QAChC,OAAO;AAEL,iBAAO,uBAAuB,aAAa,4BAAkD;AAAA,YAC3F;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACF,CAAC;AAAA,QACH;AAAA,MACF;AAMA,UAAI,CAAC,oBAAoB,MAAM,KAAK,EAAE,gBAAgB,WAAW,EAAE,0BAA0B,SAAS;AACpG,eAAO,uBAAuB;AAAA,MAChC;AAAA,IACF;AAAA,EACF;AAQA,MACQ,SAAS,QAAQ,uBAAuB,KAC9C,kBACA,OAAO,KAAK,cAAc,EAAE,SAAS,KACrC,iBACA;AACA,QAAI;AACF,YAAM,iBAAiB,YAAY,IAAI,gBAAgB,eAAe;AACtE,UAAI,gBAAgB;AAClB,eAAO,UAAU;AAAA,MACnB;AAAA,IAEF,SAAS,KAAK;AAAA,IAEd;AAAA,EACF;AAGA,MAAI,aAAa,UAAU,OAAO,OAAO,YAAY,aAAa;AAChE,QAAI,cAAc,QAAQ,QAAQ,GAAG;AAGnC,aAAO,OAAO;AAAA,IAChB,WACG,qBAAqB,UAAU,OAAO,mBAAmB,OAAO,YAAY,MAC7E,OAAO,YAAY,IACnB;AAAA,IAGF,OAAO;AAGL,aAAO,OAAO;AAAA,IAChB;AAAA,EACF,WAAW,mBAAmB,QAAQ;AACpC,UAAM,eAAe,+BAA+B,WAAW,iBAAiB,kBAAkB;AAMlG,QACE,YAAY,YAAY,KACxB,iBAAiB,QAChB,MAAM,QAAQ,YAAY,KAAK,cAAc,QAAQ,OAAO,GAC7D;AACA,aAAO,UAAU;AAAA,IACnB;AAAA,EACF;AAEA,MAAU,SAAS,QAAQ,uBAAuB,KAAK,UAAU,UAAU,MAAM,QAAQ,OAAO,IAAI,GAAG;AAIrG,WAAO,OAAO,MAAM,KAAK,IAAI,IAAI,OAAO,IAAI,CAAC;AAM7C,QAAI,wBAAwB;AAC1B,YAAM,QAAQ,OAAO,KAClB,OAAO,OAAO,EACd,IAAI,SAAO,KAAK,GAAG,IAAI,EACvB,KAAK,GAAG;AAEX,UAAI,MAAM,QAAQ;AAChB,YAAI,iBAAiB,QAAQ;AAC3B,iBAAO,eAAe;AAAA;AAAA,EAAO,KAAK;AAAA,QACpC,OAAO;AACL,iBAAO,cAAc;AAAA,QACvB;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAIA,MAAI,WAAW,UAAU,WAAW,QAAQ;AAC1C,QAAI,gBAAgB,QAAQ;AAC1B,aAAO,OAAO;AAAA,IAChB;AAEA,QAAI,WAAW,QAAQ;AACrB,aAAO,OAAO;AAAA,IAChB;AAAA,EACF;AAGA,WAAS,IAAI,GAAG,IAAI,yBAAyB,QAAQ,KAAK,GAAG;AAG3D,WAAQ,OAAmC,yBAAyB,CAAC,CAAC;AAAA,EACxE;AAIA,MAAI,0BAA0B,cAAc,UAAU,OAAO,aAAa,MAAM;AAC9E,WAAO,CAAC;AAAA,EACV,WAAW,2BAA2B,eAAe,UAAU,OAAO,cAAc,MAAM;AACxF,WAAO,CAAC;AAAA,EACV;AAEA,SAAO,YAAY,MAAM;AAC3B;;;ACp1BO,IAAM,QAA2C;AAAA,EACtD,MAAM;AAAA,EACN,OAAO;AAAA,EACP,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,UAAU;AAAA,EACV,QAAQ;AAAA,EACR,UAAU;AAAA;AACZ;AA4CO,SAAS,0BACd,WACA,KACA,MACiB;AACjB,MAAI,kBAAkB;AACtB,MAAI,8BAA8B;AAElC,WAAS,UAAU,KAAa,MAA+B;AAC7D,QAAI,SAAS,OAAO;AAClB,wBAAkB;AAAA,IACpB,OAAO;AACL,oCAA8B;AAAA,IAChC;AAAA,EACF;AAEA,WAAS,cAAc,QAAsB,MAAc;AAGzD,QAAI,KAAK,4BAA4B;AACnC,aAAO;AAAA,IACT;AAGA,QAAI,CAAC,UAAU,CAAC,OAAO,WAAY,QAAO;AAG1C,UAAM,iBAAiB,YAAY,MAAM;AAIzC,UAAM,iBAAkB,OAAO,YAAY,CAAC;AAI5C,UAAM,qBAAmD,CAAC;AAE1D,WAAO,KAAK,eAAe,UAAU,EAAE,QAAQ,SAAO;AACpD,YAAM,iBAAiB,eAAe,WAAW,GAAG;AACpD,UAAI,eAAe,cAAc,CAAC,eAAe,SAAS,GAAG,KAAK,CAAC,eAAe,UAAU;AAC1F,2BAAmB,GAAG,IAAI;AAAA,MAC5B;AAAA,IACF,CAAC;AAGD,IAAC,eAAe,aAA8C;AAC9D,UAAM,mBAAmB,aAAa,gBAAgB;AAAA,MACpD,gBAAgB,KAAK;AAAA,MACrB,wBAAwB,KAAK;AAAA,MAC7B,yBAAyB,KAAK;AAAA,MAC9B,oBAAoB,CAAC;AAAA,MACrB;AAAA,MACA,aAAa,KAAK;AAAA,IACpB,CAAC;AAGD,QAAI,OAAO,KAAK,gBAAgB,EAAE,WAAW,KAAK,OAAO,KAAK,iBAAiB,UAAU,EAAE,WAAW,GAAG;AACvG,aAAO;AAAA,IACT;AAIA,WAAO,KAAK,OAAO,UAAU,EAAE,QAAQ,SAAO;AAE5C,UAAK,OAAO,WAAW,GAAG,EAAmB,cAAc,CAAC,eAAe,SAAS,GAAG,GAAG;AACxF,eAAO,OAAO,WAAW,GAAG;AAAA,MAC9B;AAAA,IACF,CAAC;AAED,WAAO;AAAA,MACL;AAAA,MACA,QAAQ,YAAY,gBAAgB,IAChC,mBACA;AAAA,QACE,GAAG;AAAA,QACH,SAAS,uBAAuB,kBAAkB,GAAG;AAAA,MACvD;AAAA,IACN;AAAA,EACF;AAKA,WAAS,uBAAsC;AAC7C,UAAM,cAAc,UAAU,eAAe;AAC7C,QAAI,CAAC,eAAe,CAAC,MAAM,QAAQ,WAAW,EAAG,QAAO;AAExD,UAAM,CAAC,WAAW,iBAAiB,WAAW,IAAI;AAClD,UAAM,OAAO,cAAc,sCAAsC,aAAa;AAG9E,QAAI,CAAC,gBAAgB,UAAU,CAAC,OAAO,KAAK,gBAAgB,MAAM,EAAE,QAAQ;AAC1E,aAAO;AAAA,IACT;AAEA,UAAM,qBAAgE,CAAC;AACvE,QAAI,aAAa,iBAAiB;AAChC,yBAAmB,KAAK,EAAE,SAAS,gBAAgB,QAAQ,CAAC;AAAA,IAC9D,WAAW,cAAc,iBAAiB;AACxC,yBAAmB,KAAK;AAAA,QACtB,UAAU,OAAO,OAAO,gBAAgB,QAAQ,EAC7C,IAAI,CAAC,YAA2B,QAAQ,KAAK,EAC7C,OAAO,SAAO,QAAQ,MAAS;AAAA,MACpC,CAAC;AAAA,IACH;AAIA,UAAM,gBAAgB,YAAY,gBAAgB,MAAM;AAExD,UAAM,gBAAgB,aAAa,eAAe;AAAA,MAChD,gBAAgB,KAAK;AAAA,MACrB,wBAAwB,KAAK;AAAA,MAC7B,yBAAyB,KAAK;AAAA,MAC9B;AAAA,MACA;AAAA,MACA,aAAa,KAAK;AAAA,IACpB,CAAC;AAGD,QAAI,CAAC,OAAO,KAAK,aAAa,EAAE,QAAQ;AACtC,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,MACL;AAAA,MACA,OAAO,MAAM,IAAI;AAAA,MACjB,QAAQ,YAAY,aAAa,IAC7B,gBACA;AAAA,QACE,GAAG;AAAA,QACH,SAAS,uBAAuB,eAAe,GAAG;AAAA,MACpD;AAAA,MACJ,iBAAiB,cAAc,eAAe,IAAI;AAAA,MAClD,GAAI,cAAc,EAAE,YAAY,IAAI,CAAC;AAAA,IACvC;AAAA,EACF;AAEA,WAAS,sBAAwC;AAC/C,QAAI,EAAE,gBAAgB,MAAM;AAC1B,aAAO;AAAA,IACT;AAEA,UAAMC,cAAwC;AAAA,MAC5C,GAAG,OAAO,KAAK,IAAI,UAAU,EAC1B,IAAI,oBAAkB,EAAE,CAAC,aAAa,GAAG,CAAC,EAAE,EAAE,EAC9C,OAAO,CAAC,MAAM,SAAS,OAAO,OAAO,MAAM,IAAI,GAAG,CAAC,CAAC;AAAA,IACzD;AAEA,WAAO,KAAK,IAAI,UAAU,EAAE,QAAQ,CAAC,kBAA0C;AAC7E,UAAI,OAAO,IAAI,WAAW,aAAa,MAAM,YAAY,CAAC,MAAM,QAAQ,IAAI,WAAW,aAAa,CAAC,GAAG;AACtG,eAAO,KAAK,IAAI,WAAW,aAAa,CAAC,EAAE,QAAQ,gBAAc;AAC/D,gBAAM,kBAAkB,YAAY,IAAI,WAAW,aAAa,EAAE,UAAU,CAAC;AAC7E,UAAAA,YAAW,aAAa,EAAE,UAAU,IAAI,aAAa,iBAAiC;AAAA,YACpF,gBAAgB,KAAK;AAAA,YACrB,wBAAwB,KAAK;AAAA,YAC7B,yBAAyB,KAAK;AAAA,YAC9B;AAAA,YACA,aAAa,KAAK;AAAA,UACpB,CAAC;AAAA,QACH,CAAC;AAAA,MACH;AAAA,IACF,CAAC;AAGD,WAAO,KAAKA,WAAU,EAAE,QAAQ,CAAC,kBAA0C;AACzE,UAAI,CAAC,OAAO,KAAKA,YAAW,aAAa,CAAC,EAAE,QAAQ;AAClD,eAAOA,YAAW,aAAa;AAAA,MACjC;AAAA,IACF,CAAC;AAED,WAAOA;AAAA,EACT;AAEA,WAAS,sBAAuC;AAC9C,UAAM,kBAAkB,UAAU,cAAc;AAEhD,UAAM,cAAc,OAAO,KAAK,KAAK,EAClC,IAAI,UAAQ;AACX,YAAM,WAAqB,CAAC;AAI5B,YAAM,aAAa,gBAAgB,OAAO,WAAU,MAA0B,OAAO,IAAI;AACzF,UAAI,WAAW,WAAW,GAAG;AAC3B,eAAO;AAAA,MACT;AAEA,YAAM,aAAa,WAAW,OAAO,CAAC,MAAoC,YAA6B;AACrG,YAAIC,UAAuB,CAAC;AAC5B,YAAI,YAAY,SAAS;AACvB,gBAAM,gBAA8B,QAAQ,SAAS,YAAY,QAAQ,MAAM,IAAI,CAAC;AAEpF,cAAI,QAAQ,SAAS;AAGnB,0BAAc,UAAU,QAAQ;AAAA,UAClC,WAAW,QAAQ,UAAU;AAG3B,0BAAc,WAAW,QAAQ;AAAA,UACnC;AAEA,cAAI,QAAQ,WAAY,eAAc,aAAa,QAAQ;AAE3D,gBAAM,gBAAgB,aAAa,eAAe;AAAA,YAChD,iBAAiB,IAAI,QAAQ,IAAI;AAAA,YACjC,gBAAgB,KAAK;AAAA,YACrB,wBAAwB,KAAK;AAAA,YAC7B,yBAAyB,KAAK;AAAA,YAC9B;AAAA,YACA,aAAa,KAAK;AAAA,UACpB,CAAC;AAED,UAAAA,UAAS,YAAY,aAAa,IAC9B,gBACA;AAAA,YACE,GAAG;AAAA;AAAA;AAAA;AAAA,YAKH,SAAS,uBAAuB,eAAe,GAAG;AAAA,UACpD;AAAA,QACN,WAAW,aAAa,WAAW,OAAO,QAAQ,YAAY,UAAU;AACtE,gBAAM,cAAc,OAAO,KAAK,QAAQ,OAAO;AAC/C,cAAI,YAAY,QAAQ;AACtB,gBAAI;AACJ,gBAAI,YAAY,WAAW,GAAG;AAC5B,4BAAc,YAAY,CAAC;AAAA,YAC7B,OAAO;AAGL,oBAAM,uBAAuB,YAAY,OAAO,OAAK,yBAAgB,KAAK,CAAC,CAAC;AAC5E,kBAAI,qBAAqB,QAAQ;AAC/B,8BAAc,qBAAqB,CAAC;AAAA,cACtC,OAAO;AACL,8BAAc,YAAY,CAAC;AAAA,cAC7B;AAAA,YACF;AAEA,gBAAI,OAAO,QAAQ,QAAQ,WAAW,MAAM,YAAY,YAAY,QAAQ,QAAQ,WAAW,GAAG;AAChG,oBAAM,gBAA8B,QAAQ,QAAQ,WAAW,EAAE,SAC7D,YAAY,QAAQ,QAAQ,WAAW,EAAE,MAAM,IAC/C,CAAC;AAEL,kBAAI,QAAQ,SAAS;AAGnB,8BAAc,UAAU,QAAQ;AAAA,cAClC,WAAW,QAAQ,UAAU;AAI3B,8BAAc,WAAW,QAAQ;AAAA,cACnC;AAEA,kBAAI,QAAQ,WAAY,eAAc,aAAa,QAAQ;AAE3D,oBAAM,gBAAgB,aAAa,eAAe;AAAA,gBAChD,iBAAiB,IAAI,QAAQ,IAAI;AAAA,gBACjC,gBAAgB,KAAK;AAAA,gBACrB,wBAAwB,KAAK;AAAA,gBAC7B,yBAAyB,KAAK;AAAA,gBAC9B;AAAA,gBACA,aAAa,KAAK;AAAA,cACpB,CAAC;AAED,cAAAA,UAAS,YAAY,aAAa,IAC9B,gBACA;AAAA,gBACE,GAAG;AAAA;AAAA;AAAA;AAAA,gBAKH,SAAS,uBAAuB,eAAe,GAAG;AAAA,cACpD;AAAA,YACN;AAAA,UACF;AAAA,QACF;AAIA,YAAI,QAAQ,aAAa;AACvB,cAAI,CAAC,YAAYA,OAAM,GAAG;AACxB,YAAAA,QAAO,cAAc,QAAQ;AAAA,UAC/B;AAAA,QACF;AAEA,aAAK,QAAQ,IAAI,IAAIA;AAErB,YAAI,QAAQ,UAAU;AACpB,mBAAS,KAAK,QAAQ,IAAI;AAAA,QAC5B;AAEA,eAAO;AAAA,MACT,GAAG,CAAC,CAAC;AAGL,YAAM,SAAmC;AAAA,QACvC,MAAM;AAAA,QACN;AAAA,QACA;AAAA,MACF;AAEA,aAAO;AAAA,QACL;AAAA,QACA,OAAO,MAAM,IAAI;AAAA,QACjB;AAAA,QACA,iBAAiB,cAAc,QAAQ,IAAI;AAAA,MAC7C;AAAA,IACF,CAAC,EACA,OAAO,OAAO;AAEjB,QAAI,CAAC,KAAK,0BAA0B;AAClC,aAAO;AAAA,IACT,WAAW,CAAC,YAAY,QAAQ;AAC9B,aAAO,CAAC;AAAA,IACV;AAKA,UAAM,kBAAkB,YAAY,IAAI,OAAK,EAAE,iBAAiB,UAAU,IAAI,EAAE,OAAO,OAAO;AAC9F,WAAO;AAAA,MACL;AAAA,QACE,MAAM;AAAA,QACN,OAAO,MAAM;AAAA,QACb,QAAQ;AAAA,UACN,OAAO,YAAY,IAAI,OAAK,EAAE,MAAM;AAAA,QACtC;AAAA,QACA,iBAAiB,gBAAgB,SAC7B;AAAA,UACE,MAAM;AAAA,UACN,QAAQ;AAAA,YACN,OAAO;AAAA,UACT;AAAA,QACF,IACA;AAAA,MACN;AAAA,IACF;AAAA,EACF;AAIA,MAAI,CAAC,UAAU,cAAc,KAAK,CAAC,UAAU,eAAe,GAAG;AAC7D,WAAO;AAAA,EACT;AAKA,QAAM,WAAY,aAAa,oBAAoB,KAAK,SAAS,EAAe,IAAI,OAAK,EAAE,YAAY,CAAC;AACxG,WAAS,SAAS,QAAQ,MAAM,CAAC,IAAI;AACrC,WAAS,KAAK,UAAU;AAExB,QAAM,aAAa,CAAC,qBAAqB,CAAC,EAAE,OAAO,GAAG,oBAAoB,CAAC,EAAE,OAAO,OAAO;AAK3F,QAAM,0BACJ,mBAAoB,+BAA+B,KAAK;AAE1D,QAAM,aAAa,0BAA0B,oBAAoB,IAAI;AAErE,SAAO,WACJ,IAAI,WAAS;AAQZ,QAAI,cAAc,yBAAyB;AAEzC,MAAC,MAAM,OAAO,aAAkC;AAAA,IAClD;AAGA,QAAI,CAAC,MAAM,gBAAiB,QAAO,MAAM;AAEzC,WAAO;AAAA,EACT,CAAC,EACA,KAAK,CAAC,GAAG,MAAM;AACd,WAAO,SAAS,QAAQ,EAAE,IAAI,IAAI,SAAS,QAAQ,EAAE,IAAI;AAAA,EAC3D,CAAC;AACL;","names":["types","components","schema"]}