{"version":3,"sources":["/Users/erunion/code/readme/oas/packages/oas/dist/chunk-4F67E254.cjs","../src/operation/lib/dedupe-common-parameters.ts","../src/samples/index.ts","../src/samples/utils.ts","../src/operation/lib/get-mediatype-examples.ts","../src/operation/lib/get-response-examples.ts","../src/operation/lib/get-callback-examples.ts","../src/operation/lib/get-example-groups.ts","../src/operation/lib/get-requestbody-examples.ts","../src/operation/lib/get-response-as-json-schema.ts","../src/operation/index.ts"],"names":[],"mappings":"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","file":"/Users/erunion/code/readme/oas/packages/oas/dist/chunk-4F67E254.cjs","sourcesContent":[null,"import * as RMOAS from '../../types.js';\n\n/**\n * With an array of common parameters filter down them to what isn't already present in a list of\n * non-common parameters.\n *\n * @param parameters Array of parameters defined at the operation level.\n * @param commonParameters Array of **common** parameters defined at the path item level.\n */\nexport function dedupeCommonParameters(\n  parameters: RMOAS.ParameterObject[],\n  commonParameters: RMOAS.ParameterObject[],\n): RMOAS.ParameterObject[] {\n  return commonParameters.filter((param: RMOAS.ParameterObject) => {\n    return !parameters.find((param2: RMOAS.ParameterObject) => {\n      if (param.name && param2.name) {\n        return param.name === param2.name && param.in === param2.in;\n      } else if (RMOAS.isRef(param) && RMOAS.isRef(param2)) {\n        return param.$ref === param2.$ref;\n      }\n\n      return false;\n    });\n  });\n}\n","/**\n * This file has been extracted and modified from Swagger UI.\n *\n * @license Apache-2.0\n * @see {@link https://github.com/swagger-api/swagger-ui/blob/master/src/core/plugins/samples/fn.js}\n */\nimport type * as RMOAS from '../types.js';\n\nimport mergeJSONSchemaAllOf from 'json-schema-merge-allof';\nimport memoize from 'memoizee';\n\nimport { objectify, usesPolymorphism, isFunc, normalizeArray, deeplyStripKey } from './utils.js';\n\nconst sampleDefaults = (genericSample: boolean | number | string) => {\n  return (schema: RMOAS.SchemaObject): typeof genericSample =>\n    typeof schema.default === typeof genericSample ? schema.default : genericSample;\n};\n\nconst primitives: Record<string, (arg: RMOAS.SchemaObject | void) => boolean | number | string> = {\n  string: sampleDefaults('string'),\n  string_email: sampleDefaults('user@example.com'),\n  'string_date-time': sampleDefaults(new Date().toISOString()),\n  string_date: sampleDefaults(new Date().toISOString().substring(0, 10)),\n  'string_YYYY-MM-DD': sampleDefaults(new Date().toISOString().substring(0, 10)),\n  string_uuid: sampleDefaults('3fa85f64-5717-4562-b3fc-2c963f66afa6'),\n  string_hostname: sampleDefaults('example.com'),\n  string_ipv4: sampleDefaults('198.51.100.42'),\n  string_ipv6: sampleDefaults('2001:0db8:5b96:0000:0000:426f:8e17:642a'),\n  number: sampleDefaults(0),\n  number_float: sampleDefaults(0.0),\n  integer: sampleDefaults(0),\n  boolean: sampleDefaults(true),\n};\n\nconst primitive = (schema: RMOAS.SchemaObject) => {\n  schema = objectify(schema);\n  const { format } = schema;\n  let { type } = schema;\n\n  if (type === 'null') {\n    return null;\n  } else if (Array.isArray(type)) {\n    if (type.length === 1) {\n      type = type[0];\n    } else {\n      // If one of our types is `null` then we should generate a sample for the non-null value.\n      if (type.includes('null')) {\n        type = type.filter(t => t !== 'null');\n      }\n\n      type = type.shift();\n    }\n  }\n\n  // @todo add support for if `type` is an array\n  const fn = primitives[`${type}_${format}`] || primitives[type as string];\n  if (isFunc(fn)) {\n    return fn(schema);\n  }\n\n  return `Unknown Type: ${schema.type}`;\n};\n\n/**\n * Generate a piece of sample data from a JSON Schema object. If `example` declarations are present\n * they will be utilized, but generally this will generate fake data for the information present in\n * the schema.\n *\n * @param schema JSON Schema to generate a sample for.\n */\nfunction sampleFromSchema(\n  schema: RMOAS.SchemaObject,\n  opts: {\n    /**\n     * If you wish to include data that's flagged as `readOnly`.\n     */\n    includeReadOnly?: boolean;\n\n    /**\n     * If you wish to include data that's flatted as `writeOnly`.\n     */\n    includeWriteOnly?: boolean;\n  } = {},\n): Record<string, unknown> | unknown[] | boolean | number | string | null | undefined {\n  const objectifySchema = objectify(schema);\n  let { type } = objectifySchema;\n\n  const hasPolymorphism = usesPolymorphism(objectifySchema);\n  if (hasPolymorphism === 'allOf') {\n    try {\n      return sampleFromSchema(\n        mergeJSONSchemaAllOf(objectifySchema, {\n          resolvers: {\n            // Ignore any unrecognized OAS-specific keywords that might be present on the schema\n            // (like `xml`).\n            defaultResolver: mergeJSONSchemaAllOf.options.resolvers.title,\n          },\n        }),\n        opts,\n      );\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    } catch (error) {\n      return undefined;\n    }\n  } else if (hasPolymorphism) {\n    const samples = (objectifySchema[hasPolymorphism] as RMOAS.SchemaObject[]).map(s => {\n      return sampleFromSchema(s, opts);\n    });\n\n    if (samples.length === 1) {\n      return samples[0];\n    } else if (samples.some(s => s === null)) {\n      // If one of our samples is null then we should try to surface the first non-null one.\n      return samples.find(s => s !== null);\n    }\n\n    // If we still don't have a sample then we should just return whatever the first sample we've\n    // got is. The sample might not be a _full_ example but it should be enough to act as a sample.\n    return samples[0];\n  }\n\n  const { example, additionalProperties, properties, items } = objectifySchema;\n  const { includeReadOnly, includeWriteOnly } = opts;\n\n  if (example !== undefined) {\n    return deeplyStripKey(example, '$$ref', (val: string) => {\n      // do a couple of quick sanity tests to ensure the value\n      // looks like a $$ref that swagger-client generates.\n      return typeof val === 'string' && val.indexOf('#') > -1;\n    });\n  }\n\n  if (!type) {\n    if (properties || additionalProperties) {\n      type = 'object';\n    } else if (items) {\n      type = 'array';\n    } else {\n      return undefined;\n    }\n  }\n\n  if (type === 'object' || (Array.isArray(type) && type.includes('object'))) {\n    const props = objectify(properties);\n    const obj: Record<string, any> = {};\n    // eslint-disable-next-line no-restricted-syntax\n    for (const name in props) {\n      if (props[name] && props[name].deprecated) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (props[name] && props[name].readOnly && !includeReadOnly) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (props[name] && props[name].writeOnly && !includeWriteOnly) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (props[name].examples?.length) {\n        obj[name] = props[name].examples[0];\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      obj[name] = sampleFromSchema(props[name], opts);\n    }\n\n    if (additionalProperties === true) {\n      obj.additionalProp = {};\n    } else if (additionalProperties) {\n      const additionalProps = objectify(additionalProperties);\n      const additionalPropVal = sampleFromSchema(additionalProps, opts);\n\n      obj.additionalProp = additionalPropVal;\n    }\n\n    return obj;\n  }\n\n  if (type === 'array' || (Array.isArray(type) && type.includes('array'))) {\n    // `items` should always be present on arrays, but if it isn't we should at least do our best\n    // to support its absence.\n    if (typeof items === 'undefined') {\n      return [];\n    }\n\n    if (Array.isArray(items.anyOf)) {\n      return items.anyOf.map((i: RMOAS.SchemaObject) => sampleFromSchema(i, opts));\n    }\n\n    if (Array.isArray(items.oneOf)) {\n      return items.oneOf.map((i: RMOAS.SchemaObject) => sampleFromSchema(i, opts));\n    }\n\n    return [sampleFromSchema(items, opts)];\n  }\n\n  if (schema.enum) {\n    if (schema.default) {\n      return schema.default;\n    }\n\n    return normalizeArray(schema.enum as string[])[0];\n  }\n\n  if (type === 'file') {\n    return undefined;\n  }\n\n  return primitive(schema);\n}\n\nconst memo: typeof sampleFromSchema = memoize(sampleFromSchema);\n\nexport default memo;\n","/**\n * Portions of this file have been extracted and modified from Swagger UI.\n *\n * @license Apache-2.0\n * @see {@link https://github.com/swagger-api/swagger-ui/blob/master/src/core/utils.js}\n */\nimport type * as RMOAS from '../types.js';\n\nimport { isObject } from '../lib/helpers.js';\n\nexport function usesPolymorphism(schema: RMOAS.SchemaObject): 'allOf' | 'anyOf' | 'oneOf' | false {\n  if (schema.oneOf) {\n    return 'oneOf';\n  } else if (schema.anyOf) {\n    return 'anyOf';\n  } else if (schema.allOf) {\n    return 'allOf';\n  }\n\n  return false;\n}\n\nexport function objectify(thing: Record<string, unknown> | unknown): Record<string, any> {\n  if (!isObject(thing)) {\n    return {};\n  }\n\n  return thing;\n}\n\nexport function normalizeArray(arr: (number | string)[] | number | string): (number | string)[] {\n  if (Array.isArray(arr)) {\n    return arr;\n  }\n\n  return [arr];\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\nexport function isFunc(thing: unknown): thing is Function {\n  return typeof thing === 'function';\n}\n\n// Deeply strips a specific key from an object.\n//\n// `predicate` can be used to discriminate the stripping further,\n// by preserving the key's place in the object based on its value.\n// @todo make this have a better type than `any`\nexport function deeplyStripKey(\n  input: unknown,\n  keyToStrip: string,\n  predicate = (obj: unknown, key?: string): boolean => true, // eslint-disable-line @typescript-eslint/no-unused-vars\n): RMOAS.SchemaObject | any {\n  if (typeof input !== 'object' || Array.isArray(input) || input === null || !keyToStrip) {\n    return input;\n  }\n\n  const obj = { ...input } as Record<string, RMOAS.SchemaObject>;\n\n  Object.keys(obj).forEach(k => {\n    if (k === keyToStrip && predicate(obj[k], k)) {\n      delete obj[k];\n      return;\n    }\n\n    obj[k] = deeplyStripKey(obj[k], keyToStrip, predicate);\n  });\n\n  return obj;\n}\n","import type * as RMOAS from '../../types.js';\n\nimport matchesMimeType from '../../lib/matches-mimetype.js';\nimport sampleFromSchema from '../../samples/index.js';\n\nexport interface MediaTypeExample {\n  description?: string;\n  summary?: string;\n  title?: string;\n  value: unknown;\n}\n\n/**\n * Extracts a collection of examples from an OpenAPI Media Type Object. The example will either\n * come from the `example` property, the first item in an `examples` array, or if none of those are\n * present it will generate an example based off its schema.\n *\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#media-type-object}\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#media-type-object}\n * @param mediaType The media type that we're looking for examples for.\n * @param mediaTypeObject The media type object that we're looking for examples for.\n */\nexport function getMediaTypeExamples(\n  mediaType: string,\n  mediaTypeObject: RMOAS.MediaTypeObject,\n  opts: {\n    /**\n     * If you wish to include data that's flagged as `readOnly`.\n     */\n    includeReadOnly?: boolean;\n\n    /**\n     * If you wish to include data that's flatted as `writeOnly`.\n     */\n    includeWriteOnly?: boolean;\n  } = {},\n): MediaTypeExample[] {\n  if (mediaTypeObject.example) {\n    return [\n      {\n        value: mediaTypeObject.example,\n      },\n    ];\n  } else if (mediaTypeObject.examples) {\n    const { examples } = mediaTypeObject;\n    const multipleExamples = Object.keys(examples)\n      .map(key => {\n        let summary = key;\n        let description;\n\n        let example = examples[key];\n        if (example !== null && typeof example === 'object') {\n          if ('summary' in example) {\n            summary = example.summary;\n          }\n\n          if ('description' in example) {\n            description = example.description;\n          }\n\n          if ('value' in example) {\n            // If we have a $ref here then it's a circular reference and we should ignore it.\n            if (example.value !== null && typeof example.value === 'object' && '$ref' in example.value) {\n              return false;\n            }\n\n            example = example.value;\n          }\n        }\n\n        const ret: MediaTypeExample = { summary, title: key, value: example };\n        if (description) {\n          ret.description = description;\n        }\n\n        return ret;\n      })\n      .filter(Boolean) as MediaTypeExample[];\n\n    // If we were able to grab examples from the `examples` property return them (`examples` can\n    // sometimes be an empty object), otherwise we should try to generate some instead.\n    if (multipleExamples.length) {\n      return multipleExamples;\n    }\n  }\n\n  if (mediaTypeObject.schema) {\n    // We do not fully support XML so we shouldn't generate XML samples for XML schemas.\n    if (!matchesMimeType.xml(mediaType)) {\n      return [\n        {\n          // eslint-disable-next-line try-catch-failsafe/json-parse\n          value: sampleFromSchema(JSON.parse(JSON.stringify(mediaTypeObject.schema)), opts),\n        },\n      ];\n    }\n  }\n\n  return [];\n}\n","import type { MediaTypeExample } from './get-mediatype-examples.js';\nimport type * as RMOAS from '../../types.js';\n\nimport { isRef } from '../../types.js';\n\nimport { getMediaTypeExamples } from './get-mediatype-examples.js';\n\nexport type ResponseExamples = {\n  mediaTypes: Record<string, MediaTypeExample[]>;\n  onlyHeaders?: boolean;\n  status: string;\n}[];\n\n/**\n * Retrieve a collection of response examples keyed, by their media type.\n *\n * @param operation Operation to retrieve response examples for.\n */\nexport function getResponseExamples(operation: RMOAS.OperationObject) {\n  return Object.keys(operation.responses || {})\n    .map(status => {\n      const response = operation.responses[status];\n      let onlyHeaders = false;\n\n      // If we have a $ref here that means that this was a circular ref so we should ignore it.\n      if (isRef(response)) {\n        return false;\n      }\n\n      const mediaTypes: Record<string, MediaTypeExample[]> = {};\n      (response.content ? Object.keys(response.content) : []).forEach(mediaType => {\n        if (!mediaType) return;\n\n        const mediaTypeObject = response.content[mediaType];\n        const examples = getMediaTypeExamples(mediaType, mediaTypeObject, {\n          includeReadOnly: true,\n          includeWriteOnly: false,\n        });\n\n        if (examples) {\n          mediaTypes[mediaType] = examples;\n        }\n      });\n\n      // If the response has no content, but has headers, hardcode an empty example so the headers\n      // modal will still display\n      if (response.headers && Object.keys(response.headers).length && !Object.keys(mediaTypes).length) {\n        mediaTypes['*/*'] = [];\n        onlyHeaders = true;\n      }\n\n      if (!Object.keys(mediaTypes).length) {\n        return false;\n      }\n\n      return {\n        status,\n        mediaTypes,\n        ...(onlyHeaders ? { onlyHeaders } : {}),\n      };\n    })\n    .filter(Boolean) as ResponseExamples;\n}\n","import type { ResponseExamples } from './get-response-examples.js';\nimport type * as RMOAS from '../../types.js';\n\nimport { getResponseExamples } from './get-response-examples.js';\n\nexport type CallbackExamples = {\n  example: ResponseExamples;\n  expression: string;\n  identifier: string;\n  method: string;\n}[];\n\n/**\n * With an OpenAPI Operation Object return back a collection of examples for any callbacks that may\n * be present.\n *\n * @param operation Operation to retrieve callback examples from.\n */\nexport function getCallbackExamples(operation: RMOAS.OperationObject): CallbackExamples {\n  const ret: CallbackExamples = [];\n\n  // spreads the contents of the map for each callback so there's not nested arrays returned\n  return ret.concat(\n    ...Object.keys(operation.callbacks || {}).map(identifier => {\n      const callback = operation.callbacks[identifier] as RMOAS.CallbackObject;\n\n      // spreads the contents again so there's not nested arrays returned\n      return []\n        .concat(\n          ...Object.keys(callback).map(expression => {\n            return Object.keys(callback[expression]).map(method => {\n              const pathItem = callback[expression] as Record<string, RMOAS.OperationObject>;\n              const example = getResponseExamples(pathItem[method]);\n              if (example.length === 0) return false;\n\n              return {\n                identifier,\n                expression,\n                method,\n                example,\n              };\n            });\n          }),\n        )\n        .filter(Boolean);\n    }),\n  );\n}\n","import type { MediaTypeExample } from './get-mediatype-examples.js';\nimport type * as RMOAS from '../../types.js';\nimport type { Operation } from '../index.js';\nimport type { OpenAPIV3 } from 'openapi-types';\n\nimport { getExtension, type Extensions } from '../../extensions.js';\n\nexport type ExampleGroups = Record<\n  string,\n  {\n    /**\n     * Array of custom code samples that contain `correspondingExample` key.\n     * Mutually exclusive of `request`. Note that if this object is present,\n     * there may or may not be corresponding responses in the `response` object.\n     */\n    customCodeSamples?: (Extensions['code-samples'][number] & {\n      /**\n       * The index in the originally defined `code-samples` array\n       */\n      originalIndex: number;\n    })[];\n\n    /**\n     * Title of example group. This is derived from the `summary` field of one of\n     * the operation's example objects. The precedence is as follows (from highest to lowest):\n     * 1. The first custom code sample's `name` field.\n     * 2. The first request parameter (e.g., cookie/header/path/query) example object that\n     *  contains a `summary` field\n     * 3. The request body example object's `summary` field\n     * 4. The response example object's `summary` field\n     *\n     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#example-object}\n     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#example-object}\n     */\n    name: string;\n\n    /**\n     * Object containing the example request data for the current example key.\n     * Mutually exclusive of `customCodeSamples`. If `customCodeSamples` is present,\n     * any request example definitions are ignored.\n     */\n    request?: RMOAS.DataForHAR;\n\n    /**\n     * Object containing the example response data for the current example key.\n     */\n    response?: {\n      /**\n       * The content type of the current example\n       *\n       * @example \"application/json\"\n       * @example \"text/plain\"\n       */\n      mediaType: string;\n\n      /**\n       * The entire response example object. The example value itself is contained\n       * within `value`.\n       *\n       * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#example-object}\n       * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#example-object}\n       */\n      mediaTypeExample: MediaTypeExample;\n\n      /**\n       * The HTTP status code for the current response example\n       *\n       * @example \"2xx\"\n       * @example \"400\"\n       */\n      status: string;\n    };\n  }\n>;\n\n/**\n * Internal key to represent custom code samples that do not have a corresponding response example.\n */\nconst noCorrespondingResponseKey = 'NoCorrespondingResponseForCustomCodeSample';\n\n/**\n * Takes a groups object and an operation and adds any matching response examples\n * to existing groups object\n */\nfunction addMatchingResponseExamples(groups: ExampleGroups, operation: Operation) {\n  operation.getResponseExamples().forEach(example => {\n    Object.entries(example.mediaTypes || {}).forEach(([mediaType, mediaTypeExamples]) => {\n      mediaTypeExamples.forEach(mediaTypeExample => {\n        // only add a response example if the `title` field exists\n        // and it matches one of the existing example keys\n        if (mediaTypeExample.title && Object.keys(groups).includes(mediaTypeExample.title)) {\n          groups[mediaTypeExample.title].response = {\n            mediaType,\n            mediaTypeExample,\n            status: example.status,\n          };\n\n          // if the current group doesn't already have a name set,\n          // use the response example object's summary field\n          if (!groups[mediaTypeExample.title].name) {\n            groups[mediaTypeExample.title].name = mediaTypeExample.summary;\n          }\n        }\n      });\n    });\n  });\n}\n\n/**\n * Returns a name for the given custom code sample. If there isn't already one defined,\n * we construct a fallback value based on where the sample is in the array.\n */\nfunction getDefaultName(sample: Extensions['code-samples'][number], count: Record<string, number>): string {\n  return sample.name && sample.name.length > 0\n    ? sample.name\n    : `Default${count[sample.language] > 1 ? ` #${count[sample.language]}` : ''}`;\n}\n\n/**\n * Returns an object with groups of all example definitions (body/header/query/path/response/etc.).\n * The examples are grouped by their key when defined via the `examples` map.\n *\n * Any custom code samples defined via the `x-readme.code-samples` extension are returned,\n * regardless of if they have a matching response example.\n *\n * For standard OAS request parameter (e.g., body/header/query/path/etc.) examples,\n * they are only present in the return object if they have a corresponding response example\n * (i.e., a response example with the same key in the `examples` map).\n */\nexport function getExampleGroups(operation: Operation): ExampleGroups {\n  const namelessCodeSampleCounts: Record<string, number> = {};\n  const groups: ExampleGroups = {};\n\n  // add custom code samples\n  const codeSamples = getExtension('code-samples', operation.api, operation) as Extensions['code-samples'];\n  codeSamples?.forEach((sample, i) => {\n    if (namelessCodeSampleCounts[sample.language]) {\n      namelessCodeSampleCounts[sample.language] += 1;\n    } else {\n      namelessCodeSampleCounts[sample.language] = 1;\n    }\n    const name = getDefaultName(sample, namelessCodeSampleCounts);\n\n    // sample contains `correspondingExample` key\n    if (groups[sample.correspondingExample]?.customCodeSamples?.length) {\n      groups[sample.correspondingExample].customCodeSamples.push({ ...sample, name, originalIndex: i });\n    } else if (sample.correspondingExample) {\n      groups[sample.correspondingExample] = {\n        name,\n        customCodeSamples: [{ ...sample, name, originalIndex: i }],\n      };\n    }\n\n    // sample does not contain a corresponding response example\n    else if (groups[noCorrespondingResponseKey]?.customCodeSamples?.length) {\n      groups[noCorrespondingResponseKey].customCodeSamples.push({ ...sample, name, originalIndex: i });\n    } else {\n      groups[noCorrespondingResponseKey] = {\n        name,\n        customCodeSamples: [{ ...sample, name, originalIndex: i }],\n      };\n    }\n  });\n\n  // if we added any custom code samples, add the corresponding response examples and return\n  if (Object.keys(groups).length) {\n    addMatchingResponseExamples(groups, operation);\n    return groups;\n  }\n\n  // add request param examples\n  operation.getParameters().forEach(param => {\n    Object.entries(param.examples || {}).forEach(([exampleKey, paramExample]: [string, OpenAPIV3.ExampleObject]) => {\n      groups[exampleKey] = {\n        ...groups[exampleKey],\n        name: groups[exampleKey]?.name || paramExample.summary,\n        request: {\n          ...groups[exampleKey]?.request,\n          [param.in]: {\n            ...groups[exampleKey]?.request?.[param.in],\n            [param.name]: paramExample.value,\n          },\n        },\n      };\n    });\n  });\n\n  // add request body examples\n  operation.getRequestBodyExamples().forEach(requestExample => {\n    requestExample.examples.forEach((mediaTypeExample: MediaTypeExample) => {\n      if (mediaTypeExample.title) {\n        const mediaType = requestExample.mediaType === 'application/x-www-form-urlencoded' ? 'formData' : 'body';\n        groups[mediaTypeExample.title] = {\n          ...groups[mediaTypeExample.title],\n          name: groups[mediaTypeExample.title]?.name || mediaTypeExample.summary,\n          request: {\n            ...groups[mediaTypeExample.title]?.request,\n            [mediaType]: mediaTypeExample.value,\n          },\n        };\n      }\n    });\n  });\n\n  // if we added any request examples, add the corresponding response examples\n  if (Object.keys(groups).length) {\n    addMatchingResponseExamples(groups, operation);\n  }\n\n  // prune any objects that don't have both a request and a response\n  Object.entries(groups).forEach(([groupId, group]) => {\n    if (group.request && !group.response) {\n      delete groups[groupId];\n    }\n  });\n\n  return groups;\n}\n","import type { MediaTypeExample } from './get-mediatype-examples.js';\nimport type * as RMOAS from '../../types.js';\n\nimport { getMediaTypeExamples } from './get-mediatype-examples.js';\n\nexport type RequestBodyExamples = {\n  examples: MediaTypeExample[];\n  mediaType: string;\n}[];\n\n/**\n * Retrieve a collection of request body examples, keyed by their media type.\n *\n * @param operation Operation to retrieve requestBody examples for.\n */\nexport function getRequestBodyExamples(operation: RMOAS.OperationObject): RequestBodyExamples {\n  // `requestBody` will never have `$ref` pointers here so we need to work around the type that we\n  // have from `RMOAS.OperationObject`.\n  const requestBody = operation.requestBody as RMOAS.RequestBodyObject;\n  if (!requestBody || !requestBody.content) {\n    return [];\n  }\n\n  return Object.keys(requestBody.content || {})\n    .map(mediaType => {\n      const mediaTypeObject = requestBody.content[mediaType];\n      const examples = getMediaTypeExamples(mediaType, mediaTypeObject, {\n        includeReadOnly: false,\n        includeWriteOnly: true,\n      });\n\n      if (!examples.length) {\n        return false;\n      }\n\n      return {\n        mediaType,\n        examples,\n      };\n    })\n    .filter(x => x !== false);\n}\n","import type {\n  ComponentsObject,\n  MediaTypeObject,\n  OASDocument,\n  ResponseObject,\n  SchemaObject,\n  HeaderObject,\n} from '../../types.js';\nimport type { Operation } from '../index.js';\n\nimport cloneObject from '../../lib/clone-object.js';\nimport { isPrimitive } from '../../lib/helpers.js';\nimport matches from '../../lib/matches-mimetype.js';\nimport { toJSONSchema, getSchemaVersionString } from '../../lib/openapi-to-json-schema.js';\n\ninterface ResponseSchemaObject {\n  description?: string;\n  label: string;\n  schema: SchemaObject;\n  type: string[] | string;\n}\n\nconst isJSON = matches.json;\n\n/**\n * Turn a header map from OpenAPI 3.0 (and some earlier versions too) into a schema.\n *\n * Note: This does not support OpenAPI 3.1's header format.\n *\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#header-object}\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.3.md#header-object}\n * @param response Response object to build a JSON Schema object for its headers for.\n */\nfunction buildHeadersSchema(\n  response: ResponseObject,\n  opts?: {\n    /**\n     * With a transformer you can transform any data within a given schema, like say if you want to\n     * rewrite a potentially unsafe `title` that might be eventually used as a JS variable name,\n     * just make sure to return your transformed schema.\n     */\n    transformer?: (schema: SchemaObject) => SchemaObject;\n  },\n) {\n  const headers = response.headers;\n\n  const headersSchema: SchemaObject = {\n    type: 'object',\n    properties: {},\n  };\n\n  Object.keys(headers).forEach(key => {\n    if (headers[key] && (headers[key] as HeaderObject).schema) {\n      const header: HeaderObject = headers[key] as HeaderObject;\n\n      // TODO: Response headers are essentially parameters in OAS\n      //    This means they can have content instead of schema.\n      //    We should probably support that in the future\n      headersSchema.properties[key] = toJSONSchema(header.schema, {\n        addEnumsToDescriptions: true,\n        transformer: opts.transformer,\n      });\n\n      if (header.description) {\n        (headersSchema.properties[key] as HeaderObject).description = header.description;\n      }\n    }\n  });\n\n  const headersWrapper: {\n    description?: string;\n    label: string;\n    schema: SchemaObject;\n    type: string;\n  } = {\n    schema: headersSchema,\n    type: 'object',\n    label: 'Headers',\n  };\n\n  if (response.description && headersWrapper.schema) {\n    headersWrapper.description = response.description;\n  }\n\n  return headersWrapper;\n}\n\n/**\n * Extract all the response schemas, matching the format of `get-parameters-as-json-schema`.\n *\n * Note: This expects a dereferenced schema.\n *\n * @param operation Operation to construct a response JSON Schema for.\n * @param api The OpenAPI definition that this operation originates.\n * @param statusCode The response status code to generate a schema for.\n */\nexport function getResponseAsJSONSchema(\n  operation: Operation,\n  api: OASDocument,\n  statusCode: number | string,\n  opts?: {\n    includeDiscriminatorMappingRefs?: boolean;\n    /**\n     * With a transformer you can transform any data within a given schema, like say if you want\n     * to rewrite a potentially unsafe `title` that might be eventually used as a JS variable\n     * name, just make sure to return your transformed schema.\n     */\n    transformer?: (schema: SchemaObject) => SchemaObject;\n  },\n): ResponseSchemaObject[] | null {\n  const response = operation.getResponseByStatusCode(statusCode);\n  const jsonSchema: ResponseSchemaObject[] = [];\n\n  if (!response) {\n    return null;\n  }\n\n  let hasCircularRefs = false;\n  let hasDiscriminatorMappingRefs = false;\n\n  function refLogger(ref: string, type: 'discriminator' | 'ref') {\n    if (type === 'ref') {\n      hasCircularRefs = true;\n    } else {\n      hasDiscriminatorMappingRefs = true;\n    }\n  }\n\n  /**\n   * @param content An array of `MediaTypeObject`'s to retrieve a preferred schema out of. We\n   *    prefer JSON media types.\n   */\n  function getPreferredSchema(content: Record<string, MediaTypeObject>) {\n    if (!content) {\n      return null;\n    }\n\n    const contentTypes = Object.keys(content);\n    if (!contentTypes.length) {\n      return null;\n    }\n\n    // eslint-disable-next-line no-plusplus\n    for (let i = 0; i < contentTypes.length; i++) {\n      if (isJSON(contentTypes[i])) {\n        return toJSONSchema(cloneObject(content[contentTypes[i]].schema), {\n          addEnumsToDescriptions: true,\n          refLogger,\n          transformer: opts.transformer,\n        });\n      }\n    }\n\n    // We always want to prefer the JSON-compatible content types over everything else but if we\n    // haven't found one we should default to the first available.\n    const contentType = contentTypes.shift();\n    return toJSONSchema(cloneObject(content[contentType].schema), {\n      addEnumsToDescriptions: true,\n      refLogger,\n      transformer: opts.transformer,\n    });\n  }\n\n  const foundSchema = getPreferredSchema((response as ResponseObject).content);\n  if (foundSchema) {\n    const schema = cloneObject(foundSchema);\n    const schemaWrapper: {\n      description?: string;\n      label: string;\n      schema: SchemaObject;\n      type: string[] | string;\n    } = {\n      // If there's no `type` then the root schema is a circular `$ref` that we likely won't be\n      // able to render so instead of generating a JSON Schema with an `undefined` type we should\n      // default to `string` so there's at least *something* the end-user can interact with.\n      type: foundSchema.type || 'string',\n      schema: isPrimitive(schema)\n        ? schema\n        : {\n            ...schema,\n            $schema: getSchemaVersionString(schema, api),\n          },\n      label: 'Response body',\n    };\n\n    if ((response as ResponseObject).description && schemaWrapper.schema) {\n      schemaWrapper.description = (response as ResponseObject).description;\n    }\n\n    /**\n     * Since this library assumes that the schema has already been dereferenced, adding every\n     * component here that **isn't** circular adds a ton of bloat so it'd be cool if `components`\n     * was just the remaining `$ref` pointers that are still being referenced.\n     *\n     * @todo\n     */\n    if (api.components && schemaWrapper.schema) {\n      // We should only include components if we've got circular refs or we have discriminator\n      // mapping refs (we want to include them).\n      if (hasCircularRefs || (hasDiscriminatorMappingRefs && opts.includeDiscriminatorMappingRefs)) {\n        ((schemaWrapper.schema as SchemaObject).components as ComponentsObject) = api.components as ComponentsObject;\n      }\n    }\n\n    jsonSchema.push(schemaWrapper);\n  }\n\n  // 3.0.3 and earlier headers. TODO: New format for 3.1.0\n  if ((response as ResponseObject).headers) {\n    jsonSchema.push(buildHeadersSchema(response as ResponseObject, opts));\n  }\n\n  return jsonSchema.length ? jsonSchema : null;\n}\n","import type { Extensions } from '../extensions.js';\nimport type { SecurityType } from '../types.js';\nimport type { CallbackExamples } from './lib/get-callback-examples.js';\nimport type { getParametersAsJSONSchemaOptions, SchemaWrapper } from './lib/get-parameters-as-json-schema.js';\nimport type { RequestBodyExamples } from './lib/get-requestbody-examples.js';\nimport type { ResponseExamples } from './lib/get-response-examples.js';\nimport type { OpenAPIV3, OpenAPIV3_1 } from 'openapi-types';\n\nimport findSchemaDefinition from '../lib/find-schema-definition.js';\nimport matchesMimeType from '../lib/matches-mimetype.js';\nimport * as RMOAS from '../types.js';\nimport { supportedMethods } from '../utils.js';\n\nimport { dedupeCommonParameters } from './lib/dedupe-common-parameters.js';\nimport { getCallbackExamples } from './lib/get-callback-examples.js';\nimport { getExampleGroups, type ExampleGroups } from './lib/get-example-groups.js';\nimport { getParametersAsJSONSchema } from './lib/get-parameters-as-json-schema.js';\nimport { getRequestBodyExamples } from './lib/get-requestbody-examples.js';\nimport { getResponseAsJSONSchema } from './lib/get-response-as-json-schema.js';\nimport { getResponseExamples } from './lib/get-response-examples.js';\n\nexport class Operation {\n  /**\n   * Schema of the operation from the API Definition.\n   */\n  schema: RMOAS.OperationObject;\n\n  /**\n   * OpenAPI API Definition that this operation originated from.\n   */\n  api: RMOAS.OASDocument;\n\n  /**\n   * Path that this operation is targeted towards.\n   */\n  path: string;\n\n  /**\n   * HTTP Method that this operation is targeted towards.\n   */\n  method: RMOAS.HttpMethods;\n\n  /**\n   * The primary Content Type that this operation accepts.\n   */\n  contentType: string;\n\n  /**\n   * An object with groups of all example definitions (body/header/query/path/response/etc.)\n   */\n  exampleGroups: ExampleGroups;\n\n  /**\n   * Request body examples for this operation.\n   */\n  requestBodyExamples: RequestBodyExamples;\n\n  /**\n   * Response examples for this operation.\n   */\n  responseExamples: ResponseExamples;\n\n  /**\n   * Callback examples for this operation (if it has callbacks).\n   */\n  callbackExamples: CallbackExamples;\n\n  /**\n   * Flattened out arrays of both request and response headers that are utilized on this operation.\n   */\n  headers: {\n    request: string[];\n    response: string[];\n  };\n\n  constructor(api: RMOAS.OASDocument, path: string, method: RMOAS.HttpMethods, operation: RMOAS.OperationObject) {\n    this.schema = operation;\n    this.api = api;\n    this.path = path;\n    this.method = method;\n\n    this.contentType = undefined;\n    this.requestBodyExamples = undefined;\n    this.responseExamples = undefined;\n    this.callbackExamples = undefined;\n    this.exampleGroups = undefined;\n    this.headers = {\n      request: [],\n      response: [],\n    };\n  }\n\n  getSummary(): string {\n    if (this.schema?.summary && typeof this.schema.summary === 'string') {\n      return this.schema.summary;\n    } else if (this.api.paths[this.path].summary && typeof this.api.paths[this.path].summary === 'string') {\n      return this.api.paths[this.path].summary;\n    }\n\n    return undefined;\n  }\n\n  getDescription(): string {\n    if (this.schema?.description && typeof this.schema.description === 'string') {\n      return this.schema.description;\n    } else if (this.api.paths[this.path].description && typeof this.api.paths[this.path].description === 'string') {\n      return this.api.paths[this.path].description;\n    }\n\n    return undefined;\n  }\n\n  getContentType(): string {\n    if (this.contentType) {\n      return this.contentType;\n    }\n\n    let types: string[] = [];\n    if (this.schema.requestBody) {\n      if ('$ref' in this.schema.requestBody) {\n        this.schema.requestBody = findSchemaDefinition(this.schema.requestBody.$ref, this.api);\n      }\n\n      if ('content' in this.schema.requestBody) {\n        types = Object.keys(this.schema.requestBody.content);\n      }\n    }\n\n    this.contentType = 'application/json';\n    if (types && types.length) {\n      this.contentType = types[0];\n    }\n\n    // Favor JSON if it exists\n    types.forEach(t => {\n      if (matchesMimeType.json(t)) {\n        this.contentType = t;\n      }\n    });\n\n    return this.contentType;\n  }\n\n  isFormUrlEncoded(): boolean {\n    return matchesMimeType.formUrlEncoded(this.getContentType());\n  }\n\n  isMultipart(): boolean {\n    return matchesMimeType.multipart(this.getContentType());\n  }\n\n  isJson(): boolean {\n    return matchesMimeType.json(this.getContentType());\n  }\n\n  isXml(): boolean {\n    return matchesMimeType.xml(this.getContentType());\n  }\n\n  /**\n   * Checks if the current operation is a webhook or not.\n   *\n   */\n  isWebhook(): boolean {\n    return this instanceof Webhook;\n  }\n\n  /**\n   * Returns an array of all security requirements associated wtih this operation. If none are\n   * defined at the operation level, the securities for the entire API definition are returned\n   * (with an empty array as a final fallback).\n   *\n   */\n  getSecurity(): RMOAS.SecurityRequirementObject[] {\n    if (!this.api?.components?.securitySchemes || !Object.keys(this.api.components.securitySchemes).length) {\n      return [];\n    }\n\n    return this.schema.security || this.api.security || [];\n  }\n\n  /**\n   * Retrieve a collection of grouped security schemes. The inner array determines AND-grouped\n   * security schemes, the outer array determines OR-groups.\n   *\n   * @see {@link https://swagger.io/docs/specification/authentication/#multiple}\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#security-requirement-object}\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#security-requirement-object}\n   * @param filterInvalid Optional flag that, when set to `true`, filters out invalid/nonexistent\n   *    security schemes, rather than returning `false`.\n   */\n  getSecurityWithTypes(\n    filterInvalid = false,\n  ): ((false | { security: RMOAS.KeyedSecuritySchemeObject; type: SecurityType })[] | false)[] {\n    const securityRequirements = this.getSecurity();\n\n    return securityRequirements.map(requirement => {\n      let keys;\n      try {\n        keys = Object.keys(requirement);\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      } catch (e) {\n        return false;\n      }\n\n      const keysWithTypes = keys.map(key => {\n        let security;\n        try {\n          // Remove the reference type, because we know this will be dereferenced\n          security = this.api.components.securitySchemes[key] as RMOAS.KeyedSecuritySchemeObject;\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        } catch (e) {\n          return false;\n        }\n\n        if (!security) return false;\n\n        let type: SecurityType = null;\n\n        if (security.type === 'http') {\n          if (security.scheme === 'basic') type = 'Basic';\n          else if (security.scheme === 'bearer') type = 'Bearer';\n          else type = security.type;\n        } else if (security.type === 'oauth2') {\n          type = 'OAuth2';\n        } else if (security.type === 'apiKey') {\n          if (security.in === 'query') type = 'Query';\n          else if (security.in === 'header') type = 'Header';\n          else if (security.in === 'cookie') type = 'Cookie';\n          else type = security.type;\n        } else {\n          return false;\n        }\n\n        return {\n          type,\n          security: {\n            ...security,\n            _key: key,\n            _requirements: requirement[key],\n          },\n        };\n      });\n\n      if (filterInvalid) return keysWithTypes.filter(key => key !== false);\n\n      return keysWithTypes;\n    });\n  }\n\n  /**\n   * Retrieve an object where the keys are unique scheme types, and the values are arrays\n   * containing each security scheme of that type.\n   *\n   */\n  prepareSecurity(): Record<SecurityType, RMOAS.KeyedSecuritySchemeObject[]> {\n    const securitiesWithTypes = this.getSecurityWithTypes();\n\n    return securitiesWithTypes.reduce(\n      (prev, securities) => {\n        if (!securities) return prev;\n\n        securities.forEach(security => {\n          // Remove non-existent schemes\n          if (!security) return;\n          if (!prev[security.type]) prev[security.type] = [];\n\n          // Only add schemes we haven't seen yet.\n          const exists = prev[security.type].some(sec => sec._key === security.security._key);\n          if (!exists) {\n            // Since an operation can require the same security scheme several times (each with different scope requirements),\n            // including the `_requirements` in this object would be misleading since we dedupe the security schemes.\n            // eslint-disable-next-line no-underscore-dangle\n            if (security.security?._requirements) delete security.security._requirements;\n            prev[security.type].push(security.security);\n          }\n        });\n\n        return prev;\n      },\n      {} as Record<SecurityType, RMOAS.KeyedSecuritySchemeObject[]>,\n    );\n  }\n\n  getHeaders(): Operation['headers'] {\n    const security = this.prepareSecurity();\n    if (security.Header) {\n      this.headers.request = (security.Header as OpenAPIV3_1.ApiKeySecurityScheme[]).map(h => {\n        return h.name;\n      });\n    }\n\n    if (security.Bearer || security.Basic || security.OAuth2) {\n      this.headers.request.push('Authorization');\n    }\n\n    if (security.Cookie) {\n      this.headers.request.push('Cookie');\n    }\n\n    if (this.schema.parameters) {\n      this.headers.request = this.headers.request.concat(\n        // Remove the reference object because we will have already dereferenced.\n        (this.schema.parameters as OpenAPIV3_1.ParameterObject[] | OpenAPIV3.ParameterObject[])\n          .map(p => {\n            if (p.in && p.in === 'header') return p.name;\n            return undefined;\n          })\n          .filter(p => p),\n      );\n    }\n\n    if (this.schema.responses) {\n      this.headers.response = Object.keys(this.schema.responses)\n        // Remove the reference object because we will have already dereferenced.\n        .filter(r => (this.schema.responses[r] as RMOAS.ResponseObject).headers)\n        .map(r =>\n          // Remove the reference object because we will have already dereferenced.\n          Object.keys((this.schema.responses[r] as RMOAS.ResponseObject).headers),\n        )\n        .reduce((a, b) => a.concat(b), []);\n    }\n\n    // If the operation doesn't already specify a `content-type` request header, we check if the\n    // path operation request body contains content, which implies that we should also include the\n    // `content-type` header.\n    if (!this.headers.request.includes('Content-Type') && this.schema.requestBody) {\n      if (\n        (this.schema.requestBody as RMOAS.RequestBodyObject).content &&\n        Object.keys((this.schema.requestBody as RMOAS.RequestBodyObject).content)\n      ) {\n        this.headers.request.push('Content-Type');\n      }\n    }\n\n    // This is a similar approach, but in this case if we check the response content and prioritize\n    // the `accept` request header and `content-type` request header.\n    if (this.schema.responses) {\n      if (\n        Object.keys(this.schema.responses).some(\n          response => !!(this.schema.responses[response] as RMOAS.ResponseObject).content,\n        )\n      ) {\n        if (!this.headers.request.includes('Accept')) this.headers.request.push('Accept');\n        if (!this.headers.response.includes('Content-Type')) this.headers.response.push('Content-Type');\n      }\n    }\n\n    return this.headers;\n  }\n\n  /**\n   * Determine if the operation has an operation present in its schema. Note that if one is present\n   * in the schema but is an empty string then this will return false.\n   *\n   */\n  hasOperationId(): boolean {\n    return Boolean('operationId' in this.schema && this.schema.operationId.length);\n  }\n\n  /**\n   * Get an `operationId` for this operation. If one is not present (it's not required by the spec!)\n   * a hash of the path and method will be returned instead.\n   *\n   */\n  getOperationId(\n    opts: {\n      /**\n       * Generate a JS method-friendly operation ID when one isn't present.\n       *\n       * For backwards compatiblity reasons this option will be indefinitely supported however we\n       * recommend using `friendlyCase` instead as it's a heavily improved version of this option.\n       *\n       * @see {opts.friendlyCase}\n       * @deprecated\n       */\n      camelCase?: boolean;\n\n      /**\n       * Generate a human-friendly, but still camelCase, operation ID when one isn't present. The\n       * difference between this and `camelCase` is that this also ensure that consecutive words are\n       * not present in the resulting ID. For example, for the endpoint `/candidate/{candidate}` will\n       * return `getCandidateCandidate` for `camelCase` however `friendlyCase` will return\n       * `getCandidate`.\n       *\n       * The reason this friendliness is just not a part of the `camelCase` option is because we have\n       * a number of consumers of the old operation ID style and making that change there would a\n       * breaking change that we don't have any easy way to resolve.\n       */\n      friendlyCase?: boolean;\n    } = {},\n  ): string {\n    function sanitize(id: string) {\n      // We aren't sanitizing underscores here by default in order to preserve operation IDs that\n      // were already generated with this method in the past.\n      return id\n        .replace(opts?.camelCase || opts?.friendlyCase ? /[^a-zA-Z0-9_]/g : /[^a-zA-Z0-9]/g, '-') // Remove weird characters\n        .replace(/--+/g, '-') // Remove double --'s\n        .replace(/^-|-$/g, ''); // Don't start or end with -\n    }\n\n    let operationId;\n    if (this.hasOperationId()) {\n      operationId = this.schema.operationId;\n    } else {\n      operationId = sanitize(this.path).toLowerCase();\n    }\n\n    const method = this.method.toLowerCase();\n    if (opts?.camelCase || opts?.friendlyCase) {\n      if (opts?.friendlyCase) {\n        // In order to generate friendlier operation IDs we should swap out underscores with spaces\n        // so the end result will be _slightly_ more camelCase.\n        operationId = operationId.replaceAll('_', ' ');\n\n        if (!this.hasOperationId()) {\n          // In another effort to generate friendly operation IDs we should prevent words from\n          // appearing in consecutive order (eg. `/candidate/{candidate}` should generate\n          // `getCandidate` not `getCandidateCandidate`). However we only want to do this if we're\n          // generating the operation ID as if they intentionally added a consecutive word into the\n          // operation ID then we should respect that.\n          operationId = operationId\n            .replace(/[^a-zA-Z0-9_]+(.)/g, (_, chr) => ` ${chr}`)\n            .split(' ')\n            .filter((word, i, arr) => word !== arr[i - 1])\n            .join(' ');\n        }\n      }\n\n      operationId = operationId.replace(/[^a-zA-Z0-9_]+(.)/g, (_, chr) => chr.toUpperCase());\n      if (this.hasOperationId()) {\n        operationId = sanitize(operationId);\n      }\n\n      // Never start with a number.\n      operationId = operationId.replace(/^[0-9]/g, match => `_${match}`);\n\n      // Ensure that the first character of an `operationId` is always lowercase.\n      operationId = operationId.charAt(0).toLowerCase() + operationId.slice(1);\n\n      // If the generated `operationId` already starts with the method (eg. `getPets`) we don't want\n      // to double it up into `getGetPets`.\n      if (operationId.startsWith(method)) {\n        return operationId;\n      }\n\n      // If this operation already has an `operationId` and we just cleaned it up then we shouldn't\n      // prefix it with an HTTP method.\n      if (this.hasOperationId()) {\n        return operationId;\n      }\n\n      // Because we're merging the `operationId` into an HTTP method we need to reset the first\n      // character of it back to lowercase so we end up with `getBuster`, not `getbuster`.\n      operationId = operationId.charAt(0).toUpperCase() + operationId.slice(1);\n      return `${method}${operationId}`;\n    } else if (this.hasOperationId()) {\n      return operationId;\n    }\n\n    return `${method}_${operationId}`;\n  }\n\n  /**\n   * Return an array of all tags, and their metadata, that exist on this operation.\n   *\n   */\n  getTags(): RMOAS.TagObject[] {\n    if (!('tags' in this.schema)) {\n      return [];\n    }\n\n    const oasTagMap: Map<string, RMOAS.TagObject> = new Map();\n    if ('tags' in this.api) {\n      this.api.tags.forEach((tag: RMOAS.TagObject) => {\n        oasTagMap.set(tag.name, tag);\n      });\n    }\n\n    const oasTags = Object.fromEntries(oasTagMap);\n\n    const tags: RMOAS.TagObject[] = [];\n    if (Array.isArray(this.schema.tags)) {\n      this.schema.tags.forEach(tag => {\n        if (tag in oasTags) {\n          tags.push(oasTags[tag]);\n        } else {\n          tags.push({\n            name: tag,\n          });\n        }\n      });\n    }\n\n    return tags;\n  }\n\n  /**\n   * Return is the operation is flagged as `deprecated` or not.\n   *\n   */\n  isDeprecated(): boolean {\n    return 'deprecated' in this.schema ? this.schema.deprecated : false;\n  }\n\n  /**\n   * Determine if the operation has any (non-request body) parameters.\n   *\n   */\n  hasParameters(): boolean {\n    return !!this.getParameters().length;\n  }\n\n  /**\n   * Return the parameters (non-request body) on the operation.\n   *\n   */\n  getParameters(): RMOAS.ParameterObject[] {\n    let parameters = (this.schema?.parameters || []) as RMOAS.ParameterObject[];\n    const commonParams = (this.api?.paths?.[this.path]?.parameters || []) as RMOAS.ParameterObject[];\n    if (commonParams.length) {\n      parameters = parameters.concat(dedupeCommonParameters(parameters, commonParams) || []);\n    }\n\n    return parameters;\n  }\n\n  /**\n   * Determine if this operation has any required parameters.\n   *\n   */\n  hasRequiredParameters(): boolean {\n    return this.getParameters().some(param => 'required' in param && param.required);\n  }\n\n  /**\n   * Convert the operation into an array of JSON Schema schemas for each available type of\n   * parameter available on the operation.\n   *\n   */\n  getParametersAsJSONSchema(opts: getParametersAsJSONSchemaOptions = {}): SchemaWrapper[] {\n    return getParametersAsJSONSchema(this, this.api, {\n      includeDiscriminatorMappingRefs: true,\n      transformer: (s: RMOAS.SchemaObject) => s,\n      ...opts,\n    });\n  }\n\n  /**\n   * Get a single response for this status code, formatted as JSON schema.\n   *\n   * @param statusCode Status code to pull a JSON Schema response for.\n   */\n  getResponseAsJSONSchema(\n    statusCode: number | string,\n    opts: {\n      /**\n       * If you wish to include discriminator mapping `$ref` components alongside your\n       * `discriminator` in schemas. Defaults to `true`.\n       */\n      includeDiscriminatorMappingRefs?: boolean;\n\n      /**\n       * With a transformer you can transform any data within a given schema, like say if you want\n       * to rewrite a potentially unsafe `title` that might be eventually used as a JS variable\n       * name, just make sure to return your transformed schema.\n       */\n      transformer?: (schema: RMOAS.SchemaObject) => RMOAS.SchemaObject;\n    } = {},\n  ): RMOAS.SchemaObject {\n    return getResponseAsJSONSchema(this, this.api, statusCode, {\n      includeDiscriminatorMappingRefs: true,\n      transformer: (s: RMOAS.SchemaObject) => s,\n      ...opts,\n    });\n  }\n\n  /**\n   * Get an array of all valid response status codes for this operation.\n   *\n   */\n  getResponseStatusCodes(): string[] {\n    return this.schema.responses ? Object.keys(this.schema.responses) : [];\n  }\n\n  /**\n   * Determine if the operation has any request bodies.\n   *\n   */\n  hasRequestBody(): boolean {\n    return !!this.schema.requestBody;\n  }\n\n  /**\n   * Retrieve the list of all available media types that the operations request body can accept.\n   *\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#media-type-object}\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#media-type-object}\n   */\n  getRequestBodyMediaTypes(): string[] {\n    if (!this.hasRequestBody()) {\n      return [];\n    }\n\n    const requestBody = this.schema.requestBody;\n    if (RMOAS.isRef(requestBody)) {\n      // If the request body is still a `$ref` pointer we should return false because this library\n      // assumes that you've run dereferencing beforehand.\n      return [];\n    }\n\n    return Object.keys(requestBody.content);\n  }\n\n  /**\n   * Determine if this operation has a required request body.\n   *\n   */\n  hasRequiredRequestBody(): boolean {\n    if (!this.hasRequestBody()) {\n      return false;\n    }\n\n    const requestBody = this.schema.requestBody;\n    if (RMOAS.isRef(requestBody)) {\n      return false;\n    }\n\n    if (requestBody.required) {\n      return true;\n    }\n\n    // The OpenAPI spec isn't clear on the differentiation between schema `required` and\n    // `requestBody.required` because you can have required top-level schema properties but a\n    // non-required requestBody that negates each other.\n    //\n    // To kind of work ourselves around this and present a better QOL for this accessor, if at this\n    // final point where we don't have a required request body, but the underlying Media Type Object\n    // schema says that it has required properties then we should ultimately recognize that this\n    // request body is required -- even as the request body description says otherwise.\n    return !!this.getParametersAsJSONSchema()\n      .filter(js => ['body', 'formData'].includes(js.type))\n      .find(js => js.schema && Array.isArray(js.schema.required) && js.schema.required.length);\n  }\n\n  /**\n   * Retrieve a specific request body content schema off this operation.\n   *\n   * If no media type is supplied this will return either the first available JSON-like request\n   * body, or the first available if there are no JSON-like media types present. When this return\n   * comes back it's in the form of an array with the first key being the selected media type,\n   * followed by the media type object in question.\n   *\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#media-type-object}\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#media-type-object}\n   * @param mediaType Specific request body media type to retrieve if present.\n   */\n  getRequestBody(mediaType?: string): RMOAS.MediaTypeObject | false | [string, RMOAS.MediaTypeObject, ...string[]] {\n    if (!this.hasRequestBody()) {\n      return false;\n    }\n\n    const requestBody = this.schema.requestBody;\n    if (RMOAS.isRef(requestBody)) {\n      // If the request body is still a `$ref` pointer we should return false because this library\n      // assumes that you've run dereferencing beforehand.\n      return false;\n    }\n\n    if (mediaType) {\n      if (!(mediaType in requestBody.content)) {\n        return false;\n      }\n\n      return requestBody.content[mediaType];\n    }\n\n    // Since no media type was supplied we need to find either the first JSON-like media type that\n    // we've got, or the first available of anything else if no JSON-like media types are present.\n    let availableMediaType: string;\n    const mediaTypes = this.getRequestBodyMediaTypes();\n    mediaTypes.forEach((mt: string) => {\n      if (!availableMediaType && matchesMimeType.json(mt)) {\n        availableMediaType = mt;\n      }\n    });\n\n    if (!availableMediaType) {\n      mediaTypes.forEach((mt: string) => {\n        if (!availableMediaType) {\n          availableMediaType = mt;\n        }\n      });\n    }\n\n    if (availableMediaType) {\n      return [\n        availableMediaType,\n        requestBody.content[availableMediaType],\n        ...(requestBody.description ? [requestBody.description] : []),\n      ];\n    }\n\n    return false;\n  }\n\n  /**\n   * Retrieve an array of request body examples that this operation has.\n   *\n   */\n  getRequestBodyExamples(): RequestBodyExamples {\n    const isRequestExampleValueDefined = typeof this.requestBodyExamples?.[0]?.examples?.[0].value !== 'undefined';\n\n    if (this.requestBodyExamples && isRequestExampleValueDefined) {\n      return this.requestBodyExamples;\n    }\n\n    this.requestBodyExamples = getRequestBodyExamples(this.schema);\n    return this.requestBodyExamples;\n  }\n\n  /**\n   * Return a specific response out of the operation by a given HTTP status code.\n   *\n   * @param statusCode Status code to pull a response object for.\n   */\n  getResponseByStatusCode(statusCode: number | string): RMOAS.ResponseObject | boolean {\n    if (!this.schema.responses) {\n      return false;\n    }\n\n    if (typeof this.schema.responses[statusCode] === 'undefined') {\n      return false;\n    }\n\n    const response = this.schema.responses[statusCode];\n\n    if (RMOAS.isRef(response)) {\n      return false;\n    }\n\n    // Remove the reference from the type, because it will already be dereferenced.\n    return response;\n  }\n\n  /**\n   * Retrieve an array of response examples that this operation has.\n   *\n   */\n  getResponseExamples(): ResponseExamples {\n    if (this.responseExamples) {\n      return this.responseExamples;\n    }\n\n    // @todo Remove this `as` once we convert getResponseExamples\n    this.responseExamples = getResponseExamples(this.schema) as ResponseExamples;\n    return this.responseExamples;\n  }\n\n  /**\n   * Determine if the operation has callbacks.\n   *\n   */\n  hasCallbacks(): boolean {\n    return !!this.schema.callbacks;\n  }\n\n  /**\n   * Retrieve a specific callback.\n   *\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#callback-object}\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#callback-object}\n   * @param identifier Callback identifier to look for.\n   * @param expression Callback expression to look for.\n   * @param method HTTP Method on the callback to look for.\n   */\n  getCallback(identifier: string, expression: string, method: RMOAS.HttpMethods): Callback | false {\n    if (!this.schema.callbacks) return false;\n\n    // The usage of `as` in the below is to remove the possibility of a ref type, since we've\n    // dereferenced.\n    const callback = this.schema.callbacks[identifier]\n      ? (((this.schema.callbacks as Record<string, RMOAS.CallbackObject>)[identifier] as RMOAS.CallbackObject)[\n          expression\n        ] as RMOAS.PathItemObject)\n      : false;\n\n    if (!callback || !callback[method]) return false;\n    return new Callback(this.api, expression, method, callback[method], identifier, callback);\n  }\n\n  /**\n   * Retrieve an array of operations created from each callback.\n   *\n   */\n  getCallbacks(): (Callback | false)[] | false {\n    const callbackOperations: (Callback | false)[] = [];\n    if (!this.hasCallbacks()) return false;\n\n    Object.keys(this.schema.callbacks).forEach(callback => {\n      Object.keys(this.schema.callbacks[callback]).forEach(expression => {\n        const cb = this.schema.callbacks[callback];\n\n        if (!RMOAS.isRef(cb)) {\n          const exp = cb[expression];\n\n          if (!RMOAS.isRef(exp)) {\n            Object.keys(exp).forEach((method: RMOAS.HttpMethods) => {\n              if (!supportedMethods.includes(method)) return;\n\n              callbackOperations.push(this.getCallback(callback, expression, method));\n            });\n          }\n        }\n      });\n    });\n\n    return callbackOperations;\n  }\n\n  /**\n   * Retrieve an array of callback examples that this operation has.\n   *\n   */\n  getCallbackExamples(): CallbackExamples {\n    if (this.callbackExamples) {\n      return this.callbackExamples;\n    }\n\n    this.callbackExamples = getCallbackExamples(this.schema);\n    return this.callbackExamples;\n  }\n\n  /**\n   * Determine if a given a custom specification extension exists within the operation.\n   *\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#specification-extensions}\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#specification-extensions}\n   * @param extension Specification extension to lookup.\n   */\n  hasExtension(extension: string): boolean {\n    return Boolean(this.schema && extension in this.schema);\n  }\n\n  /**\n   * Retrieve a custom specification extension off of the operation.\n   *\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#specification-extensions}\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#specification-extensions}\n   * @param extension Specification extension to lookup.\n   *\n   * @deprecated Use `oas.getExtension(extension, operation)` instead.\n   */\n  getExtension(extension: string | keyof Extensions): any {\n    return this.schema?.[extension];\n  }\n\n  /**\n   * Returns an object with groups of all example definitions (body/header/query/path/response/etc.).\n   * The examples are grouped by their key when defined via the `examples` map.\n   *\n   * Any custom code samples defined via the `x-readme.code-samples` extension are returned,\n   * regardless of if they have a matching response example.\n   *\n   * For standard OAS request parameter (e.g., body/header/query/path/etc.) examples,\n   * they are only present in the return object if they have a corresponding response example\n   * (i.e., a response example with the same key in the `examples` map).\n   */\n  getExampleGroups(): ExampleGroups {\n    if (this.exampleGroups) return this.exampleGroups;\n\n    const groups = getExampleGroups(this);\n\n    this.exampleGroups = groups;\n\n    return groups;\n  }\n}\n\nexport class Callback extends Operation {\n  /**\n   * The identifier that this callback is set to.\n   */\n  identifier: string;\n\n  /**\n   * The parent path item object that this Callback exists within.\n   */\n  parentSchema: RMOAS.PathItemObject;\n\n  constructor(\n    oas: RMOAS.OASDocument,\n    path: string,\n    method: RMOAS.HttpMethods,\n    operation: RMOAS.OperationObject,\n    identifier: string,\n    parentPathItem: RMOAS.PathItemObject,\n  ) {\n    super(oas, path, method, operation);\n\n    this.identifier = identifier;\n    this.parentSchema = parentPathItem;\n  }\n\n  /**\n   * Return the primary identifier for this callback.\n   *\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#callback-object}\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#callback-object}\n   */\n  getIdentifier(): string {\n    return this.identifier;\n  }\n\n  getSummary(): string {\n    if (this.schema?.summary && typeof this.schema.summary === 'string') {\n      return this.schema.summary;\n    } else if (this.parentSchema.summary && typeof this.parentSchema.summary === 'string') {\n      return this.parentSchema.summary;\n    }\n\n    return undefined;\n  }\n\n  getDescription(): string {\n    if (this.schema?.description && typeof this.schema.description === 'string') {\n      return this.schema.description;\n    } else if (this.parentSchema.description && typeof this.parentSchema.description === 'string') {\n      return this.parentSchema.description;\n    }\n\n    return undefined;\n  }\n\n  getParameters(): RMOAS.ParameterObject[] {\n    let parameters = (this.schema?.parameters || []) as RMOAS.ParameterObject[];\n    const commonParams = (this.parentSchema.parameters || []) as RMOAS.ParameterObject[];\n    if (commonParams.length) {\n      parameters = parameters.concat(dedupeCommonParameters(parameters, commonParams) || []);\n    }\n\n    return parameters;\n  }\n}\n\nexport class Webhook extends Operation {\n  /**\n   * OpenAPI API Definition that this webhook originated from.\n   */\n  declare api: RMOAS.OAS31Document;\n\n  getSummary(): string {\n    if (this.schema?.summary && typeof this.schema.summary === 'string') {\n      return this.schema.summary;\n    } else if (this.api.webhooks[this.path].summary && typeof this.api.webhooks[this.path].summary === 'string') {\n      return this.api.webhooks[this.path].summary;\n    }\n\n    return undefined;\n  }\n\n  getDescription(): string {\n    if (this.schema?.description && typeof this.schema.description === 'string') {\n      return this.schema.description;\n    } else if (\n      this.api.webhooks[this.path].description &&\n      typeof this.api.webhooks[this.path].description === 'string'\n    ) {\n      return this.api.webhooks[this.path].description;\n    }\n\n    return undefined;\n  }\n}\n"]}